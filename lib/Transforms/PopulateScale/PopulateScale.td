#ifndef LIB_TRANSFORMS_POPULATESCALE_POPULATESCALE_TD_
#define LIB_TRANSFORMS_POPULATESCALE_POPULATESCALE_TD_

include "mlir/Pass/PassBase.td"

def PopulateScaleBGV : Pass<"populate-scale-bgv"> {
  let summary = "Populate the scale for BGV (GHS variant) ciphertext";
  let description = [{
    In the original BGV scheme, it is required that each modulus in
    the modulus chain is a prime number q such that $q \equiv 1 \pmod{t}$,
    the plaintext modulus. This is to ensure that the after each modulus
    switching, the plaintext message is preserved. However, this limits
    the possible choices of the moduli chain.

    In the GHS variant of BGV, such requirement is removed by introducing
    scaling factor to the ciphertext, with the cost of scale management.
    This pass is responsible for such management.

    This pass relies on concrete SchemeParamAttr annotated on the module
    to determine the scale for each ciphertext. Such annotation can be
    generated by the `generate-param-bgv` pass.

    Example:
    ```mlir
    module attributes {bgv.schemeParam = #bgv.scheme_param<logN = 13, Q = [67239937, 8796093202433], P = [8796093349889], plaintextModulus = 65537>, scheme.bgv} {
      func.func @mul(%arg0: !secret.secret<i16>) -> !secret.secret<i16> {
        %0 = secret.generic ins(%arg0 : !secret.secret<i16>) attrs = {__argattrs = [{mgmt.mgmt = #mgmt.mgmt<level = 1, scale = 1>} ], __resattrs = [{mgmt.mgmt = #mgmt.mgmt<level = 0, scale = 42541>} ]} {
        ^body(%input0: i16):
          %1 = arith.muli %input0, %input0 {mgmt.mgmt = #mgmt.mgmt<level = 1, dimension = 3, scale = 1>} : i16
          %2 = mgmt.relinearize %1 {mgmt.mgmt = #mgmt.mgmt<level = 1, scale = 1>} : i16
          %3 = mgmt.modreduce %2 {mgmt.mgmt = #mgmt.mgmt<level = 0, scale = 42541>} : i16
          secret.yield %3 : i16
        } -> !secret.secret<i16>
        return %0 : !secret.secret<i16>
      }
    }
    ```
  }];
}

def PopulateScaleCKKS : Pass<"populate-scale-ckks"> {
  let summary = "Populate the scale for CKKS ciphertext";
  let description = [{
    In CKKS, each ciphertext is associated with a scaling factor $\Delta$,
    and such scaling factor will change after homomorphic operations
    such as multiplication and modulus reducing.

    However, certain operations such as addition require the input ciphertexts
    to have the same scale. This pass is then responsible for managing the scale
    of the ciphertexts.

    This pass relies on concrete SchemeParamAttr annotated on the module
    to determine the scale for each ciphertext. Such annotation can be
    generated by the `generate-param-ckks` pass.

    The scaling factor is expressed in logarithm form.

    Example:
    ```mlir
    module attributes {ckks.schemeParam = #ckks.scheme_param<logN = 13, Q = [36028797019389953, 35184372121601], P = [36028797019488257], logDefaultScale = 45>, scheme.ckks} {
      func.func @mul(%arg0: !secret.secret<f32>) -> !secret.secret<f32> {
        %0 = secret.generic ins(%arg0 : !secret.secret<f32>) attrs = {__argattrs = [{mgmt.mgmt = #mgmt.mgmt<level = 1, scale = 45>} ], __resattrs = [{mgmt.mgmt = #mgmt.mgmt<level = 0, scale = 45>} ]} {
        ^body(%input0: f32):
          %1 = arith.mulf %input0, %input0 {mgmt.mgmt = #mgmt.mgmt<level = 1, dimension = 3, scale = 90>} : f32
          %2 = mgmt.relinearize %1 {mgmt.mgmt = #mgmt.mgmt<level = 1, scale = 90>} : f32
          %3 = mgmt.modreduce %2 {mgmt.mgmt = #mgmt.mgmt<level = 0, scale = 45>} : f32
          secret.yield %3 : f32
        } -> !secret.secret<f32>
        return %0 : !secret.secret<f32>
      }
    }
    ```
  }];

  let options = [
    Option<"beforeMulIncludeFirstMul", "before-mul-include-first-mul", "bool",
           /*default=*/"false", "Modulus switching before each multiplication, including the first multiplication (default to false)">,
  ];
}


#endif  // LIB_TRANSFORMS_POPULATESCALE_POPULATESCALE_TD_
