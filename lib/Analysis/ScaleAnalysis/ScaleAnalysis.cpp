#include "lib/Analysis/ScaleAnalysis/ScaleAnalysis.h"

#include <cassert>
#include <cmath>
#include <cstdint>
#include <functional>

#include "lib/Analysis/DimensionAnalysis/DimensionAnalysis.h"
#include "lib/Analysis/LevelAnalysis/LevelAnalysis.h"
#include "lib/Analysis/Utils.h"
#include "lib/Dialect/Mgmt/IR/MgmtAttributes.h"
#include "lib/Dialect/Mgmt/IR/MgmtOps.h"
#include "lib/Parameters/BGV/Params.h"
#include "lib/Parameters/CKKS/Params.h"
#include "lib/Utils/APIntUtils.h"
#include "lib/Utils/AttributeUtils.h"
#include "lib/Utils/Utils.h"
#include "llvm/include/llvm/ADT/APInt.h"                   // from @llvm-project
#include "llvm/include/llvm/ADT/TypeSwitch.h"              // from @llvm-project
#include "llvm/include/llvm/Support/Debug.h"               // from @llvm-project
#include "mlir/include/mlir/Analysis/DataFlowFramework.h"  // from @llvm-project
#include "mlir/include/mlir/Dialect/Arith/IR/Arith.h"      // from @llvm-project
#include "mlir/include/mlir/Dialect/Tensor/IR/Tensor.h"    // from @llvm-project
#include "mlir/include/mlir/IR/BuiltinAttributes.h"        // from @llvm-project
#include "mlir/include/mlir/IR/BuiltinTypes.h"             // from @llvm-project
#include "mlir/include/mlir/IR/Operation.h"                // from @llvm-project
#include "mlir/include/mlir/IR/Value.h"                    // from @llvm-project
#include "mlir/include/mlir/IR/Visitors.h"                 // from @llvm-project
#include "mlir/include/mlir/Interfaces/CallInterfaces.h"   // from @llvm-project
#include "mlir/include/mlir/Support/LLVM.h"                // from @llvm-project

#define DEBUG_TYPE "ScaleAnalysis"

namespace mlir {
namespace heir {

//===----------------------------------------------------------------------===//
// ScaleModel
//===----------------------------------------------------------------------===//

llvm::APInt BGVScaleModel::evalMulScale(const bgv::LocalParam& param,
                                        const llvm::APInt& lhs,
                                        const llvm::APInt& rhs) {
  const auto* schemeParam = param.getSchemeParam();
  auto t = llvm::APInt(64, schemeParam->getPlaintextModulus());
  // (lhs * rhs) % t
  return (lhs * rhs).urem(t);
}

llvm::APInt BGVScaleModel::evalMulScaleBackward(const bgv::LocalParam& param,
                                                const llvm::APInt& result,
                                                const llvm::APInt& lhs) {
  const auto* schemeParam = param.getSchemeParam();
  auto t = llvm::APInt(64, schemeParam->getPlaintextModulus());
  auto lhsInv = multiplicativeInverse(lhs, t);
  // (result * lhsInv) % t
  return (result * lhsInv).urem(t);
}

llvm::APInt BGVScaleModel::evalModReduceScale(const bgv::LocalParam& inputParam,
                                              const llvm::APInt& scale) {
  const auto* schemeParam = inputParam.getSchemeParam();
  auto t = llvm::APInt(64, schemeParam->getPlaintextModulus());
  auto qi = schemeParam->getQi();
  auto level = inputParam.getCurrentLevel();
  auto qiModT = llvm::APInt(64, qi[level]).urem(t);
  auto qInvT = multiplicativeInverse(qiModT, t);
  // (scale * qInvT) % t
  return (scale * qInvT).urem(t);
}

llvm::APInt BGVScaleModel::evalModReduceScaleBackward(
    const bgv::LocalParam& inputParam, const llvm::APInt& resultScale) {
  const auto* schemeParam = inputParam.getSchemeParam();
  auto t = llvm::APInt(64, schemeParam->getPlaintextModulus());
  auto qi = schemeParam->getQi();
  auto level = inputParam.getCurrentLevel();
  auto qiModT = llvm::APInt(64, qi[level]).urem(t);
  // (resultScale * qiModT) % t
  return (resultScale * qiModT).urem(t);
}

llvm::APInt CKKSScaleModel::evalMulScale(const ckks::LocalParam& param,
                                         const llvm::APInt& lhs,
                                         const llvm::APInt& rhs) {
  // High-precision scale management (#2364): multiply actual scales
  // In CKKS, ct1 * ct2 with scales s1, s2 produces ciphertext with scale s1*s2
  return lhs * rhs;
}

llvm::APInt CKKSScaleModel::evalMulScaleBackward(const ckks::LocalParam& param,
                                                 const llvm::APInt& result,
                                                 const llvm::APInt& lhs) {
  // High-precision scale management (#2364): divide actual scales
  // If result = lhs * rhs, then rhs = result / lhs
  // Handle uninitialized scales (zero) - can't infer from uninitialized values
  if (lhs.isZero() || result.isZero()) {
    return llvm::APInt(64, 0);
  }
  return result.udiv(lhs);
}

llvm::APInt CKKSScaleModel::evalModReduceScale(
    const ckks::LocalParam& inputParam, const llvm::APInt& scale) {
  const auto* schemeParam = inputParam.getSchemeParam();
  // High-precision scale management (#2364): divide by actual qi value
  // Rescaling divides the ciphertext modulus by qi[level] and the scale by
  // qi[level]
  auto qi = schemeParam->getQi();
  auto level = inputParam.getCurrentLevel();

  // If qi is not populated, fall back to using default scale
  if (qi.empty() || level >= static_cast<int>(qi.size())) {
    // Fallback: use 2^logDefaultScale as the rescaling factor
    auto logDefaultScale = schemeParam->getLogDefaultScale();
    llvm::APInt defaultScale(scale.getBitWidth(), 1);
    defaultScale = defaultScale.shl(logDefaultScale);
    return scale.udiv(defaultScale);
  }

  llvm::APInt qiVal(scale.getBitWidth(), qi[level]);
  return scale.udiv(qiVal);
}

llvm::APInt CKKSScaleModel::evalModReduceScaleBackward(
    const ckks::LocalParam& inputParam, const llvm::APInt& resultScale) {
  const auto* schemeParam = inputParam.getSchemeParam();
  // High-precision scale management (#2364): multiply by actual qi value
  // Reverse of evalModReduceScale: if result = scale / qi, then scale = result
  // * qi
  auto qi = schemeParam->getQi();
  auto level = inputParam.getCurrentLevel();

  // If qi is not populated, fall back to using default scale
  if (qi.empty() || level >= static_cast<int>(qi.size())) {
    // Fallback: use 2^logDefaultScale as the rescaling factor
    auto logDefaultScale = schemeParam->getLogDefaultScale();
    llvm::APInt defaultScale(resultScale.getBitWidth(), 1);
    defaultScale = defaultScale.shl(logDefaultScale);
    return resultScale * defaultScale;
  }

  llvm::APInt qiVal(resultScale.getBitWidth(), qi[level]);
  return resultScale * qiVal;
}

//===----------------------------------------------------------------------===//
// ScaleAnalysis (Forward)
//===----------------------------------------------------------------------===//

template <typename ScaleModelT>
LogicalResult ScaleAnalysis<ScaleModelT>::visitOperation(
    Operation* op, ArrayRef<const ScaleLattice*> operands,
    ArrayRef<ScaleLattice*> results) {
  auto getLocalParam = [&](Value value) {
    auto level = getLevelFromMgmtAttr(value);
    auto dimension = getDimensionFromMgmtAttr(value);
    return LocalParamType(&schemeParam, level, dimension);
  };

  auto propagate = [&](Value value, const ScaleState& state) {
    auto* lattice = getLatticeElement(value);
    ChangeResult changed = lattice->join(state);
    if (changed == ChangeResult::Change) {
      LLVM_DEBUG(llvm::dbgs()
                 << "Propagate " << state << " to " << value << "\n");
    }
    propagateIfChanged(lattice, changed);
  };

  auto getOperandScales = [&](Operation* op,
                              SmallVectorImpl<llvm::APInt>& scales) {
    SmallVector<OpOperand*> secretOperands;
    this->getSecretOperands(op, secretOperands);

    for (auto* operand : secretOperands) {
      auto operandState = getLatticeElement(operand->get())->getValue();
      if (!operandState.isInitialized()) {
        continue;
      }
      scales.push_back(operandState.getScale());
    }
    if (scales.size() > 1) {
      if (scales[0] != scales[1]) {
        LLVM_DEBUG(llvm::dbgs() << "Different scales: " << scales[0] << ", "
                                << scales[1] << " for " << *op << "\n");
      }
    }
  };

  llvm::TypeSwitch<Operation&>(*op)
      .template Case<arith::MulIOp, arith::MulFOp>([&](auto mulOp) {
        SmallVector<llvm::APInt> scales;
        getOperandScales(mulOp, scales);
        // there must be at least one secret operand that has scale
        if (scales.empty()) {
          return;
        }
        auto scaleLhs = scales[0];
        auto scaleRhs = scaleLhs;
        // default to the same scale for both operand
        if (scales.size() > 1) {
          scaleRhs = scales[1];
        }

        // propagate scale to result
        auto result = ScaleModelT::evalMulScale(
            getLocalParam(mulOp.getResult()), scaleLhs, scaleRhs);
        propagate(mulOp.getResult(), ScaleState(result));
      })
      .template Case<mgmt::ModReduceOp>([&](auto modReduceOp) {
        SmallVector<llvm::APInt> scales;
        getOperandScales(modReduceOp, scales);
        // there must be at least one secret operand that has scale
        if (scales.empty()) {
          return;
        }

        // propagate scale to result
        auto scale = scales[0];
        // get level of the operand.
        auto newScale = ScaleModelT::evalModReduceScale(
            getLocalParam(modReduceOp.getInput()), scale);

        propagate(modReduceOp.getResult(), ScaleState(newScale));
      })
      .template Case<mgmt::AdjustScaleOp>([&](auto adjustScaleOp) {
        // adjust scale op is opaque, just do not propagate
        return;
      })
      .template Case<mgmt::InitOp>([&](auto initOp) {
        auto mgmtAttr = mgmt::findMgmtAttrAssociatedWith(initOp.getResult());
        // if there is scale annotation, use it
        if (mgmtAttr && mgmtAttr.getScale() != 0) {
          propagate(initOp.getResult(), ScaleState(mgmtAttr.getScale()));
        }
      })
      .Default([&](auto& op) {
        // condition on result secretness
        SmallVector<OpResult> secretResults;
        this->getSecretResults(&op, secretResults);
        if (secretResults.empty()) {
          return;
        }

        SmallVector<llvm::APInt> scales;
        getOperandScales(&op, scales);
        if (scales.empty()) {
          return;
        }

        // just propagate the scale
        for (auto result : secretResults) {
          propagate(result, ScaleState(scales[0]));
        }
      });
  return success();
}

template <typename ScaleModelT>
void ScaleAnalysis<ScaleModelT>::visitExternalCall(
    CallOpInterface call, ArrayRef<const ScaleLattice*> argumentLattices,
    ArrayRef<ScaleLattice*> resultLattices) {
  auto callback = std::bind(&ScaleAnalysis::propagateIfChangedWrapper, this,
                            std::placeholders::_1, std::placeholders::_2);
  ::mlir::heir::visitExternalCall<ScaleState, ScaleLattice>(
      call, argumentLattices, resultLattices, callback);
}

// instantiation
template class ScaleAnalysis<BGVScaleModel>;
template class ScaleAnalysis<CKKSScaleModel>;

//===----------------------------------------------------------------------===//
// ScaleAnalysis (Backward)
//===----------------------------------------------------------------------===//

template <typename ScaleModelT>
LogicalResult ScaleAnalysisBackward<ScaleModelT>::visitOperation(
    Operation* op, ArrayRef<ScaleLattice*> operands,
    ArrayRef<const ScaleLattice*> results) {
  auto getLocalParam = [&](Value value) {
    auto level = getLevelFromMgmtAttr(value);
    auto dimension = getDimensionFromMgmtAttr(value);
    return LocalParamType(&schemeParam, level, dimension);
  };

  auto propagate = [&](Value value, const ScaleState& state) {
    auto* lattice = getLatticeElement(value);
    ChangeResult changed = lattice->join(state);
    if (changed == ChangeResult::Change) {
      LLVM_DEBUG(llvm::dbgs()
                 << "Back Propagate " << state << " to " << value << "\n");
    }
    propagateIfChanged(lattice, changed);
  };

  auto getSecretOrInittedOperands =
      [&](Operation* op, SmallVectorImpl<OpOperand*>& secretOperands) {
        this->getSecretOperands(op, secretOperands);
        for (auto& opOperand : op->getOpOperands()) {
          if (!this->isSecretInternal(op, opOperand.get()) &&
              isa_and_nonnull<mgmt::InitOp>(opOperand.get().getDefiningOp())) {
            // Treat it as if it were secret for the purpose of scale
            // propagation
            secretOperands.push_back(&opOperand);
          }
        }
      };

  auto getOperandScales =
      [&](Operation* op, SmallVectorImpl<int64_t>& operandWithoutScaleIndices,
          SmallVectorImpl<llvm::APInt>& scales) {
        LLVM_DEBUG(llvm::dbgs()
                   << "Operand scales for " << op->getName() << ": ");
        SmallVector<OpOperand*> secretOperands;
        getSecretOrInittedOperands(op, secretOperands);

        for (auto* operand : secretOperands) {
          auto operandState = getLatticeElement(operand->get())->getValue();
          if (!operandState.isInitialized()) {
            LLVM_DEBUG(llvm::dbgs()
                       << "o" << operand->getOperandNumber() << "(uninit), ");
            operandWithoutScaleIndices.push_back(operand->getOperandNumber());
            continue;
          }
          LLVM_DEBUG(llvm::dbgs() << "o" << operand->getOperandNumber() << "("
                                  << operandState.getScale() << "), ");
          scales.push_back(operandState.getScale());
        }
        if (scales.size() > 1) {
          if (scales[0] != scales[1]) {
            LLVM_DEBUG(llvm::dbgs() << "Different scales: " << scales[0] << ", "
                                    << scales[1] << " for " << *op << "\n");
          }
        }
        LLVM_DEBUG(llvm::dbgs() << "\n");
      };

  auto getResultScales = [&](Operation* op,
                             SmallVectorImpl<llvm::APInt>& scales) {
    LLVM_DEBUG(llvm::dbgs() << "Result scales for " << op->getName() << ": ");
    SmallVector<OpResult> secretResults;
    this->getSecretResults(op, secretResults);

    for (auto result : secretResults) {
      auto resultState = getLatticeElement(result)->getValue();
      if (!resultState.isInitialized()) {
        continue;
      }
      LLVM_DEBUG(llvm::dbgs() << "r" << cast<OpResult>(result).getResultNumber()
                              << "(" << resultState.getScale() << "), ");
      scales.push_back(resultState.getScale());
    }
    LLVM_DEBUG(llvm::dbgs() << "\n");
  };

  LLVM_DEBUG(llvm::dbgs() << "Backward analysis visiting: " << op->getName()
                          << "\n");
  llvm::TypeSwitch<Operation&>(*op)
      .template Case<arith::MulIOp, arith::MulFOp>([&](auto mulOp) {
        SmallVector<llvm::APInt> resultScales;
        getResultScales(mulOp, resultScales);
        // there must be at least one secret result that has scale
        if (resultScales.empty()) {
          return;
        }
        SmallVector<int64_t> operandWithoutScaleIndices;
        SmallVector<llvm::APInt> operandScales;
        getOperandScales(mulOp, operandWithoutScaleIndices, operandScales);
        // there must be at least one secret operand that has scale
        if (operandScales.empty()) {
          mulOp->emitError("No secret operand has scale");
          return;
        }
        // two operands have scale, succeed.
        if (operandScales.size() > 1) {
          return;
        }
        auto presentScale = operandScales[0];

        // propagate scale to other operand
        auto scaleOther = ScaleModelT::evalMulScaleBackward(
            getLocalParam(mulOp.getResult()), resultScales[0], presentScale);
        propagate(mulOp->getOperand(operandWithoutScaleIndices[0]),
                  ScaleState(scaleOther));
      })
      .template Case<mgmt::ModReduceOp>([&](auto modReduceOp) {
        SmallVector<llvm::APInt> resultScales;
        getResultScales(modReduceOp, resultScales);
        // there must be at least one secret result that has scale
        if (resultScales.empty()) {
          return;
        }
        SmallVector<int64_t> operandWithoutScaleIndices;
        SmallVector<llvm::APInt> scales;
        getOperandScales(modReduceOp, operandWithoutScaleIndices, scales);
        // if all operands have scale, succeed.
        if (!scales.empty()) {
          return;
        }

        // propagate scale to operand
        auto resultScale = resultScales[0];
        // get level of the operand.
        auto newScale = ScaleModelT::evalModReduceScaleBackward(
            getLocalParam(modReduceOp.getInput()), resultScale);

        propagate(modReduceOp.getInput(), ScaleState(newScale));
      })
      .template Case<mgmt::AdjustScaleOp>([&](auto adjustScaleOp) {
        // Do not back propagate through adjust scale op
        return;
      })
      .Default([&](auto& op) {
        // condition on result secretness
        SmallVector<OpResult> secretResults;
        this->getSecretResults(&op, secretResults);
        if (secretResults.empty()) {
          return;
        }

        SmallVector<llvm::APInt> scales;
        getResultScales(&op, scales);
        if (scales.empty()) {
          return;
        }

        // propagate the scale to all operands
        // including plaintext (non-secret)
        for (auto operand : op.getOperands()) {
          propagate(operand, ScaleState(scales[0]));
        }
      });
  return success();
}

// instantiation
template class ScaleAnalysisBackward<BGVScaleModel>;
template class ScaleAnalysisBackward<CKKSScaleModel>;

//===----------------------------------------------------------------------===//
// Utils
//===----------------------------------------------------------------------===//

llvm::APInt getScale(Value value, DataFlowSolver* solver) {
  auto* lattice = solver->lookupState<ScaleLattice>(value);
  if (!lattice) {
    assert(false && "ScaleLattice not found");
    return llvm::APInt(64, 0);
  }
  if (!lattice->getValue().isInitialized()) {
    assert(false && "ScaleLattice not initialized");
    return llvm::APInt(64, 0);
  }
  return lattice->getValue().getScale();
}

llvm::APInt getScaleFromMgmtAttr(Value value) {
  auto mgmtAttr = mgmt::findMgmtAttrAssociatedWith(value);
  if (!mgmtAttr) {
    assert(false && "MgmtAttr not found");
    return llvm::APInt(64, 0);
  }
  // High-precision scale management (#2364): MgmtAttr now stores APInt directly
  return mgmtAttr.getScale();
}

void annotateScale(Operation* top, DataFlowSolver* solver) {
  auto getStringAttr = [&](const llvm::APInt& scale) {
    // Store APInt as a string in base 10 for full precision
    llvm::SmallString<64> str;
    scale.toString(str, 10, /*Signed=*/false);
    return StringAttr::get(top->getContext(), str);
  };

  walkValues(top, [&](Value value) {
    if (mgmt::shouldHaveMgmtAttribute(value, solver)) {
      setAttributeAssociatedWith(value, kArgScaleAttrName,
                                 getStringAttr(getScale(value, solver)));
    }
  });
}

}  // namespace heir
}  // namespace mlir
