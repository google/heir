Loading:
Loading:
Loading: 0 packages loaded
Analyzing: target //tools:heir-opt (0 packages loaded, 0 targets configured)
INFO: Analyzed target //tools:heir-opt (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
[0 / 4] [Prepa] BazelWorkspaceStatusAction stable-status.txt ... (2 actions, 0 running)
[1 / 4] Compiling lib/Dialect/Arith/Conversions/ArithToModArith/ArithToModArith.cpp; 1s linux-sandbox
[2 / 4] [Prepa] Linking tools/heir-opt
[2 / 4] Linking tools/heir-opt; 1s linux-sandbox
Target //tools:heir-opt up-to-date:
  bazel-bin/tools/heir-opt
INFO: Elapsed time: 13.078s, Critical Path: 12.68s
INFO: 3 processes: 1 internal, 2 linux-sandbox.
INFO: Build completed successfully, 3 total actions
INFO: Running command line: bazel-bin/tools/heir-opt --arith-to-mod-arith --debug /usr/local/google/home/legiest/heir/tests/Dialect/Arith/Conversions/ArithToModArith/arith-to-mod-arith.mlir
Args: /usr/local/google/home/legiest/.cache/bazel/_bazel_legiest/0167411e4815a34188c70d6ec5fca69a/execroot/heir/bazel-out/k8-dbg/bin/tools/heir-opt --arith-to-mod-arith --debug /usr/local/google/home/legiest/heir/tests/Dialect/Arith/Conversions/ArithToModArith/arith-to-mod-arith.mlir
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DistinctAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ResourceBlobManagerDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context memref
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithFastMathInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithDenormalModeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithIntegerOverflowFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithRoundingModeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SelectLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConvertToLLVMPatternInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferDeallocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ValueBoundsOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CopyOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableMemOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAccessorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableAllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedDimOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ReifyRankedShapedTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OffsetSizeAndStrideOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::AllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RuntimeVerifiableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::memref::detail::GlobalOpGenericAdaptorBase::Properties)
Load new dialect in Context func
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
Load new dialect in Context cf
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::mesh::ShardingInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::memref::detail::GetGlobalOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AttrSizedOperandSegments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::memref::detail::AllocOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableMemOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAccessorOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultShape<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Elementwise<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Scalarizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Vectorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Tensorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsCommutative<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithIntegerOverflowFlagsInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultType<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
Load new dialect in Context mod_arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::heir::rns::RNSBasisTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::OpToOpPassAdaptor)

//===-------------------------------------------===//
Legalizing operation : 'builtin.module'(0x5558ae301090) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.global'(0x5558ae2f6810) {
  "memref.global"() <{alignment = 64 : i64, constant, initial_value = dense<[-729, 1954, 610, 0, 241, -471, -35, -867, 571, 581, 4260, 3943, 591, 0, -889, -5103]> : tensor<16xi32>, sym_name = "__constant_16xi32_0", sym_visibility = "private", type = memref<16xi32>}> : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.global'(0x5558ae2f8c10) {
  "memref.global"() <{alignment = 64 : i64, constant, initial_value = dense<[[-9], [-54], [57], [71], [104], [115], [98], [99], [64], [-26], [127], [25], [-82], [68], [95], [86]]> : tensor<16x1xi8>, sym_name = "__constant_16x1xi8", sym_visibility = "private", type = memref<16x1xi8>}> : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x5558ae2eda50) {
  * Fold {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "(anonymous namespace)::FunctionOpInterfaceSignatureConversion"
    ** Insert Block into : 'func.func'(0x5558ae2eda50)
"(anonymous namespace)::FunctionOpInterfaceSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.func'(0x5558ae2eda50) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
type of return operand 0 ('i32') doesn't match function result type ('!mod_arith.int<2147483647 : i32>') in function @main
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "memref.global"() <{alignment = 64 : i64, constant, initial_value = dense<[-729, 1954, 610, 0, 241, -471, -35, -867, 571, 581, 4260, 3943, 591, 0, -889, -5103]> : tensor<16xi32>, sym_name = "__constant_16xi32_0", sym_visibility = "private", type = memref<16xi32>}> : () -> ()
  "memref.global"() <{alignment = 64 : i64, constant, initial_value = dense<[[-9], [-54], [57], [71], [104], [115], [98], [99], [64], [-26], [127], [25], [-82], [68], [95], [86]]> : tensor<16x1xi8>, sym_name = "__constant_16x1xi8", sym_visibility = "private", type = memref<16x1xi8>}> : () -> ()
  "func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
  ^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
    %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
    %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
    %2 = "arith.constant"() <{value = 429 : i32}> : () -> i32
    %3 = "arith.constant"() <{value = 0 : index}> : () -> index
    %4 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
    %5 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
    %6 = "memref.load"(%4, %3, %3) : (memref<16x1xi8>, index, index) -> i8
    %7 = "memref.load"(<<UNKNOWN SSA VALUE>>, %3, %3) : (memref<1x1xi8>, index, index) -> i8
    %8 = "arith.extsi"(%7) : (i8) -> i32
    %9 = "arith.extsi"(%6) : (i8) -> i32
    %10 = "arith.muli"(%8, %9) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
    %11 = "arith.addi"(%10, %10) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
    %12 = "arith.muli"(%11, %10) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
    %13 = "arith.addi"(%11, %12) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
    "func.return"(%13) : (i32) -> ()
  }) : () -> ()
}) {tf_saved_model.semantics} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x5558ae2fcd30) {
  %2 = "arith.constant"() <{value = 429 : i32}> : () -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "mlir::heir::arith::ConvertConstant"
ImplicitTypeIDRegistry::lookupOrInsert(mlir::heir::mod_arith::detail::ConstantOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::heir::mod_arith::ModArithType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::InferTypeOpAdaptor<Empty>)
    ** Insert  : 'mod_arith.constant'(0x5558ae30f910)
    ** Replace : 'arith.constant'(0x5558ae2fcd30)
"mlir::heir::arith::ConvertConstant" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'mod_arith.constant'(0x5558ae30f910) {
      %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
type of return operand 0 ('i32') doesn't match function result type ('!mod_arith.int<2147483647 : i32>') in function @main
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
  %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
  %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>
  %3 = "arith.constant"() <{value = 429 : i32}> : () -> i32
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8
  %8 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8
  %9 = "arith.extsi"(%8) : (i8) -> i32
  %10 = "arith.extsi"(%7) : (i8) -> i32
  %11 = "arith.muli"(%9, %10) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %12 = "arith.addi"(%11, %11) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %13 = "arith.muli"(%12, %11) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %14 = "arith.addi"(%12, %13) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  "func.return"(%14) : (i32) -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x5558ae2fce00) {
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.get_global'(0x5558ae2fd7b0) {
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.alloc'(0x5558ae2fdce0) {
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.load'(0x5558ae2fe210) {
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.load'(0x5558ae2fe340) {
  %8 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'memref.load -> ()' {
Trying to match "mlir::heir::arith::ConvertMemRefLoad"
################################### ConverMemRefLoad
    ** Insert  : 'memref.load'(0x5558ae30ce80)
    ** Replace : 'memref.load'(0x5558ae2fe340)
"mlir::heir::arith::ConvertMemRefLoad" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'memref.load'(0x5558ae30ce80) {
      %8 = "memref.load"(%1, %4, %4) : (memref<1x1x!mod_arith.int<127 : i8>>, index, index) -> !mod_arith.int<127 : i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
type of return operand 0 ('i32') doesn't match function result type ('!mod_arith.int<2147483647 : i32>') in function @main
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
  %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
  %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>
  %3 = "arith.constant"() <{value = 429 : i32}> : () -> i32
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8
  %8 = "memref.load"(%1, %4, %4) : (memref<1x1x!mod_arith.int<127 : i8>>, index, index) -> !mod_arith.int<127 : i8>
  %9 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8
  %10 = "arith.extsi"(%9) : (i8) -> i32
  %11 = "arith.extsi"(%7) : (i8) -> i32
  %12 = "arith.muli"(%10, %11) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %13 = "arith.addi"(%12, %12) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %14 = "arith.muli"(%13, %12) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %15 = "arith.addi"(%13, %14) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  "func.return"(%15) : (i32) -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.extsi'(0x5558ae2ecf10) {
  %10 = "arith.extsi"(%9) : (i8) -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.extsi -> ()' {
Trying to match "mlir::heir::arith::ConvertExt"
    ** Insert  : 'mod_arith.encapsulate'(0x5558ae30d060)
    ** Insert  : 'mod_arith.mod_switch'(0x5558ae30d0f0)
    ** Replace : 'arith.extsi'(0x5558ae2ecf10)
"mlir::heir::arith::ConvertExt" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'mod_arith.encapsulate'(0x5558ae30d060) {
      %10 = "mod_arith.encapsulate"(%9) : (i8) -> !mod_arith.int<127 : i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'mod_arith.mod_switch'(0x5558ae30d0f0) {
      %11 = "mod_arith.mod_switch"(%10) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
type of return operand 0 ('i32') doesn't match function result type ('!mod_arith.int<2147483647 : i32>') in function @main
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
  %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
  %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>
  %3 = "arith.constant"() <{value = 429 : i32}> : () -> i32
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8
  %8 = "memref.load"(%1, %4, %4) : (memref<1x1x!mod_arith.int<127 : i8>>, index, index) -> !mod_arith.int<127 : i8>
  %9 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8
  %10 = "mod_arith.encapsulate"(%9) : (i8) -> !mod_arith.int<127 : i8>
  %11 = "mod_arith.mod_switch"(%10) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %12 = "arith.extsi"(%9) : (i8) -> i32
  %13 = "arith.extsi"(%7) : (i8) -> i32
  %14 = "arith.muli"(%12, %13) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %15 = "arith.addi"(%14, %14) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %16 = "arith.muli"(%15, %14) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %17 = "arith.addi"(%15, %16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  "func.return"(%17) : (i32) -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.extsi'(0x5558ae2ed000) {
  %13 = "arith.extsi"(%7) : (i8) -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.extsi -> ()' {
Trying to match "mlir::heir::arith::ConvertExt"
    ** Insert  : 'mod_arith.encapsulate'(0x5558ae30d240)
    ** Insert  : 'mod_arith.mod_switch'(0x5558ae30d2d0)
    ** Replace : 'arith.extsi'(0x5558ae2ed000)
"mlir::heir::arith::ConvertExt" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'mod_arith.encapsulate'(0x5558ae30d240) {
      %14 = "mod_arith.encapsulate"(%7) : (i8) -> !mod_arith.int<127 : i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'mod_arith.mod_switch'(0x5558ae30d2d0) {
      %15 = "mod_arith.mod_switch"(%14) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
type of return operand 0 ('i32') doesn't match function result type ('!mod_arith.int<2147483647 : i32>') in function @main
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
  %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
  %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>
  %3 = "arith.constant"() <{value = 429 : i32}> : () -> i32
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8
  %8 = "builtin.unrealized_conversion_cast"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %9 = "memref.load"(%1, %4, %4) : (memref<1x1x!mod_arith.int<127 : i8>>, index, index) -> !mod_arith.int<127 : i8>
  %10 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8
  %11 = "mod_arith.encapsulate"(%10) : (i8) -> !mod_arith.int<127 : i8>
  %12 = "mod_arith.mod_switch"(%11) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %13 = "arith.extsi"(%10) : (i8) -> i32
  %14 = "mod_arith.encapsulate"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %15 = "mod_arith.mod_switch"(%14) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %16 = "arith.extsi"(%7) : (i8) -> i32
  %17 = "arith.muli"(%13, %16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %18 = "arith.addi"(%17, %17) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %19 = "arith.muli"(%18, %17) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %20 = "arith.addi"(%18, %19) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  "func.return"(%20) : (i32) -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.muli'(0x5558ae2de1a0) {
  %17 = "arith.muli"(%13, %16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.muli -> ()' {
Trying to match "mlir::heir::arith::ConvertBinOp<mlir::arith::MulIOp, mlir::heir::mod_arith::MulOp>"
    ** Insert  : 'mod_arith.mul'(0x5558ae2ebed0)
    ** Replace : 'arith.muli'(0x5558ae2de1a0)
"mlir::heir::arith::ConvertBinOp<mlir::arith::MulIOp, mlir::heir::mod_arith::MulOp>" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'mod_arith.mul'(0x5558ae2ebed0) {
      %17 = "mod_arith.mul"(%12, %15) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
type of return operand 0 ('i32') doesn't match function result type ('!mod_arith.int<2147483647 : i32>') in function @main
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
  %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
  %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>
  %3 = "arith.constant"() <{value = 429 : i32}> : () -> i32
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8
  %8 = "builtin.unrealized_conversion_cast"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %9 = "memref.load"(%1, %4, %4) : (memref<1x1x!mod_arith.int<127 : i8>>, index, index) -> !mod_arith.int<127 : i8>
  %10 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8
  %11 = "mod_arith.encapsulate"(%10) : (i8) -> !mod_arith.int<127 : i8>
  %12 = "mod_arith.mod_switch"(%11) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %13 = "arith.extsi"(%10) : (i8) -> i32
  %14 = "mod_arith.encapsulate"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %15 = "mod_arith.mod_switch"(%14) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %16 = "arith.extsi"(%7) : (i8) -> i32
  %17 = "mod_arith.mul"(%12, %15) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %18 = "arith.muli"(%13, %16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %19 = "arith.addi"(%18, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %20 = "arith.muli"(%19, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %21 = "arith.addi"(%19, %20) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  "func.return"(%21) : (i32) -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.addi'(0x5558ae2faca0) {
  %19 = "arith.addi"(%18, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.addi -> ()' {
Trying to match "mlir::heir::arith::ConvertBinOp<mlir::arith::AddIOp, mlir::heir::mod_arith::AddOp>"
    ** Insert  : 'mod_arith.add'(0x5558ae30e520)
    ** Replace : 'arith.addi'(0x5558ae2faca0)
"mlir::heir::arith::ConvertBinOp<mlir::arith::AddIOp, mlir::heir::mod_arith::AddOp>" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'mod_arith.add'(0x5558ae30e520) {
      %19 = "mod_arith.add"(%17, %17) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
type of return operand 0 ('i32') doesn't match function result type ('!mod_arith.int<2147483647 : i32>') in function @main
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
  %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
  %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>
  %3 = "arith.constant"() <{value = 429 : i32}> : () -> i32
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8
  %8 = "builtin.unrealized_conversion_cast"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %9 = "memref.load"(%1, %4, %4) : (memref<1x1x!mod_arith.int<127 : i8>>, index, index) -> !mod_arith.int<127 : i8>
  %10 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8
  %11 = "mod_arith.encapsulate"(%10) : (i8) -> !mod_arith.int<127 : i8>
  %12 = "mod_arith.mod_switch"(%11) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %13 = "arith.extsi"(%10) : (i8) -> i32
  %14 = "mod_arith.encapsulate"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %15 = "mod_arith.mod_switch"(%14) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %16 = "arith.extsi"(%7) : (i8) -> i32
  %17 = "mod_arith.mul"(%12, %15) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %18 = "arith.muli"(%13, %16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %19 = "mod_arith.add"(%17, %17) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %20 = "arith.addi"(%18, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %21 = "arith.muli"(%20, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %22 = "arith.addi"(%20, %21) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  "func.return"(%22) : (i32) -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.muli'(0x5558ae2ed620) {
  %21 = "arith.muli"(%20, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.muli -> ()' {
Trying to match "mlir::heir::arith::ConvertBinOp<mlir::arith::MulIOp, mlir::heir::mod_arith::MulOp>"
    ** Insert  : 'mod_arith.mul'(0x5558ae30e5d0)
    ** Replace : 'arith.muli'(0x5558ae2ed620)
"mlir::heir::arith::ConvertBinOp<mlir::arith::MulIOp, mlir::heir::mod_arith::MulOp>" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'mod_arith.mul'(0x5558ae30e5d0) {
      %21 = "mod_arith.mul"(%19, %17) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
type of return operand 0 ('i32') doesn't match function result type ('!mod_arith.int<2147483647 : i32>') in function @main
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
  %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
  %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>
  %3 = "arith.constant"() <{value = 429 : i32}> : () -> i32
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8
  %8 = "builtin.unrealized_conversion_cast"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %9 = "memref.load"(%1, %4, %4) : (memref<1x1x!mod_arith.int<127 : i8>>, index, index) -> !mod_arith.int<127 : i8>
  %10 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8
  %11 = "mod_arith.encapsulate"(%10) : (i8) -> !mod_arith.int<127 : i8>
  %12 = "mod_arith.mod_switch"(%11) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %13 = "arith.extsi"(%10) : (i8) -> i32
  %14 = "mod_arith.encapsulate"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %15 = "mod_arith.mod_switch"(%14) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %16 = "arith.extsi"(%7) : (i8) -> i32
  %17 = "mod_arith.mul"(%12, %15) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %18 = "arith.muli"(%13, %16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %19 = "mod_arith.add"(%17, %17) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %20 = "arith.addi"(%18, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %21 = "mod_arith.mul"(%19, %17) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %22 = "arith.muli"(%20, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %23 = "arith.addi"(%20, %22) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  "func.return"(%23) : (i32) -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.addi'(0x5558ae2ed730) {
  %23 = "arith.addi"(%20, %22) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.addi -> ()' {
Trying to match "mlir::heir::arith::ConvertBinOp<mlir::arith::AddIOp, mlir::heir::mod_arith::AddOp>"
    ** Insert  : 'mod_arith.add'(0x5558ae30e6b0)
    ** Replace : 'arith.addi'(0x5558ae2ed730)
"mlir::heir::arith::ConvertBinOp<mlir::arith::AddIOp, mlir::heir::mod_arith::AddOp>" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'mod_arith.add'(0x5558ae30e6b0) {
      %23 = "mod_arith.add"(%19, %21) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
type of return operand 0 ('i32') doesn't match function result type ('!mod_arith.int<2147483647 : i32>') in function @main
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
  %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
  %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>
  %3 = "arith.constant"() <{value = 429 : i32}> : () -> i32
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8
  %8 = "builtin.unrealized_conversion_cast"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %9 = "memref.load"(%1, %4, %4) : (memref<1x1x!mod_arith.int<127 : i8>>, index, index) -> !mod_arith.int<127 : i8>
  %10 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8
  %11 = "mod_arith.encapsulate"(%10) : (i8) -> !mod_arith.int<127 : i8>
  %12 = "mod_arith.mod_switch"(%11) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %13 = "arith.extsi"(%10) : (i8) -> i32
  %14 = "mod_arith.encapsulate"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %15 = "mod_arith.mod_switch"(%14) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %16 = "arith.extsi"(%7) : (i8) -> i32
  %17 = "mod_arith.mul"(%12, %15) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %18 = "arith.muli"(%13, %16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %19 = "mod_arith.add"(%17, %17) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %20 = "arith.addi"(%18, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %21 = "mod_arith.mul"(%19, %17) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %22 = "arith.muli"(%20, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %23 = "mod_arith.add"(%19, %21) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %24 = "arith.addi"(%20, %22) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  "func.return"(%24) : (i32) -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x5558ae2ed9d0) {
  "func.return"(%24) : (i32) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::ReturnOpTypeConversion"
    ** Insert  : 'func.return'(0x5558ae306b80)
    ** Replace : 'func.return'(0x5558ae2ed9d0)
"(anonymous namespace)::ReturnOpTypeConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.return'(0x5558ae306b80) {
      "func.return"(%23) : (!mod_arith.int<2147483647 : i32>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
'func.return' op must be the last operation in the parent block
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<1x1x!mod_arith.int<127 : i8>>) -> !mod_arith.int<2147483647 : i32>, sym_name = "main"}> ({
^bb0(%arg0: memref<1x1x!mod_arith.int<127 : i8>>):
  %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<1x1x!mod_arith.int<127 : i8>>) -> memref<1x1xi8>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<1x1xi8>) -> memref<1x1x!mod_arith.int<127 : i8>>
  %2 = "mod_arith.constant"() <{value = #mod_arith<int 429 : i32 : <2147483647 : i32>> : !mod_arith.int<2147483647 : i32>}> : () -> !mod_arith.int<2147483647 : i32>
  %3 = "arith.constant"() <{value = 429 : i32}> : () -> i32
  %4 = "arith.constant"() <{value = 0 : index}> : () -> index
  %5 = "memref.get_global"() <{name = @__constant_16x1xi8}> : () -> memref<16x1xi8>
  %6 = "memref.alloc"() <{alignment = 64 : i64, operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x1xi32>
  %7 = "memref.load"(%5, %4, %4) : (memref<16x1xi8>, index, index) -> i8
  %8 = "builtin.unrealized_conversion_cast"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %9 = "memref.load"(%1, %4, %4) : (memref<1x1x!mod_arith.int<127 : i8>>, index, index) -> !mod_arith.int<127 : i8>
  %10 = "memref.load"(<<UNKNOWN SSA VALUE>>, %4, %4) : (memref<1x1xi8>, index, index) -> i8
  %11 = "mod_arith.encapsulate"(%10) : (i8) -> !mod_arith.int<127 : i8>
  %12 = "mod_arith.mod_switch"(%11) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %13 = "arith.extsi"(%10) : (i8) -> i32
  %14 = "mod_arith.encapsulate"(%7) : (i8) -> !mod_arith.int<127 : i8>
  %15 = "mod_arith.mod_switch"(%14) : (!mod_arith.int<127 : i8>) -> !mod_arith.int<2147483647 : i32>
  %16 = "arith.extsi"(%7) : (i8) -> i32
  %17 = "mod_arith.mul"(%12, %15) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %18 = "arith.muli"(%13, %16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %19 = "mod_arith.add"(%17, %17) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %20 = "arith.addi"(%18, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %21 = "mod_arith.mul"(%19, %17) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %22 = "arith.muli"(%20, %18) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  %23 = "mod_arith.add"(%19, %21) : (!mod_arith.int<2147483647 : i32>, !mod_arith.int<2147483647 : i32>) -> !mod_arith.int<2147483647 : i32>
  %24 = "arith.addi"(%20, %22) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32
  "func.return"(%23) : (!mod_arith.int<2147483647 : i32>) -> ()
  "func.return"(%24) : (i32) -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AttributeTrait::IsLocation<Empty>)
/usr/local/google/home/legiest/heir/tests/Dialect/Arith/Conversions/ArithToModArith/arith-to-mod-arith.mlir:91:11: error: failed to legalize unresolved materialization from ('!mod_arith.int<127 : i8>') to ('i8') that remained live after conversion
    %23 = memref.load %arg0[%c0, %c0] : memref<1x1xi8>
          ^
/usr/local/google/home/legiest/heir/tests/Dialect/Arith/Conversions/ArithToModArith/arith-to-mod-arith.mlir:91:11: note: see current operation: %6 = "builtin.unrealized_conversion_cast"(%5) : (!mod_arith.int<127 : i8>) -> i8
/usr/local/google/home/legiest/heir/tests/Dialect/Arith/Conversions/ArithToModArith/arith-to-mod-arith.mlir:92:11: note: see existing live user here: %5 = mod_arith.encapsulate %4 : i8 -> !mod_arith.int<127 : i8>
    %24 = arith.extsi %23 : i8 to i32
          ^
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)
