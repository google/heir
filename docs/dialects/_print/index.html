<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.113.0"><link rel=canonical type=text/html href=https://heir.dev/docs/dialects/><link rel=alternate type=application/rss+xml href=https://heir.dev/docs/dialects/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Dialects | HEIR</title><meta name=description content><meta property="og:title" content="Dialects"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://heir.dev/docs/dialects/"><meta itemprop=name content="Dialects"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="Dialects"><meta name=twitter:description content><link rel=preload href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css as=style><link href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=td-section><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class=navbar-brand__name>HEIR</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/><span>Home</span></a></li><li class=nav-item><a class="nav-link active" href=/docs/><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://github.com/google/heir/ target=_blank rel=noopener><span>GitHub</span></a></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/dialects/>Return to the regular view of this page</a>.</p></div><h1 class=title>Dialects</h1><ul><li>1: <a href=#pg-7edb6db9a7c1e9cd1b88e7f261615363>ArithExt</a></li><li>2: <a href=#pg-7a2d769a54237b8d0845fe32a6451c2b>BGV</a></li><li>3: <a href=#pg-5f74537b9610a2b3f8ddf498be3d47b0>CGGI</a></li><li>4: <a href=#pg-818a3660f61ebf5859b5c98635beacc8>CKKS</a></li><li>5: <a href=#pg-80cc312dd83f43a069330083f04eb4f2>Comb</a></li><li>6: <a href=#pg-df73b993320a0b803398dca1b5f7c3cd>Jaxite</a></li><li>7: <a href=#pg-c5dda3cb8e694541eacbee638af7317d>LWE</a></li><li>8: <a href=#pg-e397c035ea096bd861aadf40d3fccd0a>Openfhe</a></li><li>9: <a href=#pg-b18fea903e4651113f5317788f1491e1>Polynomial</a></li><li>10: <a href=#pg-c9ea40a8d17399f57cdd3c18b53cedef>Random</a></li><li>11: <a href=#pg-aeae60b865ac85372556b396a5a052ce>RNS</a></li><li>12: <a href=#pg-f7ffac8ba93b73b8a62e185ec8643d63>Secret</a></li><li>13: <a href=#pg-ca9ddb02db7c0683037407c6f9eb1f2a>TensorExt</a></li><li>14: <a href=#pg-678c1db0f9b2ed4c9d43b790f890bea0>TfheRust</a></li><li>15: <a href=#pg-d46d9ee8aeb1f8889ca7cfc9a061a7cc>TfheRustBool</a></li></ul><div class=content><p>This section contains the reference documentation for all of the dialects
defined in HEIR.</p></div></div><div class=td-content><h1 id=pg-7edb6db9a7c1e9cd1b88e7f261615363>1 - ArithExt</h1><h2 id=arithext-ops>ArithExt ops</h2><h3 id=arith_extadd-heirarith_extaddop><code>arith_ext.add</code> (heir::arith_ext::AddOp)</h3><p><em>Modular addition operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith_ext.add` operands attr-dict `:` type($output)
</code></pre><p>Computes addition modulo a statically known modulus $q$.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modulus</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arith_extbarrett_reduce-heirarith_extbarrettreduceop><code>arith_ext.barrett_reduce</code> (heir::arith_ext::BarrettReduceOp)</h3><p><em>Compute the first step of the Barrett reduction.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith_ext.barrett_reduce` operands attr-dict `:` qualified(type($input))
</code></pre><p>Let $q$ denote a statically known modulus and $b = 4^{w}$, where $w$ is the
smallest bit-width that contains the range $[0, q)$. The Barrett reduce
operation computes <code>barret_reduce x = x - floor(x * floor(b / q) / b) * q</code>.</p><p>Given $0 &lt;= x &lt; q^2$, then this will compute $(x \mod q)$ or $(x \mod q) + p$.</p><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modulus</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arith_extmac-heirarith_extmacop><code>arith_ext.mac</code> (heir::arith_ext::MacOp)</h3><p><em>Modular multiplication-and-accumulation operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith_ext.mac` operands attr-dict `:` type($output)
</code></pre><p><code>arith_ext.mac x, y, z {modulus = q}</code> computes $(x * y) + z \mod q$</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modulus</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>acc</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arith_extmul-heirarith_extmulop><code>arith_ext.mul</code> (heir::arith_ext::MulOp)</h3><p><em>Modular multiplication operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith_ext.mul` operands attr-dict `:` type($output)
</code></pre><p>Computes multiplication modulo a statically known modulus $q$.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modulus</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arith_extsubifge-heirarith_extsubifgeop><code>arith_ext.subifge</code> (heir::arith_ext::SubIfGEOp)</h3><p><em>Compute (x >= y) ? x - y : x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith_ext.subifge` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arith_extsub-heirarith_extsubop><code>arith_ext.sub</code> (heir::arith_ext::SubOp)</h3><p><em>Modular subtraction operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith_ext.sub` operands attr-dict `:` type($output)
</code></pre><p>Computes subtraction modulo a statically known modulus $q$.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modulus</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-7a2d769a54237b8d0845fe32a6451c2b>2 - BGV</h1><p>The BGV dialect defines the types and operations of the BGV cryptosystem.</p><h2 id=bgv-ops>BGV ops</h2><h3 id=bgvadd-heirbgvaddop><code>bgv.add</code> (heir::bgv::AddOp)</h3><p><em>Addition operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.add` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvadd_plain-heirbgvaddplainop><code>bgv.add_plain</code> (heir::bgv::AddPlainOp)</h3><p><em>Addition operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.add_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertextInput</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>plaintextInput</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvextract-heirbgvextractop><code>bgv.extract</code> (heir::bgv::ExtractOp)</h3><p><em>Extract the i-th element of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.extract` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>While this operation is costly to compute in FHE, we represent it so we can
implement efficient lowerings and folders.</p><p>This op can be implemented as a plaintext multiplication with a one-hot
vector and a rotate into the zero-th index.</p><p>An extraction op&rsquo;s input ciphertext type is asserted to have an <code>underlying_type</code>
corresponding to a ranked tensor type, and this op&rsquo;s return type is
inferred to have the <code>underlying_type</code> corresponding to the element type of
that tensor type.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultRings</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>offset</code></td><td>signless integer or index</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvmodulus_switch-heirbgvmodulusswitchop><code>bgv.modulus_switch</code> (heir::bgv::ModulusSwitchOp)</h3><p><em>Lower the modulus level of the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.modulus_switch` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>to_ring</code></td><td>::mlir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvmul-heirbgvmulop><code>bgv.mul</code> (heir::bgv::MulOp)</h3><p><em>Multiplication operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.mul` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvmul_plain-heirbgvmulplainop><code>bgv.mul_plain</code> (heir::bgv::MulPlainOp)</h3><p><em>Multiplication operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.mul_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertextInput</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>plaintextInput</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvnegate-heirbgvnegateop><code>bgv.negate</code> (heir::bgv::NegateOp)</h3><p><em>Negate the coefficients of the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.negate` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Involution</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvrelinearize-heirbgvrelinearizeop><code>bgv.relinearize</code> (heir::bgv::RelinearizeOp)</h3><p><em>Relinearize the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.relinearize` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>This op takes integer array attributes <code>from_basis</code> and <code>to_basis</code> that are
used to indicate the key basis from which and to which the ciphertext is
encrypted against. A ciphertext is canonically encrypted against key basis
<code>(1, s)</code>. After a multiplication, its size will increase and the basis will be
<code>(1, s, s^2)</code>. The array that represents the key basis is constructed by
listing the powers of <code>s</code> at each position of the array. For example, <code>(1, s, s^2)</code> corresponds to <code>[0, 1, 2]</code>, while <code>(1, s^2)</code> corresponds to <code>[0, 2]</code>.</p><p>Traits: <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>from_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>to_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvrotate-heirbgvrotateop><code>bgv.rotate</code> (heir::bgv::RotateOp)</h3><p><em>Rotate the coefficients of the ciphertext using a Galois automorphism.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.rotate` operands attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvsub-heirbgvsubop><code>bgv.sub</code> (heir::bgv::SubOp)</h3><p><em>Subtraction operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.sub` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=bgvsub_plain-heirbgvsubplainop><code>bgv.sub_plain</code> (heir::bgv::SubPlainOp)</h3><p><em>Subtraction operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.sub_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertextInput</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>plaintextInput</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-5f74537b9610a2b3f8ddf498be3d47b0>3 - CGGI</h1><p>A dialect for types and operations in the CGGI cryptosystem</p><h2 id=cggi-attributes>CGGI attributes</h2><h3 id=cggigateattr>CGGIGateAttr</h3><p>An Attribute containing an array of strings to store bool gates</p><p>Syntax:</p><pre tabindex=0><code>#cggi.cggi_gate&lt;
  ::llvm::ArrayRef&lt;mlir::StringAttr&gt;   # gate
&gt;
</code></pre><p>This attributes stores a list of string identifiers for Boolean gates.</p><p>This used in the <code>cggi.packed</code> operation to indicate the boolean gate that applies pairwise between elements of two ciphertext arrays. For example,</p><p>%0 = cggi.packed %a, %b {gates = #cggi.cggi_gate&lt;&ldquo;and&rdquo;, &ldquo;xor&rdquo;>} : tensor&lt;2x!lwe.lwe_ciphertext></p><p>applies an &ldquo;and&rdquo; gate between the first elements of %a and %b and an xor gate between the second elements.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>gate</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::StringAttr></code></td><td></td></tr></tbody></table><h3 id=cggiparamsattr>CGGIParamsAttr</h3><p>Syntax:</p><pre tabindex=0><code>#cggi.cggi_params&lt;
  ::mlir::heir::lwe::RLWEParamsAttr,   # rlweParams
  unsigned,   # bsk_noise_variance
  unsigned,   # bsk_gadget_base_log
  unsigned,   # bsk_gadget_num_levels
  unsigned,   # ksk_noise_variance
  unsigned,   # ksk_gadget_base_log
  unsigned   # ksk_gadget_num_levels
&gt;
</code></pre><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>rlweParams</td><td style=text-align:center><code>::mlir::heir::lwe::RLWEParamsAttr</code></td><td></td></tr><tr><td style=text-align:center>bsk_noise_variance</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>bsk_gadget_base_log</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>bsk_gadget_num_levels</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>ksk_noise_variance</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>ksk_gadget_base_log</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>ksk_gadget_num_levels</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h2 id=cggi-ops>CGGI ops</h2><h3 id=cggiand-heircggiandop><code>cggi.and</code> (heir::cggi::AndOp)</h3><p><em>Logical AND of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.and` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=cggilut2-heircggilut2op><code>cggi.lut2</code> (heir::cggi::Lut2Op)</h3><p><em>A lookup table on two inputs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.lut2` operands attr-dict `:` qualified(type($output))
</code></pre><p>An op representing a lookup table applied to some number <code>n</code> of ciphertexts
encrypting boolean input bits.</p><p>Over cleartext bits <code>a, b, c</code>, using <code>n = 3</code> for example, the operation
computed by this function can be interpreted as</p><pre tabindex=0><code>  truth_table &gt;&gt; {c, b, a}
</code></pre><p>where <code>{c, b, a}</code> is the unsigned 3-bit integer with bits <code>c, b, a</code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookup_table</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>b</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>a</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=cggilut3-heircggilut3op><code>cggi.lut3</code> (heir::cggi::Lut3Op)</h3><p><em>A lookup table on three inputs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.lut3` operands attr-dict `:` qualified(type($output))
</code></pre><p>An op representing a lookup table applied to some number <code>n</code> of ciphertexts
encrypting boolean input bits.</p><p>Over cleartext bits <code>a, b, c</code>, using <code>n = 3</code> for example, the operation
computed by this function can be interpreted as</p><pre tabindex=0><code>  truth_table &gt;&gt; {c, b, a}
</code></pre><p>where <code>{c, b, a}</code> is the unsigned 3-bit integer with bits <code>c, b, a</code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookup_table</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>c</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>b</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>a</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=cggilut_lincomb-heircggilutlincombop><code>cggi.lut_lincomb</code> (heir::cggi::LutLinCombOp)</h3><p><em>A variadic-input lookup table with inputs prepared via linear combination.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.lut_lincomb` operands attr-dict `:` type($output)
</code></pre><p>An op representing a lookup table applied to an arbitrary number of
input ciphertexts, which are combined according to a static linear
combination attached to the op.</p><p>The user must ensure the chosen linear combination does not bleed error
bits into the message space according to the underlying ciphertext&rsquo;s
encoding attributes. E.g., a bit_field_encoding with 3 cleartext bits
cannot be multiplied by 16.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#encoding</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.bit_field_encoding</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cleartext_start=</span><span style=color:#0000cf;font-weight:700>30</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>cleartext_bitwidth=</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#params</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.lwe_params</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cmod=</span><span style=color:#0000cf;font-weight:700>7917</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>dimension=</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>ciphertext =</span> <span style=color:#000;font-weight:700>!</span>lwe<span style=color:#000;font-weight:700>.</span>lwe_ciphertext<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>encoding =</span> <span style=color:#000>#encoding</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>lwe_params =</span> <span style=color:#000>#params</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> cggi<span style=color:#000;font-weight:700>.</span>lut_lincomb <span style=color:#000>%c0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c3</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>coefficients =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#f57900>lookup_table =</span> <span style=color:#0000cf;font-weight:700>68</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>ciphertext
</span></span></code></pre></div><p>Represents applying the lut</p><pre tabindex=0><code>  68 &gt;&gt; (1 * c0 + 2 * c1 + 3 * c2 + 2 * c3)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>lookup_table</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of A type for LWE ciphertexts</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h3 id=cggimulti_lut_lincomb-heircggimultilutlincombop><code>cggi.multi_lut_lincomb</code> (heir::cggi::MultiLutLinCombOp)</h3><p><em>A multi-output version of lut_lincomb with one LUT per output.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.multi_lut_lincomb` operands attr-dict `:` functional-type($inputs, $outputs)
</code></pre><p>An op representing multiple lookup tables applied to a shared input, which
is prepared via a static linear combination. This is equivalent to
<code>cggi.lut_lincomb</code>, but where the linear combination is given to multiple
lookup tables, each producing a separate output.</p><p>This can be achieved by a special implementation of blind rotate in the CGGI
scheme. See <a href=https://ieeexplore.ieee.org/document/10413195>AutoHoG</a>.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#encoding</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.bit_field_encoding</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cleartext_start=</span><span style=color:#0000cf;font-weight:700>30</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>cleartext_bitwidth=</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#params</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.lwe_params</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cmod=</span><span style=color:#0000cf;font-weight:700>7917</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>dimension=</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>ciphertext =</span> <span style=color:#000;font-weight:700>!</span>lwe<span style=color:#000;font-weight:700>.</span>lwe_ciphertext<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>encoding =</span> <span style=color:#000>#encoding</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>lwe_params =</span> <span style=color:#000>#params</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> cggi<span style=color:#000;font-weight:700>.</span>multi_lut_lincomb <span style=color:#000>%c0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c3</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#f57900>coefficients =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;,</span>
</span></span><span style=display:flex><span>    <span style=color:#f57900>lookup_tables =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>68</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>70</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Represents applying the following LUTs. Performance-wise, this is
comparable to applying a single LUT to a linear combination.</p><pre tabindex=0><code>x = (1 * c0 + 2 * c1 + 3 * c2 + 2 * c3)
return (
  (68 &gt;&gt; x) &amp; 1,
  (70 &gt;&gt; x) &amp; 1,
  (4 &gt;&gt; x) &amp; 1,
  (8 &gt;&gt; x) &amp; 1
)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>lookup_tables</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of A type for LWE ciphertexts</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of A type for LWE ciphertexts</td></tr></tbody></table><h3 id=cgginand-heircgginandop><code>cggi.nand</code> (heir::cggi::NandOp)</h3><p><em>Logical NAND of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.nand` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=cgginor-heircgginorop><code>cggi.nor</code> (heir::cggi::NorOp)</h3><p><em>Logical NOR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.nor` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=cgginot-heircgginotop><code>cggi.not</code> (heir::cggi::NotOp)</h3><p><em>Logical NOT of two ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.not` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Involution</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=cggior-heircggiorop><code>cggi.or</code> (heir::cggi::OrOp)</h3><p><em>Logical OR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.or` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=cggipacked_gates-heircggipackedop><code>cggi.packed_gates</code> (heir::cggi::PackedOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.packed_gates` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>gates</code></td><td>::mlir::heir::cggi::CGGIGateAttr</td><td>An Attribute containing an array of strings to store bool gates</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=cggixnor-heircggixnorop><code>cggi.xnor</code> (heir::cggi::XNorOp)</h3><p><em>Logical XNOR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.xnor` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=cggixor-heircggixorop><code>cggi.xor</code> (heir::cggi::XorOp)</h3><p><em>Logical XOR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.xor` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-818a3660f61ebf5859b5c98635beacc8>4 - CKKS</h1><p>The CKKS dialect defines the types and operations of the CKKS cryptosystem.</p><h2 id=ckks-ops>CKKS ops</h2><h3 id=ckksadd-heirckksaddop><code>ckks.add</code> (heir::ckks::AddOp)</h3><p><em>Addition operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.add` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckksadd_plain-heirckksaddplainop><code>ckks.add_plain</code> (heir::ckks::AddPlainOp)</h3><p><em>Addition operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.add_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertextInput</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>plaintextInput</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckksextract-heirckksextractop><code>ckks.extract</code> (heir::ckks::ExtractOp)</h3><p><em>Extract the i-th element of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.extract` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>While this operation is costly to compute in FHE, we represent it so we can
implement efficient lowerings and folders.</p><p>This op can be implemented as a plaintext multiplication with a one-hot
vector and a rotate into the zero-th index.</p><p>An extraction op&rsquo;s input ciphertext type is asserted to have an <code>underlying_type</code>
corresponding to a ranked tensor type, and this op&rsquo;s return type is
inferred to have the <code>underlying_type</code> corresponding to the element type of
that tensor type.</p><p>Traits: <code>SameOperandsAndResultRings</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>offset</code></td><td>signless integer or index</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckksmul-heirckksmulop><code>ckks.mul</code> (heir::ckks::MulOp)</h3><p><em>Multiplication operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.mul` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckksmul_plain-heirckksmulplainop><code>ckks.mul_plain</code> (heir::ckks::MulPlainOp)</h3><p><em>Multiplication operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.mul_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertextInput</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>plaintextInput</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckksnegate-heirckksnegateop><code>ckks.negate</code> (heir::ckks::NegateOp)</h3><p><em>Negate the coefficients of the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.negate` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Involution</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckksrelinearize-heirckksrelinearizeop><code>ckks.relinearize</code> (heir::ckks::RelinearizeOp)</h3><p><em>Relinearize the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.relinearize` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>This op takes integer array attributes <code>from_basis</code> and <code>to_basis</code> that are
used to indicate the key basis from which and to which the ciphertext is
encrypted against. A ciphertext is canonically encrypted against key basis
<code>(1, s)</code>. After a multiplication, its size will increase and the basis will be
<code>(1, s, s^2)</code>. The array that represents the key basis is constructed by
listing the powers of <code>s</code> at each position of the array. For example, <code>(1, s, s^2)</code> corresponds to <code>[0, 1, 2]</code>, while <code>(1, s^2)</code> corresponds to <code>[0, 2]</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>from_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>to_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckksrescale-heirckksrescaleop><code>ckks.rescale</code> (heir::ckks::RescaleOp)</h3><p><em>Rescales the ciphertext, which is the CKKS version of modulus switching in BGV/BFV.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.rescale` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>to_ring</code></td><td>::mlir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckksrotate-heirckksrotateop><code>ckks.rotate</code> (heir::ckks::RotateOp)</h3><p><em>Rotate the coefficients of the ciphertext using a Galois automorphism.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.rotate` operands attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckkssub-heirckkssubop><code>ckks.sub</code> (heir::ckks::SubOp)</h3><p><em>Subtraction operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.sub` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=ckkssub_plain-heirckkssubplainop><code>ckks.sub_plain</code> (heir::ckks::SubPlainOp)</h3><p><em>Subtraction operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.sub_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertextInput</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>plaintextInput</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-80cc312dd83f43a069330083f04eb4f2>5 - Comb</h1><p>Types and operations for comb dialect
This dialect defines the <code>comb</code> dialect, which is intended to be a generic
representation of combinational logic outside of a particular use-case.</p><h2 id=operations>Operations</h2><h3 id=combadd-heircombaddop><code>comb.add</code> (heir::comb::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comband-heircombandop><code>comb.and</code> (heir::comb::AndOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combconcat-heircombconcatop><code>comb.concat</code> (heir::comb::ConcatOp)</h3><p><em>Concatenate a variadic list of operands together.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
</code></pre><p>See the comb rationale document for details on operand ordering.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combextract-heircombextractop><code>comb.extract</code> (heir::comb::ExtractOp)</h3><p><em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combicmp-heircombicmpop><code>comb.icmp</code> (heir::comb::ICmpOp)</h3><p><em>Compare two integer values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre tabindex=0><code>    %r = comb.icmp eq %a, %b : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::heir::comb::ICmpPredicateAttr</td><td>hw.icmp comparison predicate</td></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combinv-heircombinvop><code>comb.inv</code> (heir::comb::InvOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmul-heircombmulop><code>comb.mul</code> (heir::comb::MulOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmux-heircombmuxop><code>comb.mux</code> (heir::comb::MuxOp)</h3><p><em>Return one or the other operand depending on a selector bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))
</code></pre><pre tabindex=0><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=combnand-heircombnandop><code>comb.nand</code> (heir::comb::NandOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combnor-heircombnorop><code>comb.nor</code> (heir::comb::NorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combor-heircomborop><code>comb.or</code> (heir::comb::OrOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combparity-heircombparityop><code>comb.parity</code> (heir::comb::ParityOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combreplicate-heircombreplicateop><code>comb.replicate</code> (heir::comb::ReplicateOp)</h3><p><em>Concatenate the operand a constant number of times</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combtruth_table-heircombtruthtableop><code>comb.truth_table</code> (heir::comb::TruthTableOp)</h3><p><em>Return a true/false based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.truth_table` $inputs `-&gt;` $lookupTable attr-dict
</code></pre><pre tabindex=0><code>  %a = ... : i1
  %b = ... : i1
  %0 = comb.truth_table %a, %b -&gt; 6 : ui4
</code></pre><p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -> LSB from left
to right and the offset into <code>lookupTable</code> is computed from them. The
integer containing the truth table value&rsquo;s LSB is the output for the input
&ldquo;all false&rdquo;, and the MSB is the output for the input &ldquo;all true&rdquo;.</p><p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &lsquo;x&rsquo; &ndash; it should be the well-known result.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookupTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combxnor-heircombxnorop><code>comb.xnor</code> (heir::comb::XNorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combxor-heircombxorop><code>comb.xor</code> (heir::comb::XorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h2 id=enums>Enums</h2><h3 id=icmppredicate>ICmpPredicate</h3><p>hw.icmp comparison predicate</p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>eq</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>ne</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>slt</td><td style=text-align:center><code>2</code></td><td>slt</td></tr><tr><td style=text-align:center>sle</td><td style=text-align:center><code>3</code></td><td>sle</td></tr><tr><td style=text-align:center>sgt</td><td style=text-align:center><code>4</code></td><td>sgt</td></tr><tr><td style=text-align:center>sge</td><td style=text-align:center><code>5</code></td><td>sge</td></tr><tr><td style=text-align:center>ult</td><td style=text-align:center><code>6</code></td><td>ult</td></tr><tr><td style=text-align:center>ule</td><td style=text-align:center><code>7</code></td><td>ule</td></tr><tr><td style=text-align:center>ugt</td><td style=text-align:center><code>8</code></td><td>ugt</td></tr><tr><td style=text-align:center>uge</td><td style=text-align:center><code>9</code></td><td>uge</td></tr><tr><td style=text-align:center>ceq</td><td style=text-align:center><code>10</code></td><td>ceq</td></tr><tr><td style=text-align:center>cne</td><td style=text-align:center><code>11</code></td><td>cne</td></tr><tr><td style=text-align:center>weq</td><td style=text-align:center><code>12</code></td><td>weq</td></tr><tr><td style=text-align:center>wne</td><td style=text-align:center><code>13</code></td><td>wne</td></tr></tbody></table><h2 id=comb-types>Comb types</h2><h2 id=comb-ops>Comb ops</h2><h3 id=combadd-heircombaddop-1><code>comb.add</code> (heir::comb::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comband-heircombandop-1><code>comb.and</code> (heir::comb::AndOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combconcat-heircombconcatop-1><code>comb.concat</code> (heir::comb::ConcatOp)</h3><p><em>Concatenate a variadic list of operands together.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
</code></pre><p>See the comb rationale document for details on operand ordering.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combextract-heircombextractop-1><code>comb.extract</code> (heir::comb::ExtractOp)</h3><p><em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combicmp-heircombicmpop-1><code>comb.icmp</code> (heir::comb::ICmpOp)</h3><p><em>Compare two integer values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre tabindex=0><code>    %r = comb.icmp eq %a, %b : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::heir::comb::ICmpPredicateAttr</td><td>hw.icmp comparison predicate</td></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combinv-heircombinvop-1><code>comb.inv</code> (heir::comb::InvOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-18>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmul-heircombmulop-1><code>comb.mul</code> (heir::comb::MulOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-19>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmux-heircombmuxop-1><code>comb.mux</code> (heir::comb::MuxOp)</h3><p><em>Return one or the other operand depending on a selector bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))
</code></pre><pre tabindex=0><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-20>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=combnand-heircombnandop-1><code>comb.nand</code> (heir::comb::NandOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combnor-heircombnorop-1><code>comb.nor</code> (heir::comb::NorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combor-heircomborop-1><code>comb.or</code> (heir::comb::OrOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-23>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combparity-heircombparityop-1><code>comb.parity</code> (heir::comb::ParityOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-24>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combreplicate-heircombreplicateop-1><code>comb.replicate</code> (heir::comb::ReplicateOp)</h3><p><em>Concatenate the operand a constant number of times</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-28>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combtruth_table-heircombtruthtableop-1><code>comb.truth_table</code> (heir::comb::TruthTableOp)</h3><p><em>Return a true/false based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.truth_table` $inputs `-&gt;` $lookupTable attr-dict
</code></pre><pre tabindex=0><code>  %a = ... : i1
  %b = ... : i1
  %0 = comb.truth_table %a, %b -&gt; 6 : ui4
</code></pre><p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -> LSB from left
to right and the offset into <code>lookupTable</code> is computed from them. The
integer containing the truth table value&rsquo;s LSB is the output for the input
&ldquo;all false&rdquo;, and the MSB is the output for the input &ldquo;all true&rdquo;.</p><p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &lsquo;x&rsquo; &ndash; it should be the well-known result.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-25>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookupTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combxnor-heircombxnorop-1><code>comb.xnor</code> (heir::comb::XNorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-26>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combxor-heircombxorop-1><code>comb.xor</code> (heir::comb::XorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-27>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-df73b993320a0b803398dca1b5f7c3cd>6 - Jaxite</h1><p>The <code>jaxite</code> dialect is an exit dialect for generating py code against the jaxite library API,
using the jaxite parameters and encoding scheme.</p><p>See <a href=https://github.com/google/jaxite>https://github.com/google/jaxite</a></p><h2 id=jaxite-types>Jaxite types</h2><h3 id=paramstype>ParamsType</h3><p>The jaxite security params required to perform homomorphic operations.</p><p>Syntax: <code>!jaxite.params</code></p><h3 id=serverkeysettype>ServerKeySetType</h3><p>The jaxite server key set required to perform homomorphic operations.</p><p>Syntax: <code>!jaxite.server_key_set</code></p><h2 id=jaxite-ops>Jaxite ops</h2><h3 id=jaxiteconstant-heirjaxiteconstantop><code>jaxite.constant</code> (heir::jaxite::ConstantOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `jaxite.constant` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>params</code></td><td>The jaxite security params required to perform homomorphic operations.</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h3 id=jaxitelut3-heirjaxitelut3op><code>jaxite.lut3</code> (heir::jaxite::Lut3Op)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `jaxite.lut3` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>b</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>c</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>truth_table</code></td><td>8-bit signless integer</td></tr><tr><td style=text-align:center><code>serverKeySet</code></td><td>The jaxite server key set required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>params</code></td><td>The jaxite security params required to perform homomorphic operations.</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c5dda3cb8e694541eacbee638af7317d>7 - LWE</h1><h2 id=lwe-attributes>LWE attributes</h2><h3 id=bitfieldencodingattr>BitFieldEncodingAttr</h3><p>An attribute describing encoded LWE plaintexts using bit fields.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.bit_field_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>A bit field encoding of an integer describes which contiguous region
of bits a small integer occupies within a larger integer.</p><p>The data describing the encoding consists of the starting bit positions of
the cleartext bit field and its width, where the LSB is bit 0 and the MSB
is bit <code>bit_width-1</code>. So the above example would have starting bit <code>30</code> and
width <code>3</code>. The bits not specified for the message have semantics defined
by the scheme or lowering.</p><p>Note that this encoding does not specify the underlying bit width of the
plaintext space. This is left for lowerings to decide.</p><p>The presence of this attribute as the <code>encoding</code> attribute of a tensor
indicates that the tensor is an LWE ciphertext.</p><p><strong>Example (CGGI):</strong></p><pre tabindex=0><code>#encoding = #lwe.bit_field_encoding&lt;cleartext_start=30, cleartext_bitwidth=3&gt;
!plaintext = !lwe.lwe_plaintext&lt;encoding = #encoding&gt;

%0 = arith.constant 4 : i3
%1 = lwe.encode %0 { encoding = #encoding }: i3 to !plaintext
</code></pre><p>The above represents an LWE plaintext encoding the 3-bit cleartext 4 as an
LWE ciphertext in a 32-bit integer, with a single bit of padding at the MSB.
This corresponds to the following, where 0 denotes a 0 bit, <code>b</code> denotes a
bit of the cleartext, <code>n</code> denotes a bit reserved for noise, and <code>|</code> is a
visual aid to show where the bit fields begin and end.</p><pre tabindex=0><code>   0|bbb|nn...n
MSB^          ^LSB
</code></pre><p><strong>Example (BGV):</strong></p><p>Note: BGV uses the RLWE encodings, but they have the same bit-field encoding
attributes as here. So this example serves mainly to show how this attribute
can be used to specify storing bits in the LSB of a plaintext.</p><pre tabindex=0><code>#encoding = #lwe.bit_field_encoding&lt;cleartext_start=4, cleartext_bitwidth=4&gt;
!plaintext = !lwe.lwe_plaintext&lt;encoding = #encoding&gt;

%0 = arith.constant 9 : i4
%1 = lwe.encode %0 { encoding = #encoding }: i4 to !plaintext
</code></pre><p>The above represents an LWE plaintext encoding a 4-bit cleartext as an
LWE ciphertext in the least-significant bits of a larger integer.
This corresponds to the following.</p><pre tabindex=0><code>   nn...n|bbbb
MSB^         ^LSB
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=lweparamsattr>LWEParamsAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.lwe_params&lt;
  IntegerAttr,   # cmod
  unsigned   # dimension
&gt;
</code></pre><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cmod</td><td style=text-align:center><code>IntegerAttr</code></td><td></td></tr><tr><td style=text-align:center>dimension</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=rlweparamsattr>RLWEParamsAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.rlwe_params&lt;
  unsigned,   # dimension
  ::mlir::polynomial::RingAttr   # ring
&gt;
</code></pre><p>An attribute describing classical RLWE parameters:</p><ul><li><code>dimension</code>: the number of polynomials used in an RLWE sample, analogous
to LWEParams.dimension.</li><li><code>ring</code>: the polynomial ring to use.</li></ul><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>dimension</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::polynomial::RingAttr</code></td><td></td></tr></tbody></table><h3 id=unspecifiedbitfieldencodingattr>UnspecifiedBitFieldEncodingAttr</h3><p>An attribute describing unspecified bit field encodings.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.unspecified_bit_field_encoding&lt;
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>See LWE_BitFieldEncoding for a description of bit field encodings.</p><p>This attribute describes an unspecified bit field encoding; this is where
the starting bit position of the cleartext bit field is unspecified, but its
width is fixed. A noise growth analysis should be performed to determine the
optimal amount of bits needed for noise and padding to specify the bit field
encodings starting bit position.</p><p>Example:</p><pre tabindex=0><code>#lwe_encoding = #lwe.unspecified_bit_field_encoding&lt;cleartext_bitwidth=3&gt;
%lwe_ciphertext = arith.constant &lt;[1,2,3,4]&gt; : tensor&lt;4xi32, #lwe_encoding&gt;
</code></pre><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=inversecanonicalembeddingencodingattr>InverseCanonicalEmbeddingEncodingAttr</h3><p>An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.inverse_canonical_embedding_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>Let $n$ be the degree of the polynomials in the plaintext space. An
&ldquo;inverse canonical embedding encoding&rdquo; of a list of real or complex values
$v_1, \dots, v_{n/2}$ is (almost) the inverse of the following decoding
map.</p><p>Define a map $\tau_N$ that maps a polynomial $p \in \mathbb{Z}[x] / (x^N + 1)
\to \mathbb{C}^{N/2}$ by evaluating it at the following $N/2$ points,
where $\omega = e^{2 \pi i / 2N}$ is the primitive $2N$th root of unity:</p><p>[
\omega, \omega^3, \omega^5, \dots, \omega^{N-1}
]</p><p>Then the complete decoding operation is $\textup{Decode}(p) =
(1/\Delta)\tau_N(p)$, where $\Delta$ is a scaling parameter and $\tau_N$ is
the truncated canonical embedding above. The encoding operation is the
inverse of the decoding operation, with some caveats explained below.</p><p>The map $\tau_N$ is derived from the so-called <em>canonical embedding</em>
$\tau$, though in the standard canonical embedding, we evaluate at all odd
powers of the root of unity, $\omega, \omega^3, \dots, \omega^{2N-1}$. For
polynomials in the slightly larger space $\mathbb{R}[x] / (x^N + 1)$, the
image of the canonical embedding is the subspace $H \subset \mathbb{C}^N$
defined by tuples $(z_1, \dots, z_N)$ such that $\overline{z_i} =
\overline{z_{N-i+1}}$. Note that this property holds because polynomial
evaluation commutes with complex conjugates, and the second half of the
roots of unity evaluate are complex conjugates of the first half. The
converse, that any such tuple with complex conjugate symmetry has an
inverse under $\tau$ with all real coefficients, makes $\tau$ is a
bijection onto $H$. $\tau$ and its inverse are explicitly computable as
discrete Fourier Transforms.</p><p>Because of the symmetry in canonical embedding for real polynomials, inputs
to this encoding can be represented as a list of $N/2$ complex points, with
the extra symmetric structure left implicit. $\tau_N$ and its inverse can
also be explicitly computed without need to expand the vectors to length
$N$.</p><p>The rounding step is required to invert the decoding because, while
cleartexts must be (implicitly) in the subspace $H$, they need not be the
output of $\tau_N$ for an <em>integer</em> polynomial. The rounding step ensures
we can use integer polynomial plaintexts for the FHE operations. There are
multiple rounding mechanisms, and this attribute does not specify which is
used, because in theory two ciphertexts that have used different roundings
are still compatible, though they may have different noise growth patterns.</p><p>The scaling parameter $\Delta$ is specified by the <code>cleartext_start</code> and
<code>cleartext_bitwidth</code> parameters, which are applied coefficient-wise using
the same semantics as the <code>bit_field_encoding</code>.</p><p>This attribute can be used in multiple ways:</p><ul><li>On a <code>poly.poly</code>, it asserts that the polynomial has been transformed
from a coefficient list using the canonical embedding.</li><li>On a tensor of <code>poly.poly</code>, it asserts that the tensor is an RLWE
ciphertext for some RLWE scheme that supports the approximate embedding
encoding.</li></ul><p>A typical flow for the CKKS scheme using this encoding would be to apply an
inverse FFT operation to invert the canonical embedding to be a polynomial
with real coefficients, then encrypt scale the resulting polynomial&rsquo;s
coefficients according to the scaling parameters, then round to get integer
coefficients.</p><p>Example:</p><pre tabindex=0><code>#generator = #poly.polynomial&lt;1 + x**1024&gt;
#ring = #poly.ring&lt;cmod=65536, ideal=#generator&gt;
#lwe_encoding = #lwe.polynomial_evaluation_encoding&lt;cleartext_start=30, cleartext_bitwidth=3&gt;

%evals = arith.constant &lt;[1, 2, 4, 5]&gt; : tensor&lt;4xi16&gt;
%poly1 = poly.intt %evals : tensor&lt;4xi16, #ring&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%poly2 = poly.intt %evals : tensor&lt;4xi16, #ring&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&lt;2x!poly.poly&lt;#ring, #eval_encoding&gt;&gt;
</code></pre><p>See <code>bit_field_encoding</code> for the definition of the <code>cleartext_start</code> and
<code>cleartext_bitwidth</code> fields.</p><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=polynomialcoefficientencodingattr>PolynomialCoefficientEncodingAttr</h3><p>An attribute describing encoded RLWE plaintexts via coefficients.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.polynomial_coefficient_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>A coefficient encoding of a list of integers asserts that the coefficients
of the polynomials contain the cleartexts, with the same semantics as
<code>bit_field_encoding</code> for per-coefficient encodings.</p><p>The presence of this attribute as the <code>encoding</code> attribute of a tensor of
<code>poly.poly</code> indicates that the tensor is an RLWE ciphertext for some RLWE
scheme that supports the coefficient encoding.</p><p>See <code>bit_field_encoding</code> for the definition of the <code>cleartext_start</code> and
<code>cleartext_bitwidth</code> fields.</p><p>Example:</p><pre tabindex=0><code>#generator = #poly.polynomial&lt;1 + x**1024&gt;
#ring = #poly.ring&lt;cmod=65536, ideal=#generator&gt;
#coeff_encoding = #lwe.polynomial_coefficient_encoding&lt;cleartext_start=15, cleartext_bitwidth=4&gt;

%poly1 = poly.from_tensor %coeffs1 : tensor&lt;10xi16&gt; -&gt; !poly.poly&lt;#ring&gt;
%poly2 = poly.from_tensor %coeffs2 : tensor&lt;10xi16&gt; -&gt; !poly.poly&lt;#ring&gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&lt;2x!poly.poly&lt;#ring&gt;, #coeff_encoding&gt;
</code></pre><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=polynomialevaluationencodingattr>PolynomialEvaluationEncodingAttr</h3><p>An attribute describing encoded RLWE plaintexts via evaluations at fixed points.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.polynomial_evaluation_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>A &ldquo;evaluation encoding&rdquo; of a list of integers $(v_1, \dots, v_n)$ asserts
that $f(x_1 ) = v_1, \dots, f(x_n) = v_n$ for some implicit, but fixed and
distinct choice of inputs $x_i$. The encoded values are also scaled by a
scale factor, having the same semantics as <code>bit_field_encoding</code>, but
applied entry-wise (to either the coefficient or evaluation representation).</p><p>This attribute can be used in multiple ways:</p><ul><li>On a <code>poly.poly</code>, it asserts that the polynomial has been transformed
from an evaluation tensor.</li><li>On a tensor of <code>poly.poly</code>, it asserts that the tensor is an RLWE
ciphertext for some RLWE scheme that supports the evaluation encoding.</li></ul><p>A typical workflow for the BFV/BGV schemes using this encoding would be
to apply a INTT operation to the input list of cleartexts to convert from
evaluation form to coefficient form, then encrypt the resulting polynomial
in coefficient form, then apply NTT back to the evaluation form for faster
multiplication of ciphertexts.</p><p>The points chosen are fixed to be the powers of a primitive root of unity
of the coefficient ring of the plaintext space, which allows one to use
NTT/INTT to tansform quickly between the coefficient and evaluation forms.</p><p>Example:</p><pre tabindex=0><code>#generator = #poly.polynomial&lt;1 + x**1024&gt;
// note that the cmod should be chosen so as to ensure a primitive root of
// unity exists in the multiplicative group (Z / cmod Z)^*
#ring = #poly.ring&lt;cmod=65536, ideal=#generator&gt;
#lwe_encoding = #lwe.polynomial_evaluation_encoding&lt;cleartext_start=30, cleartext_bitwidth=3&gt;

%evals = arith.constant &lt;[1, 2, 4, 5]&gt; : tensor&lt;4xi16&gt;
%poly1 = poly.intt %evals : tensor&lt;4xi16, #ring&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%poly2 = poly.intt %evals : tensor&lt;4xi16, #ring&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&lt;2x!poly.poly&lt;#ring, #eval_encoding&gt;&gt;
</code></pre><p>See <code>bit_field_encoding</code> for the definition of the <code>cleartext_start</code> and
<code>cleartext_bitwidth</code> fields.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h2 id=lwe-types>LWE types</h2><h3 id=lweciphertexttype>LWECiphertextType</h3><p>A type for LWE ciphertexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_ciphertext&lt;
  ::mlir::Attribute,   # encoding
  LWEParamsAttr   # lwe_params
&gt;
</code></pre><p>A type for LWE ciphertexts.</p><p>This type keeps track of the plaintext integer encoding for the LWE
Ciphertext to ensure proper decoding after decryption. It also keeps track
of the ring where the LWE ciphertext is defined, which provides information
on the ciphertext shape and the ring operations used in LWE operations.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr><tr><td style=text-align:center>lwe_params</td><td style=text-align:center><code>LWEParamsAttr</code></td><td></td></tr></tbody></table><h3 id=lweplaintexttype>LWEPlaintextType</h3><p>A type for LWE plaintexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_plaintext&lt;
  ::mlir::Attribute   # encoding
&gt;
</code></pre><p>A type for LWE plaintexts.</p><p>This type keeps track of the plaintext integer encoding for the LWE
plaintext before it is encrypted.</p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h3 id=rlweciphertexttype>RLWECiphertextType</h3><p>A type for RLWE ciphertexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.rlwe_ciphertext&lt;
  ::mlir::Attribute,   # encoding
  RLWEParamsAttr,   # rlwe_params
  Type   # underlying_type
&gt;
</code></pre><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr><tr><td style=text-align:center>rlwe_params</td><td style=text-align:center><code>RLWEParamsAttr</code></td><td></td></tr><tr><td style=text-align:center>underlying_type</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=rlweplaintexttype>RLWEPlaintextType</h3><p>A type for RLWE plaintexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.rlwe_plaintext&lt;
  ::mlir::Attribute,   # encoding
  ::mlir::polynomial::RingAttr,   # ring
  Type   # underlying_type
&gt;
</code></pre><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::polynomial::RingAttr</code></td><td></td></tr><tr><td style=text-align:center>underlying_type</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=rlwepublickeytype>RLWEPublicKeyType</h3><p>A public key for RLWE</p><p>Syntax:</p><pre tabindex=0><code>!lwe.rlwe_public_key&lt;
  RLWEParamsAttr   # rlwe_params
&gt;
</code></pre><h4 id=parameters-11>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>rlwe_params</td><td style=text-align:center><code>RLWEParamsAttr</code></td><td></td></tr></tbody></table><h3 id=rlwesecretkeytype>RLWESecretKeyType</h3><p>A secret key for RLWE</p><p>Syntax:</p><pre tabindex=0><code>!lwe.rlwe_secret_key&lt;
  RLWEParamsAttr   # rlwe_params
&gt;
</code></pre><h4 id=parameters-12>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>rlwe_params</td><td style=text-align:center><code>RLWEParamsAttr</code></td><td></td></tr></tbody></table><h2 id=lwe-ops>LWE ops</h2><h3 id=lweadd-heirlweaddop><code>lwe.add</code> (heir::lwe::AddOp)</h3><p><em>Add two LWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.add` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=lweencode-heirlweencodeop><code>lwe.encode</code> (heir::lwe::EncodeOp)</h3><p><em>Encode an integer to yield an LWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.encode` $plaintext attr-dict `:` qualified(type($plaintext)) `to` qualified(type($output))
</code></pre><p>Encode an integer to yield an LWE plaintext.</p><p>This op uses a an encoding attribute to encode the bits of the integer into
an LWE plaintext value that can then be encrypted.</p><p>Examples:</p><pre tabindex=0><code>%Y = lwe.encode %value {encoding = #enc}: i1 to !lwe.lwe_plaintext&lt;encoding = #enc&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>encoding</code></td><td>::mlir::Attribute</td><td>An attribute describing encoded LWE plaintexts using bit fields. or An attribute describing unspecified bit field encodings.</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE plaintexts</td></tr></tbody></table><h3 id=lwemul_scalar-heirlwemulscalarop><code>lwe.mul_scalar</code> (heir::lwe::MulScalarOp)</h3><p><em>Multiply an LWE ciphertext by a scalar</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.mul_scalar` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertext</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>scalar</code></td><td>integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=lweradd-heirlweraddop><code>lwe.radd</code> (heir::lwe::RAddOp)</h3><p><em>Add two RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.radd` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=lwerlwe_decode-heirlwerlwedecodeop><code>lwe.rlwe_decode</code> (heir::lwe::RLWEDecodeOp)</h3><p><em>Decode an RLWE plaintext to an underlying type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_decode` $input attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>encoding</code></td><td>::mlir::Attribute</td><td>An attribute describing encoded RLWE plaintexts via coefficients. or An attribute describing encoded RLWE plaintexts via evaluations at fixed points. or An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.</td></tr><tr><td><code>ring</code></td><td>::mlir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=lwerlwe_decrypt-heirlwerlwedecryptop><code>lwe.rlwe_decrypt</code> (heir::lwe::RLWEDecryptOp)</h3><p><em>Decrypt an RLWE ciphertext to a RLWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_decrypt` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Decrypt an RLWE ciphertext to yield a RLWE plaintext</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>secret_key</code></td><td>A secret key for RLWE</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h3 id=lwerlwe_encode-heirlwerlweencodeop><code>lwe.rlwe_encode</code> (heir::lwe::RLWEEncodeOp)</h3><p><em>Encode an integer to yield an RLWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_encode` $input attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Encode an integer to yield an RLWE plaintext.</p><p>This op uses a an encoding attribute to encode the bits of the integer into
an RLWE plaintext value that can then be encrypted.</p><p>Examples:</p><pre tabindex=0><code>%Y = lwe.rlwe_encode %value {encoding = #enc, ring = #ring}: i1 to !lwe.rlwe_plaintext&lt;encoding = #enc, ring = #ring&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>encoding</code></td><td>::mlir::Attribute</td><td>An attribute describing encoded RLWE plaintexts via coefficients. or An attribute describing encoded RLWE plaintexts via evaluations at fixed points. or An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.</td></tr><tr><td><code>ring</code></td><td>::mlir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h3 id=lwerlwe_encrypt-heirlwerlweencryptop><code>lwe.rlwe_encrypt</code> (heir::lwe::RLWEEncryptOp)</h3><p><em>Encrypt an RLWE plaintext to a RLWE ciphertext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_encrypt` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Encrypt an RLWE plaintext to yield a RLWE ciphertext.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE plaintexts</td></tr><tr><td style=text-align:center><code>key</code></td><td>A secret key for RLWE or A public key for RLWE</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=lwermul-heirlwermulop><code>lwe.rmul</code> (heir::lwe::RMulOp)</h3><p><em>Multiplies two RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rmul` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=lwernegate-heirlwernegateop><code>lwe.rnegate</code> (heir::lwe::RNegateOp)</h3><p><em>Negate a RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rnegate` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=lwersub-heirlwersubop><code>lwe.rsub</code> (heir::lwe::RSubOp)</h3><p><em>Subtract two RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rsub` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=lwetrivial_encrypt-heirlwetrivialencryptop><code>lwe.trivial_encrypt</code> (heir::lwe::TrivialEncryptOp)</h3><p><em>Create a trivial encryption of a plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.trivial_encrypt` operands attr-dict `:`  qualified(type(operands)) `to` qualified(type(results))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>params</code></td><td>::mlir::heir::lwe::LWEParamsAttr</td><td></td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for LWE plaintexts</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h3 id=lwereinterpret_underlying_type-heirlwereinterpretunderlyingtypeop><code>lwe.reinterpret_underlying_type</code> (heir::lwe::ReinterpretUnderlyingTypeOp)</h3><p><em>A placeholder cast from one ciphertext type to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.reinterpret_underlying_type` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
</code></pre><p>The <code>cast</code> op is thus used to translate <code>underlying_type</code> between
ciphertexts in particular situations , such as when lowering to an API that
does not keep track of types for you.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e397c035ea096bd861aadf40d3fccd0a>8 - Openfhe</h1><p>The <code>openfhe</code> dialect is an exit dialect for generating c++ code against the OpenFHE library API.</p><p>See <a href=https://github.com/openfheorg/openfhe-development>https://github.com/openfheorg/openfhe-development</a></p><h2 id=openfhe-types>Openfhe types</h2><h3 id=ccparamstype>CCParamsType</h3><p>The CCParams required to create CryptoContext.</p><p>Syntax: <code>!openfhe.cc_params</code></p><h3 id=cryptocontexttype>CryptoContextType</h3><p>The CryptoContext required to perform homomorphic operations in OpenFHE.</p><p>Syntax: <code>!openfhe.crypto_context</code></p><h3 id=evalkeytype>EvalKeyType</h3><p>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.</p><p>Syntax: <code>!openfhe.eval_key</code></p><h3 id=privatekeytype>PrivateKeyType</h3><p>The private key required to decrypt a ciphertext in OpenFHE.</p><p>Syntax: <code>!openfhe.private_key</code></p><h3 id=publickeytype>PublicKeyType</h3><p>The public key required to encrypt plaintext in OpenFHE.</p><p>Syntax: <code>!openfhe.public_key</code></p><h2 id=openfhe-ops>Openfhe ops</h2><h3 id=openfheadd-heiropenfheaddop><code>openfhe.add</code> (heir::openfhe::AddOp)</h3><p><em>OpenFHE add operation of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfheautomorph-heiropenfheautomorphop><code>openfhe.automorph</code> (heir::openfhe::AutomorphOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.automorph` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>evalKey</code></td><td>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhedecrypt-heiropenfhedecryptop><code>openfhe.decrypt</code> (heir::openfhe::DecryptOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.decrypt` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>privateKey</code></td><td>The private key required to decrypt a ciphertext in OpenFHE.</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h3 id=openfheencrypt-heiropenfheencryptop><code>openfhe.encrypt</code> (heir::openfhe::EncryptOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.encrypt` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>plaintext</code></td><td>A type for RLWE plaintexts</td></tr><tr><td style=text-align:center><code>publicKey</code></td><td>The public key required to encrypt plaintext in OpenFHE.</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhegen_context-heiropenfhegencontextop><code>openfhe.gen_context</code> (heir::openfhe::GenContextOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.gen_context` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td>The CCParams required to create CryptoContext.</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>context</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr></tbody></table><h3 id=openfhegen_mulkey-heiropenfhegenmulkeyop><code>openfhe.gen_mulkey</code> (heir::openfhe::GenMulKeyOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.gen_mulkey` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>privateKey</code></td><td>The private key required to decrypt a ciphertext in OpenFHE.</td></tr></tbody></table><h3 id=openfhegen_params-heiropenfhegenparamsop><code>openfhe.gen_params</code> (heir::openfhe::GenParamsOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.gen_params` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mulDepth</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>plainMod</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td>The CCParams required to create CryptoContext.</td></tr></tbody></table><h3 id=openfhegen_rotkey-heiropenfhegenrotkeyop><code>openfhe.gen_rotkey</code> (heir::openfhe::GenRotKeyOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.gen_rotkey` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>indices</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>privateKey</code></td><td>The private key required to decrypt a ciphertext in OpenFHE.</td></tr></tbody></table><h3 id=openfhekey_switch-heiropenfhekeyswitchop><code>openfhe.key_switch</code> (heir::openfhe::KeySwitchOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.key_switch` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>evalKey</code></td><td>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhelevel_reduce-heiropenfhelevelreduceop><code>openfhe.level_reduce</code> (heir::openfhe::LevelReduceOp)</h3><p><em>OpenFHE level_reduce operation of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.level_reduce` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhemod_reduce-heiropenfhemodreduceop><code>openfhe.mod_reduce</code> (heir::openfhe::ModReduceOp)</h3><p><em>OpenFHE mod_reduce operation of a ciphertext. (used only for BGV/CKKS)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mod_reduce` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhemul_const-heiropenfhemulconstop><code>openfhe.mul_const</code> (heir::openfhe::MulConstOp)</h3><p><em>OpenFHE mul operation of a ciphertext and a constant.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mul_const` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>constant</code></td><td>64-bit signless integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhemul_no_relin-heiropenfhemulnorelinop><code>openfhe.mul_no_relin</code> (heir::openfhe::MulNoRelinOp)</h3><p><em>OpenFHE mul operation of two ciphertexts without relinearization.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mul_no_relin` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhemul-heiropenfhemulop><code>openfhe.mul</code> (heir::openfhe::MulOp)</h3><p><em>OpenFHE mul operation of two ciphertexts with relinearization.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhemul_plain-heiropenfhemulplainop><code>openfhe.mul_plain</code> (heir::openfhe::MulPlainOp)</h3><p><em>OpenFHE mul operation of a ciphertext and a plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mul_plain` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>plaintext</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhenegate-heiropenfhenegateop><code>openfhe.negate</code> (heir::openfhe::NegateOp)</h3><p><em>OpenFHE negate operation of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.negate` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfherelin-heiropenfherelinop><code>openfhe.relin</code> (heir::openfhe::RelinOp)</h3><p><em>OpenFHE relinearize operation of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.relin` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfherot-heiropenfherotop><code>openfhe.rot</code> (heir::openfhe::RotOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.rot` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhesquare-heiropenfhesquareop><code>openfhe.square</code> (heir::openfhe::SquareOp)</h3><p><em>OpenFHE square operation of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.square` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=openfhesub-heiropenfhesubop><code>openfhe.sub</code> (heir::openfhe::SubOp)</h3><p><em>OpenFHE sub operation of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.sub` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-b18fea903e4651113f5317788f1491e1>9 - Polynomial</h1><h2 id=polynomial-additional-definitions>Polynomial additional definitions</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-c9ea40a8d17399f57cdd3c18b53cedef>10 - Random</h1><h2 id=random-types>Random types</h2><h3 id=distributiontype>DistributionType</h3><p>A random distribution type</p><p>Syntax:</p><pre tabindex=0><code>!random.distribution&lt;
  ::mlir::heir::random::Distribution   # distribution_type
&gt;
</code></pre><p>A generic type, representing a specific random distribution type of either
uniform or gaussian as an attribute ($distribution_type).</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>distribution_type</td><td style=text-align:center><code>::mlir::heir::random::Distribution</code></td><td></td></tr></tbody></table><h3 id=prngtype>PRNGType</h3><p>A pseudorandom number generator type</p><p>Syntax: <code>!random.prng</code></p><p>A type that provides pseudorandom number generator.</p><h2 id=random-ops>Random ops</h2><h3 id=randomdiscrete_gaussian_distribution-heirrandomdiscretegaussiandistributionop><code>random.discrete_gaussian_distribution</code> (heir::random::DiscreteGaussianDistributionOp)</h3><p><em>Initializes the Discrete Gaussian Distribution</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `random.discrete_gaussian_distribution` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Initializes the Discrete Gaussian Distribution. The distribution is
initialized with a mean and a standard deviation and pseudorandom generator
that provides the source of the randomness.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mean</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr><tr><td><code>stddev</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value whose value is non-negative</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A pseudorandom number generator type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A random distribution type</td></tr></tbody></table><h3 id=randomdiscrete_uniform_distribution-heirrandomdiscreteuniformdistributionop><code>random.discrete_uniform_distribution</code> (heir::random::DiscreteUniformDistributionOp)</h3><p><em>Initializes the Discrete Uniform Distribution</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `random.discrete_uniform_distribution` $input `{` `range` `=` `[` $min `,` $max `]` `}` attr-dict `:` `(` qualified(type($input)) `)` `-&gt;` type($output)
</code></pre><p>Initializes the Discrete Uniform Distribution. The distribution is
initialized with a minimum and a maximum value and pseudo random generator
that provides the source of the randomness. The distribution is inclusive of
the minimum and exclusive of the maximum.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>min</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr><tr><td><code>max</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A pseudorandom number generator type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A random distribution type</td></tr></tbody></table><h3 id=randominit_prng-heirrandominitop><code>random.init_prng</code> (heir::random::InitOp)</h3><p><em>Initializes the pseudorandom number generator with a seed.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `random.init_prng` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Initializes the PRNG with a seed. The seed is dynamically provided due to
protocols that agree on shared randomness. The PRNG is used to initialized
the random distributions such as the discrete gaussian distribution and the
discrete uniform distribution. This initialization also takes as input a
number of bits that are generated for each number value sampled (num_bits).
For instance, a num_bits of 32 will mean that distributions will generate a
32-bit integer value. We expect that the seed initialization is done statically
and globally once per thread for all distributions; however, if multiple threads are
generating randomness, then seed initialization should be done per thread;
otherwise there is no guarantee of consistent behavior. Thread safety is so
far not considered.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>num_bits</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>seed</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A pseudorandom number generator type</td></tr></tbody></table><h3 id=randomsample-heirrandomsampleop><code>random.sample</code> (heir::random::SampleOp)</h3><p><em>Samples from a distribution</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `random.sample` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Samples from the distribution to obtain a random value
or tensor of values.</p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A random distribution type</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-aeae60b865ac85372556b396a5a052ce>11 - RNS</h1><h2 id=rns-types>RNS types</h2><h3 id=rnstype>RNSType</h3><p>A residue number system representation</p><p>Syntax:</p><pre tabindex=0><code>!rns.rns&lt;
  ::llvm::ArrayRef&lt;mlir::Type&gt;   # basisTypes
&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>basisTypes</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::Type></code></td><td></td></tr></tbody></table><h2 id=rns-ops>RNS ops</h2><h2 id=rns-additional-definitions>RNS additional definitions</h2><h1 id=typeinterface-definitions>TypeInterface definitions</h1><h2 id=rnsbasistypeinterface-rnsbasistypeinterface>RNSBasisTypeInterface (<code>RNSBasisTypeInterface</code>)</h2><p>This interface is required for a type to be used as a parameter
to an <code>rns</code> type.</p><h3 id=methods>Methods:</h3><h4 id=iscompatiblewith><code>isCompatibleWith</code></h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#204a87;font-weight:700>bool</span> <span style=color:#000>isCompatibleWith</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>mlir</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Type</span> <span style=color:#000>otherRnsBasisType</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>Returns true if this type is compatible with another type in the
same RNS basis. In particular, the set of types used for a single
RNS basis are never equal as types, but instead have some common
attribute that must be checked here. For example, an RNS type where
the basis types are polynomials would return true if the two types
are both polynomial types, even if they have different coefficient
moduli.</p><p><code>isCompatibleWith</code> must be both commutative and associative, in the sense
that <code>type1.isCompatibleWith(type2)</code> if and only if
<code>type2.isCompatibleWith(type1)</code>, and further
<code>type2.isCompatibleWith(type3)</code> if and only if
<code>type1.isCompatibleWith(type3)</code>.</p><p>NOTE: This method <em>must</em> be implemented by the user.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f7ffac8ba93b73b8a62e185ec8643d63>12 - Secret</h1><p>Secret is a dialect for computations that operate on encrypted data.</p><p>Secret is intended to serve as a scheme-agnostic front-end for the HEIR
ecosystem of dialects. It is supposed to be fully interoperable with the
rest of MLIR via secret.generic, while lower-level HEIR dialects would have
custom types for arithmetic on secret integers of various bit widths.</p><h2 id=secret-types>Secret types</h2><h3 id=secrettype>SecretType</h3><p>A secret value</p><p>Syntax:</p><pre tabindex=0><code>!secret.secret&lt;
  Type   # valueType
&gt;
</code></pre><p>A generic wrapper around another MLIR type, representing an encrypted value
but not specifying the manner of encryption. This is useful in HEIR because
the compiler may choose various details of the FHE scheme based on the
properties of the input program, the backend target hardware, and cost
models of the various passes.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>valueType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h2 id=secret-ops>Secret ops</h2><h3 id=secretcast-heirsecretcastop><code>secret.cast</code> (heir::secret::CastOp)</h3><p><em>A placeholder cast from one secret type to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.cast` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
</code></pre><p>A <code>cast</code> operation represents a type cast from one secret type to another,
that is used to enable the intermixing of various equivalent secret types
before a lower-level FHE scheme has been chosen.</p><p>For example, <code>secret.cast</code> can be used to convert a <code>secret&lt;i8></code> to a
<code>secret&lt;tensor&lt;8xi1>></code> as a compatibility layer between boolean and
non-boolean parts of a program. The pass that later lowers the IR to
specific FHE schemes would need to replace these casts with appropriate
scheme-specific operations, and it is left to those later passes to
determine which casts are considered valid.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%result</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>cast <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span> to <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i1</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%result2</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>cast <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span> to <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>2x</span><span style=color:#204a87;font-weight:700>i4</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A secret value</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A secret value</td></tr></tbody></table><h3 id=secretconceal-heirsecretconcealop><code>secret.conceal</code> (heir::secret::ConcealOp)</h3><p><em>Convert a non-secret value into a secret</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.conceal` $cleartext attr-dict `:` type($cleartext) `-&gt;` type($output)
</code></pre><p>Convert a value to a secret containing the same value.</p><p>This op represents a scheme-agnostic encryption operation, as well as a
&ldquo;trivial encryption&rdquo; operation which is needed for some FHE schemes. This
op is also useful for type materialization in the dialect conversion
framework.</p><p>Examples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%Y</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>conceal <span style=color:#000>%value</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cleartext</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A secret value</td></tr></tbody></table><h3 id=secretgeneric-heirsecretgenericop><code>secret.generic</code> (heir::secret::GenericOp)</h3><p><em>Lift a plaintext computation to operate on secrets.</em></p><p><code>secret.generic</code> lifts a plaintext computation to operate on one or more
secrets. The lifted computation is represented as a region containing a
single block terminated by <code>secret.yield</code>. The arguments of the <code>secret.generic</code>
may include one or more <code>!secret.secret</code> types. The arguments of the block
in the op&rsquo;s body correspond to the underlying plaintext types of the secrets.</p><p><code>secret.generic</code> is not isolated from above, so you may directly reference
values in the enclosing scope. This is required to support using
<code>secret.generic</code> inside of ops with <code>AffineScope</code>, while having the body
of the generic use the induction variables defined by the affine scope.</p><p>Basic examples:</p><p>Add two secret integers together</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%Z</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic ins<span style=color:#000;font-weight:700>(</span><span style=color:#000>%X</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%Y</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%x</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%x</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span>
</span></span></code></pre></div><p>Add a secret value with a plaintext value. I.e., not all arguments to the
op need be secret.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%Z</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic ins<span style=color:#000;font-weight:700>(</span><span style=color:#000>%X</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%Y</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%x</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%x</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span>
</span></span></code></pre></div><p>The same as above, but the plaintext op is not passed through the basic
block.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%y</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%Z</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic ins<span style=color:#000;font-weight:700>(</span><span style=color:#000>%Y</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%x</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span>
</span></span></code></pre></div><p>Traits: <code>SingleBlockImplicitTerminator&lt;YieldOp></code>, <code>SingleBlock</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=secretreveal-heirsecretrevealop><code>secret.reveal</code> (heir::secret::RevealOp)</h3><p><em>Convert a secret value into a non-secret</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.reveal` $input attr-dict `:` type($input) `-&gt;` type($cleartext)
</code></pre><p>Convert a secret into a non-secret containing the same value.</p><p>This op represents a scheme-agnostic decryption operation. This op is also
useful for target materialization in the dialect conversion framework.</p><p>Examples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%Y</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>reveal <span style=color:#000>%secret_value</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A secret value</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cleartext</code></td><td>any type</td></tr></tbody></table><h3 id=secretseparator-heirsecretseparatorop><code>secret.separator</code> (heir::secret::SeparatorOp)</h3><p><em>Convert a non-secret value into a secret</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.separator` attr-dict ($inputs^ `:` type($inputs))?
</code></pre><p>This operation is used as a separation boundary between logical subunits of
the module. This is used in conjunction with
<code>--secret-distribute-generic=distribute-through=secret.separator</code> to break a
generic around these separators and allow for optimization passses to
analyze and optimize the sub-units locally.</p><p>In order to allow bufferization of modules with this operation, we must
register a (bogus) memory effect that also prevents this operation from
being trivially dead during operation folding.</p><p>This operation also accepts operands, which act as boundaries between the
logical units. This enforces separation of memref and affine optimizations
between the subunits, preventing optimizations from removing the operand and
combining the two separated regions. The operand can be thought of as an
return value of the logical subunit.</p><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=secretyield-heirsecretyieldop><code>secret.yield</code> (heir::secret::YieldOp)</h3><p><em>Secret yield operation</em></p><p><code>secret.yield</code> is a special terminator operation for blocks inside regions
in <code>secret</code> generic ops. It returns the cleartext value of the
corresponding private computation to the immediately enclosing <code>secret</code>
generic op.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;GenericOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>variadic of any type</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ca9ddb02db7c0683037407c6f9eb1f2a>13 - TensorExt</h1><h2 id=tensorext-attributes>TensorExt attributes</h2><h3 id=simdpackingattr>SIMDPackingAttr</h3><p>An attribute describing the SIMD packing of a tensor.</p><p>Syntax:</p><pre tabindex=0><code>#tensor_ext.simd_packing&lt;
  ::mlir::DenseI64ArrayAttr,   # in
  ::mlir::DenseI64ArrayAttr,   # padding
  ::mlir::DenseI64ArrayAttr,   # out
  int64_t   # padding_value
&gt;
</code></pre><p>This attribute is used as the encoding attribute on a tensor. It describes
the transformations that were applied to an input tensor to pack it into the
given tensor.</p><p>The <code>in</code> attribute describes the shape of the original tensor.
The following transformations are applied to the input tensor.</p><ol><li><p>Padding is applied first. The <code>padding</code> attribute is an array with the
same size as the input tensor shape. Padding is applied at the end of
the array using the <code>padding_value</code> attribute (default zero). The
result after zero padding should be a power of two.</p></li><li><p>The padded result is replicated or split to fill the output tensor
shape.</p></li></ol><p>For example,</p><pre tabindex=0><code>#packing = #tensor_ext.simd_packing&lt;
  in = [7],
  padding = [1],
  padding_value = 0,
  out = [16],
&gt;
</code></pre><p>may be used on a tensor type like</p><pre tabindex=0><code>tensor&lt;1x16xi32, #packing&gt;
</code></pre><p>If the original tensor had values <code>[1, 2, 3, 4, 5, 6, 7]</code> then a tensor with
this attribute contains the data <code>[1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0]</code>.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>in</td><td style=text-align:center><code>::mlir::DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>padding</td><td style=text-align:center><code>::mlir::DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>out</td><td style=text-align:center><code>::mlir::DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>padding_value</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h2 id=tensorext-ops>TensorExt ops</h2><h3 id=tensor_extrotate-heirtensor_extrotateop><code>tensor_ext.rotate</code> (heir::tensor_ext::RotateOp)</h3><p><em>Rotate a tensor some number of indices left.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tensor_ext.rotate` operands attr-dict `:` qualified(type($tensor)) `,` type($shift)
</code></pre><p>This op represents a left-rotation of a tensor by given number of indices.
Negative shift values are interpreted as right-rotations.</p><p>This corresponds to the <code>rotate</code> operation in arithmetic FHE schemes like
BGV.</p><p>Examples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>...</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%c7</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>7</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span>_ext<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c7</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tensor</code></td><td>tensor of any type values</td></tr><tr><td style=text-align:center><code>shift</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of any type values</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-678c1db0f9b2ed4c9d43b790f890bea0>14 - TfheRust</h1><p>The <code>thfe_rust</code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the shortint parameters and encoding scheme.</p><p>See <a href=https://github.com/zama-ai/tfhe-rs>https://github.com/zama-ai/tfhe-rs</a></p><h2 id=tfherust-types>TfheRust types</h2><h3 id=encryptedint8type>EncryptedInt8Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type</p><p>Syntax: <code>!tfhe_rust.ei8</code></p><h3 id=encryptedint16type>EncryptedInt16Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type</p><p>Syntax: <code>!tfhe_rust.ei16</code></p><h3 id=encryptedint32type>EncryptedInt32Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type</p><p>Syntax: <code>!tfhe_rust.ei32</code></p><h3 id=encryptedint64type>EncryptedInt64Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type</p><p>Syntax: <code>!tfhe_rust.ei64</code></p><h3 id=encryptedint128type>EncryptedInt128Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type</p><p>Syntax: <code>!tfhe_rust.ei128</code></p><h3 id=encryptedint256type>EncryptedInt256Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</p><p>Syntax: <code>!tfhe_rust.ei256</code></p><h3 id=encrypteduint2type>EncryptedUInt2Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type</p><p>Syntax: <code>!tfhe_rust.eui2</code></p><h3 id=encrypteduint3type>EncryptedUInt3Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type</p><p>Syntax: <code>!tfhe_rust.eui3</code></p><h3 id=encrypteduint4type>EncryptedUInt4Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type</p><p>Syntax: <code>!tfhe_rust.eui4</code></p><h3 id=encrypteduint8type>EncryptedUInt8Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type</p><p>Syntax: <code>!tfhe_rust.eui8</code></p><h3 id=encrypteduint10type>EncryptedUInt10Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type</p><p>Syntax: <code>!tfhe_rust.eui10</code></p><h3 id=encrypteduint12type>EncryptedUInt12Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type</p><p>Syntax: <code>!tfhe_rust.eui12</code></p><h3 id=encrypteduint14type>EncryptedUInt14Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type</p><p>Syntax: <code>!tfhe_rust.eui14</code></p><h3 id=encrypteduint16type>EncryptedUInt16Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type</p><p>Syntax: <code>!tfhe_rust.eui16</code></p><h3 id=encrypteduint32type>EncryptedUInt32Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type</p><p>Syntax: <code>!tfhe_rust.eui32</code></p><h3 id=encrypteduint64type>EncryptedUInt64Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type</p><p>Syntax: <code>!tfhe_rust.eui64</code></p><h3 id=encrypteduint128type>EncryptedUInt128Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type</p><p>Syntax: <code>!tfhe_rust.eui128</code></p><h3 id=encrypteduint256type>EncryptedUInt256Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type</p><p>Syntax: <code>!tfhe_rust.eui256</code></p><h3 id=lookuptabletype>LookupTableType</h3><p>A univariate lookup table used for programmable bootstrapping.</p><p>Syntax: <code>!tfhe_rust.lookup_table</code></p><h3 id=serverkeytype>ServerKeyType</h3><p>The short int server key required to perform homomorphic operations.</p><p>Syntax: <code>!tfhe_rust.server_key</code></p><h2 id=tfherust-ops>TfheRust ops</h2><h3 id=tfhe_rustapply_lookup_table-heirtfhe_rustapplylookuptableop><code>tfhe_rust.apply_lookup_table</code> (heir::tfhe_rust::ApplyLookupTableOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.apply_lookup_table` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>input</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr><tr><td style=text-align:center><code>lookupTable</code></td><td>A univariate lookup table used for programmable bootstrapping.</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr></tbody></table><h3 id=tfhe_rustcreate_trivial-heirtfhe_rustcreatetrivialop><code>tfhe_rust.create_trivial</code> (heir::tfhe_rust::CreateTrivialOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.create_trivial` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>value</code></td><td>integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr></tbody></table><h3 id=tfhe_rustgenerate_lookup_table-heirtfhe_rustgeneratelookuptableop><code>tfhe_rust.generate_lookup_table</code> (heir::tfhe_rust::GenerateLookupTableOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.generate_lookup_table` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>truthTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lookupTable</code></td><td>A univariate lookup table used for programmable bootstrapping.</td></tr></tbody></table><h3 id=tfhe_rustscalar_left_shift-heirtfhe_rustscalarleftshiftop><code>tfhe_rust.scalar_left_shift</code> (heir::tfhe_rust::ScalarLeftShiftOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.scalar_left_shift` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr><tr><td style=text-align:center><code>shiftAmount</code></td><td>8-bit integer</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr></tbody></table><h3 id=tfhe_rustadd-heirtfhe_rustaddop><code>tfhe_rust.add</code> (heir::tfhe_rust::AddOp)</h3><p><em>Arithmetic add of two tfhe ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr></tbody></table><h3 id=tfhe_rustbitand-heirtfhe_rustbitandop><code>tfhe_rust.bitand</code> (heir::tfhe_rust::BitAndOp)</h3><p><em>Logical AND of two tfhe ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.bitand` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr></tbody></table><h3 id=tfhe_rustsub-heirtfhe_rustsubop><code>tfhe_rust.sub</code> (heir::tfhe_rust::SubOp)</h3><p><em>Arithmetic sub of two tfhe ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.sub` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-d46d9ee8aeb1f8889ca7cfc9a061a7cc>15 - TfheRustBool</h1><p>The <code>tfhe_rust_bool</code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the boolean parameter set.</p><p>See <a href=https://github.com/zama-ai/tfhe-rs>https://github.com/zama-ai/tfhe-rs</a></p><h2 id=tfherustbool-types>TfheRustBool types</h2><h3 id=booleangateandtype>BooleanGateAndType</h3><p>Enum placeholder to define the binary gateAnd to perform as homomoprhic operation.</p><p>Syntax: <code>!tfhe_rust_bool.bin_gateAnd</code></p><h3 id=booleangatenandtype>BooleanGateNandType</h3><p>Enum placeholder to define the binary gateNand to perform as homomoprhic operation.</p><p>Syntax: <code>!tfhe_rust_bool.bin_gateNand</code></p><h3 id=booleangatenortype>BooleanGateNorType</h3><p>Enum placeholder to define the binary gateNor to perform as homomoprhic operation.</p><p>Syntax: <code>!tfhe_rust_bool.bin_gateNor</code></p><h3 id=booleangateortype>BooleanGateOrType</h3><p>Enum placeholder to define the binary gateOr to perform as homomoprhic operation.</p><p>Syntax: <code>!tfhe_rust_bool.bin_gateOr</code></p><h3 id=booleangatexnortype>BooleanGateXnorType</h3><p>Enum placeholder to define the binary gateXnor to perform as homomoprhic operation.</p><p>Syntax: <code>!tfhe_rust_bool.bin_gateXnor</code></p><h3 id=booleangatexortype>BooleanGateXorType</h3><p>Enum placeholder to define the binary gateXor to perform as homomoprhic operation.</p><p>Syntax: <code>!tfhe_rust_bool.bin_gateXor</code></p><h3 id=encryptedbooltype>EncryptedBoolType</h3><p>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</p><p>Syntax: <code>!tfhe_rust_bool.eb</code></p><h3 id=serverkeytype>ServerKeyType</h3><p>The boolean server key required to perform homomorphic operations.</p><p>Syntax: <code>!tfhe_rust_bool.server_key</code></p><h2 id=tfherustbool-ops>TfheRustBool ops</h2><h3 id=tfhe_rust_boolcreate_trivial-heirtfhe_rust_boolcreatetrivialop><code>tfhe_rust_bool.create_trivial</code> (heir::tfhe_rust_bool::CreateTrivialOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.create_trivial` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>value</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr></tbody></table><h3 id=tfhe_rust_booland-heirtfhe_rust_boolandop><code>tfhe_rust_bool.and</code> (heir::tfhe_rust_bool::AndOp)</h3><p><em>Logical AND of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.and` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolmux-heirtfhe_rust_boolmuxop><code>tfhe_rust_bool.mux</code> (heir::tfhe_rust_bool::MuxOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.mux` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>cnd</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr></tbody></table><h3 id=tfhe_rust_boolnand-heirtfhe_rust_boolnandop><code>tfhe_rust_bool.nand</code> (heir::tfhe_rust_bool::NandOp)</h3><p><em>Logical NAND of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.nand` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolnor-heirtfhe_rust_boolnorop><code>tfhe_rust_bool.nor</code> (heir::tfhe_rust_bool::NorOp)</h3><p><em>Logical NOR of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.nor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolnot-heirtfhe_rust_boolnotop><code>tfhe_rust_bool.not</code> (heir::tfhe_rust_bool::NotOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.not` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>input</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolor-heirtfhe_rust_boolorop><code>tfhe_rust_bool.or</code> (heir::tfhe_rust_bool::OrOp)</h3><p><em>Logical OR of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.or` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolpacked-heirtfhe_rust_boolpackedop><code>tfhe_rust_bool.packed</code> (heir::tfhe_rust_bool::PackedOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.packed` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>gates</code></td><td>Enum placeholder to define the binary gateAnd to perform as homomoprhic operation. or Enum placeholder to define the binary gateOr to perform as homomoprhic operation. or Enum placeholder to define the binary gateXor to perform as homomoprhic operation. or Enum placeholder to define the binary gateNand to perform as homomoprhic operation. or Enum placeholder to define the binary gateNor to perform as homomoprhic operation. or Enum placeholder to define the binary gateXnor to perform as homomoprhic operation.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolxnor-heirtfhe_rust_boolxnorop><code>tfhe_rust_bool.xnor</code> (heir::tfhe_rust_bool::XnorOp)</h3><p><em>Logical XNOR of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.xnor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolxor-heirtfhe_rust_boolxorop><code>tfhe_rust_bool.xor</code> (heir::tfhe_rust_bool::XorOp)</h3><p><em>Logical XOR of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.xor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/google/heir aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2024 The HEIR Authors All Rights Reserved</span>
<span class=ms-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.027d75d71824837bee74c12a7806c5fe51249c1ca7accc27553a251a75cdb3a4.js integrity="sha256-An111xgkg3vudMEqeAbF/lEknBynrMwnVTolGnXNs6Q=" crossorigin=anonymous></script>
<script defer src=/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>