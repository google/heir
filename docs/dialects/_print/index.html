<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.113.0"><link rel=canonical type=text/html href=https://heir.dev/docs/dialects/><link rel=alternate type=application/rss+xml href=https://heir.dev/docs/dialects/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Dialects | HEIR</title><meta name=description content><meta property="og:title" content="Dialects"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://heir.dev/docs/dialects/"><meta itemprop=name content="Dialects"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="Dialects"><meta name=twitter:description content><link rel=preload href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css as=style><link href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=td-section><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="32" height="32" fill="#fff" fill-opacity=".01"/><path d="M18.6889 10.124l7.7916 5.0511 2.6263-1.6684-2.6146-1.6779-7.8033-4.96754 2.8526 1.84162L18.6889 10.124z" fill="#efcf6f"/><path d="M29.1185 6.86125 18.6979.13981 16.06 1.79876 26.4922 8.52025l2.6263-1.659z" fill="#efcf6f"/><path d="M8.2405 6.74134 5.60033 5.07291 3.05751 6.79935 5.67334 8.49344 8.2405 6.74134z" fill="#ee958a"/><path d="M10.8697 8.49344 8.2405 10.124v3.3995l5.2049-3.3348-2.5757-1.69526z" fill="#ee958a"/><path d="M5.67334 8.49344 3.05751 6.79935 3.03318 23.4932l2.64016 1.6897V8.49344z" fill="#a32e24"/><path d="M29.1185 6.86126 26.4922 8.52025V11.8288l2.6263-1.6401V6.86126z" fill="#d38041"/><path d="M21.5415 8.70288 18.6889 6.86126V10.124l2.8526-1.42112z" fill="#d38041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M8.2405 6.74134V10.124v3.3995l5.2049-3.3348V3.58723l2.6145-1.7885L16.1123 11.8484V18.467l-2.6158 1.6181L13.4574 13.5235 10.849 15.1694 8.2405 16.8152v6.678L5.67334 25.1829V8.49344L8.2405 6.74134z" fill="#dd583b"/><path d="M13.4965 20.0851 13.4574 13.5235 10.849 15.1694 10.8077 18.467l2.6888 1.6181z" fill="#a32e24"/><path fill-rule="evenodd" clip-rule="evenodd" d="M13.4454 3.58723V10.1887L10.8697 8.49344 10.9293 1.79873l2.5161 1.7885z" fill="#a32e24"/><path d="M16.0599 1.79873 13.4454.13981 10.9293 1.79873l2.5161 1.7885 2.6145-1.7885z" fill="#ee958a"/><path d="M16.06 1.79876 16.0793 5.52165 16.1123 11.8484V18.467l2.5766-1.6518V13.4696 10.124 6.86126l7.8033 4.96754V8.52025L16.06 1.79876z" fill="#e5ad11"/><path d="M18.6889 16.8152 16.1123 18.467l10.3682 6.7159V21.8372l-7.7916-5.022z" fill="#e5ad11"/><path d="M26.4805 15.1751 18.6889 10.124v3.3456l2.7505 1.7641 5.0411 3.2333V15.1751z" fill="#e5ad11"/><path d="M29.1068 13.5067l-2.6263 1.6684V18.467l2.6263-1.6518V13.5067z" fill="#d48041"/><path d="M29.1185 20.0851l-2.638 1.7521v3.3457l2.6263-1.6897L29.1185 20.0851z" fill="#d48041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M26.4805 21.8372l-7.7916-5.022 2.7505-1.5815 5.0411 3.2333 2.638 1.6181-2.638 1.7521z" fill="#efcf6f"/><path d="M18.6889 13.4696v3.3456l2.7505-1.5815-2.7505-1.7641z" fill="#d48041"/><path d="M20.1621 26.5165l-4.2015-2.7017-4.2015-2.7016L11.7108 23.8491l6.3384 4.0776 2.1129 1.3512V26.5165z" fill="#395aad"/><path d="M7.49852 23.8491v2.6674l8.41958 5.4439V29.2779L7.49852 23.8491z" fill="#276e3a"/><path d="M9.57951 22.4781l-2.08099 1.371 8.41958 5.4288 2.1311-1.3512-6.3384-4.0776-2.13129-1.371z" fill="#add284"/><path d="M24.3747 26.5165V23.8491L22.174 22.8377l-2.0054.9665 2.1815 1.3793 2.0246 1.333z" fill="#395aad"/><path d="M18.0492 19.7061l2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#395aad"/><path fill-rule="evenodd" clip-rule="evenodd" d="M20.1621 18.4432l-2.0415-.596-2.1581.596-2.1017 1.3349-2.1017 1.3351 2.1012 1.3511 6.3018 4.0522 2.188-1.333-2.1815-1.3793 2.0054-.9665 2.2007 1.0114 2.0995-1.329-2.0811-1.4069L22.3501 21.1371l-.1752-1.4237L22.174 19.7061l-2.0119-1.2629zm-2.1129 1.2629 2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#9ec4e0"/><path d="M26.4742 22.5201l-2.0995 1.329v2.6674l2.1289-1.3305L26.4742 22.5201z" fill="#4285f4"/><path d="M20.1621 26.5165v2.7614l2.188-1.3512V25.1835l-2.188 1.333z" fill="#4285f4"/><path d="M15.9181 29.2779v2.6825l2.1311-1.3708V27.9267l-2.1311 1.3512z" fill="#4e9c68"/></svg></span><span class=navbar-brand__name>HEIR</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/><span>Home</span></a></li><li class=nav-item><a class="nav-link active" href=/docs/><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://github.com/google/heir/ target=_blank rel=noopener><span>GitHub</span></a></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/dialects/>Return to the regular view of this page</a>.</p></div><h1 class=title>Dialects</h1><ul><li>1: <a href=#pg-7a2d769a54237b8d0845fe32a6451c2b>BGV</a></li><li>2: <a href=#pg-5f74537b9610a2b3f8ddf498be3d47b0>CGGI</a></li><li>3: <a href=#pg-818a3660f61ebf5859b5c98635beacc8>CKKS</a></li><li>4: <a href=#pg-80cc312dd83f43a069330083f04eb4f2>Comb</a></li><li>5: <a href=#pg-df73b993320a0b803398dca1b5f7c3cd>Jaxite</a></li><li>6: <a href=#pg-63d08712eb5ec0da1ca62003de70e7f1>JaxiteWord</a></li><li>7: <a href=#pg-6857a323f6f4a36b66d9290a3b2c84fc>Lattigo</a></li><li>8: <a href=#pg-c5dda3cb8e694541eacbee638af7317d>LWE</a></li><li>9: <a href=#pg-024e5f7d26a5dfbbc21bb90c29119ca6>MathExt</a></li><li>10: <a href=#pg-b15a871dcca009396e70be943220c783>Mgmt</a></li><li>11: <a href=#pg-75945813f3978b67fb0398cc4f17cb8b>ModArith</a></li><li>12: <a href=#pg-e397c035ea096bd861aadf40d3fccd0a>Openfhe</a></li><li>13: <a href=#pg-b18fea903e4651113f5317788f1491e1>Polynomial</a></li><li>14: <a href=#pg-c9ea40a8d17399f57cdd3c18b53cedef>Random</a></li><li>15: <a href=#pg-aeae60b865ac85372556b396a5a052ce>RNS</a></li><li>16: <a href=#pg-f7ffac8ba93b73b8a62e185ec8643d63>Secret</a></li><li>17: <a href=#pg-ca9ddb02db7c0683037407c6f9eb1f2a>TensorExt</a></li><li>18: <a href=#pg-678c1db0f9b2ed4c9d43b790f890bea0>TfheRust</a></li><li>19: <a href=#pg-d46d9ee8aeb1f8889ca7cfc9a061a7cc>TfheRustBool</a></li></ul><div class=content><p>This section contains the reference documentation for all of the dialects
defined in HEIR.</p></div></div><div class=td-content><h1 id=pg-7a2d769a54237b8d0845fe32a6451c2b>1 - BGV</h1><h1 id=bgv-dialect>&lsquo;bgv&rsquo; Dialect</h1><p>The BGV dialect defines the types and operations of the BGV and B/FV cryptosystem.</p><p>Due to similarity with the BFV scheme, BGV dialect also represents the B/FV scheme.</p><p>The semantics of bgv dialect operations are determined by the <code>scheme.bgv</code> or <code>scheme.bfv</code>
annotation at the module level.</p><p>In B/FV mode, bgv.modulus_switch is an no-op.</p><h2 id=bgv-attributes>BGV attributes</h2><h3 id=schemeparamattr>SchemeParamAttr</h3><p><em>BGV Scheme Parameters</em></p><p>Syntax:</p><pre tabindex=0><code>#bgv.scheme_param&lt;
  int,   # logN
  DenseI64ArrayAttr,   # Q
  DenseI64ArrayAttr,   # P
  int64_t,   # plaintextModulus
  BGVEncryptionType,   # encryptionType
  BGVEncryptionTechnique   # encryptionTechnique
&gt;
</code></pre><p>This attribute is used for recording the scheme parameters for CKKS.</p><p>The attribute is a struct with the following fields:</p><ul><li><code>int</code> logN: The log of the degree of the polynomial modulus.</li><li><code>DenseI64ArrayAttr</code> Q: The array of primes in the ciphertext modulus.</li><li><code>DenseI64ArrayAttr</code> P: The array of primes in the special modulus, used for key switching.</li><li><code>int64_t</code> plaintextModulus: The plaintext modulus.</li></ul><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>logN</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>Q</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>P</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintextModulus</td><td style=text-align:center><code>int64_t</code></td><td></td></tr><tr><td style=text-align:center>encryptionType</td><td style=text-align:center><code>BGVEncryptionType</code></td><td></td></tr><tr><td style=text-align:center>encryptionTechnique</td><td style=text-align:center><code>BGVEncryptionTechnique</code></td><td></td></tr></tbody></table><h2 id=bgv-ops>BGV ops</h2><h3 id=bgvadd-heirbgvaddop><code>bgv.add</code> (heir::bgv::AddOp)</h3><p><em>Addition operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.add` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvadd_plain-heirbgvaddplainop><code>bgv.add_plain</code> (heir::bgv::AddPlainOp)</h3><p><em>Addition operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.add_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AllCiphertextTypesMatch</code>, <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>IsCiphertextPlaintextOp</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvlevel_reduce-heirbgvlevelreduceop><code>bgv.level_reduce</code> (heir::bgv::LevelReduceOp)</h3><p><em>Lower the modulus level of the ciphertext via dropping RNS limbs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.level_reduce` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>levelToDrop</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvmodulus_switch-heirbgvmodulusswitchop><code>bgv.modulus_switch</code> (heir::bgv::ModulusSwitchOp)</h3><p><em>Lower the modulus level of the ciphertext via modulus switching.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.modulus_switch` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>to_ring</code></td><td>::mlir::heir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvmul-heirbgvmulop><code>bgv.mul</code> (heir::bgv::MulOp)</h3><p><em>Multiplication operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.mul` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvmul_plain-heirbgvmulplainop><code>bgv.mul_plain</code> (heir::bgv::MulPlainOp)</h3><p><em>Multiplication operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.mul_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>IsCiphertextPlaintextOp</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvnegate-heirbgvnegateop><code>bgv.negate</code> (heir::bgv::NegateOp)</h3><p><em>Negate the coefficients of the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.negate` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Involution</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvrelinearize-heirbgvrelinearizeop><code>bgv.relinearize</code> (heir::bgv::RelinearizeOp)</h3><p><em>Relinearize the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.relinearize` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>This op takes integer array attributes <code>from_basis</code> and <code>to_basis</code> that are
used to indicate the key basis from which and to which the ciphertext is
encrypted against. A ciphertext is canonically encrypted against key basis
<code>(1, s)</code>. After a multiplication, its size will increase and the basis will be
<code>(1, s, s^2)</code>. The array that represents the key basis is constructed by
listing the powers of <code>s</code> at each position of the array. For example, <code>(1, s, s^2)</code> corresponds to <code>[0, 1, 2]</code>, while <code>(1, s^2)</code> corresponds to <code>[0, 2]</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>from_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>to_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvrotate_cols-heirbgvrotatecolumnsop><code>bgv.rotate_cols</code> (heir::bgv::RotateColumnsOp)</h3><p><em>Rotate the columns of the coefficients of the ciphertext using a Galois automorphism.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.rotate_cols` operands attr-dict `:` qualified(type($input))
</code></pre><p>This operation rotates the columns of the coefficients of the ciphertext using a
Galois automorphism.</p><p>Often BGV scheme is instantiated with a ring of the form <code>Z_q[X]/(X^N + 1)</code> and
plaintext modulus <code>t</code> where <code>N</code> is a power of 2 and <code>t</code> is a prime number. In
this case, the plaintext slots can be viewed as a <code>2 x N/2</code> matrix where
<code>N/2</code> is the number of columns and <code>2</code> is the number of rows.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvrotate_rows-heirbgvrotaterowsop><code>bgv.rotate_rows</code> (heir::bgv::RotateRowsOp)</h3><p><em>Rotate the rows of the coefficients of the ciphertext using a Galois automorphism.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.rotate_rows` operands attr-dict `:` qualified(type($input))
</code></pre><p>This operation rotates the rows of the coefficients of the ciphertext using a
Galois automorphism.</p><p>Often BGV scheme is instantiated with a ring of the form <code>Z_q[X]/(X^N + 1)</code> and
plaintext modulus <code>t</code> where <code>N</code> is a power of 2 and <code>t</code> is a prime number. In
this case, the plaintext slots can be viewed as a <code>2 x N/2</code> matrix where
<code>N/2</code> is the number of columns and <code>2</code> is the number of rows.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvsub-heirbgvsubop><code>bgv.sub</code> (heir::bgv::SubOp)</h3><p><em>Subtraction operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.sub` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=bgvsub_plain-heirbgvsubplainop><code>bgv.sub_plain</code> (heir::bgv::SubPlainOp)</h3><p><em>Subtraction operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.sub_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AllCiphertextTypesMatch</code>, <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>IsCiphertextPlaintextOp</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h2 id=bgv-additional-definitions>BGV additional definitions</h2><h3 id=bgvencryptiontechnique>BGVEncryptionTechnique</h3><p><em>An enum attribute representing an encryption technique</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>standard</td><td style=text-align:center><code>0</code></td><td>standard</td></tr><tr><td style=text-align:center>extended</td><td style=text-align:center><code>1</code></td><td>extended</td></tr></tbody></table><h3 id=bgvencryptiontype>BGVEncryptionType</h3><p><em>An enum attribute representing an encryption method</em></p><h4 id=cases-1>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>pk</td><td style=text-align:center><code>0</code></td><td>pk</td></tr><tr><td style=text-align:center>sk</td><td style=text-align:center><code>1</code></td><td>sk</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-5f74537b9610a2b3f8ddf498be3d47b0>2 - CGGI</h1><h1 id=cggi-dialect>&lsquo;cggi&rsquo; Dialect</h1><p><em>A dialect for types and operations in the CGGI cryptosystem</em></p><h2 id=cggi-attributes>CGGI attributes</h2><h3 id=cggiboolgatesattr>CGGIBoolGatesAttr</h3><p><em>An attribute containing an array of strings to store bool gates</em></p><p>Syntax:</p><pre tabindex=0><code>#cggi.cggi_bool_gates&lt;
  ::llvm::ArrayRef&lt;::mlir::heir::cggi::CGGIBoolGateEnumAttr&gt;   # gates
&gt;
</code></pre><pre><code>This attributes stores a list of integer identifiers for Boolean gates.
</code></pre><p>Uses following mapping:
AND_GATE = 0;
NAND_GATE = 1;
OR_GATE = 2;
NOR_GATE = 3;
XOR_GATE = 4;
XNOR_GATE = 5;
NOT_GATE = 6;</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>gates</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::heir::cggi::CGGIBoolGateEnumAttr></code></td><td></td></tr></tbody></table><h2 id=cggi-ops>CGGI ops</h2><h3 id=cggiadd-heircggiaddop><code>cggi.add</code> (heir::cggi::AddOp)</h3><p><em>Arithmetic addition of two ciphertexts. One of the two ciphertext is allowed to be a scalar, this will result in the scalar addition to a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or A ciphertext type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=cggiand-heircggiandop><code>cggi.and</code> (heir::cggi::AndOp)</h3><p><em>Logical AND of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.and` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggicast-heircggicastop><code>cggi.cast</code> (heir::cggi::CastOp)</h3><p><em>Change the plaintext space of a CGGI ciphertext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.cast` $input attr-dict `:` type($input) `to` type($output)
</code></pre><p>&ldquo;cast&rdquo; operation to change the plaintext size of a CGGI ciphertext.
Note this operations is not a standard CGGI operation, but an mirror of the cast op implemented in TFHE-rs.</p><p>Examples:</p><pre tabindex=0><code>`cggi.cast %c0 : !lwe.lwe_ciphertext&lt;encoding = #unspecified_bit_field_encoding&gt; to !lwe.lwe_ciphertext&lt;encoding = #unspecified_bit_field_encoding1&gt;`
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggicmp-heircggicmpop><code>cggi.cmp</code> (heir::cggi::CmpOp)</h3><p>_High level operation to check the relation of two ciphertexts.</p><ul><li>equal (mnemonic: &ldquo;eq&rdquo;; integer value: 0)</li><li>not equal (mnemonic: &ldquo;ne&rdquo;; integer value: 1)</li><li>signed less than (mnemonic: &ldquo;slt&rdquo;; integer value: 2)</li><li>signed less than or equal (mnemonic: &ldquo;sle&rdquo;; integer value: 3)</li><li>signed greater than (mnemonic: &ldquo;sgt&rdquo;; integer value: 4)</li><li>signed greater than or equal (mnemonic: &ldquo;sge&rdquo;; integer value: 5)</li><li>unsigned less than (mnemonic: &ldquo;ult&rdquo;; integer value: 6)</li><li>unsigned less than or equal (mnemonic: &ldquo;ule&rdquo;; integer value: 7)</li><li>unsigned greater than (mnemonic: &ldquo;ugt&rdquo;; integer value: 8)</li><li>unsigned greater than or equal (mnemonic: &ldquo;uge&rdquo;; integer value: 9)</li></ul><p>Note: <a href=https://mlir.llvm.org/docs/Dialects/ArithOps/#arithcmpi-arithcmpiop>https://mlir.llvm.org/docs/Dialects/ArithOps/#arithcmpi-arithcmpiop</a>
Note this operations to indirect mirror the TFHE-rs implmementation._</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.cmp` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::arith::CmpIPredicateAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggicreate_trivial-heircggicreatetrivialop><code>cggi.create_trivial</code> (heir::cggi::CreateTrivialOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.create_trivial` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>An Attribute containing a integer value or A collection of other Attribute values</td></tr></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggieq-heircggieqop><code>cggi.eq</code> (heir::cggi::EqOp)</h3><p><em>High level operation to check equality of two ciphertexts. Note this operations to mirror the TFHE-rs implmementation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.eq` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or A ciphertext type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=cggilut2-heircggilut2op><code>cggi.lut2</code> (heir::cggi::Lut2Op)</h3><p><em>A lookup table on two inputs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.lut2` operands attr-dict `:` qualified(type($output))
</code></pre><p>An op representing a lookup table applied to some number <code>n</code> of ciphertexts
encrypting boolean input bits.</p><p>Over cleartext bits <code>a, b, c</code>, using <code>n = 3</code> for example, the operation
computed by this function can be interpreted as</p><pre tabindex=0><code>  truth_table &gt;&gt; {c, b, a}
</code></pre><p>where <code>{c, b, a}</code> is the unsigned 3-bit integer with bits <code>c, b, a</code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookup_table</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>b</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>a</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggilut3-heircggilut3op><code>cggi.lut3</code> (heir::cggi::Lut3Op)</h3><p><em>A lookup table on three inputs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.lut3` operands attr-dict `:` qualified(type($output))
</code></pre><p>An op representing a lookup table applied to some number <code>n</code> of ciphertexts
encrypting boolean input bits.</p><p>Over cleartext bits <code>a, b, c</code>, using <code>n = 3</code> for example, the operation
computed by this function can be interpreted as</p><pre tabindex=0><code>  truth_table &gt;&gt; {c, b, a}
</code></pre><p>where <code>{c, b, a}</code> is the unsigned 3-bit integer with bits <code>c, b, a</code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookup_table</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>c</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>b</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>a</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggilut_lincomb-heircggilutlincombop><code>cggi.lut_lincomb</code> (heir::cggi::LutLinCombOp)</h3><p><em>A variadic-input lookup table with inputs prepared via linear combination.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.lut_lincomb` operands attr-dict `:` type($output)
</code></pre><p>An op representing a lookup table applied to an arbitrary number of
input ciphertexts, which are combined according to a static linear
combination attached to the op.</p><p>The user must ensure the chosen linear combination does not bleed error
bits into the message space according to the underlying ciphertext&rsquo;s
encoding attributes. E.g., a bit_field_encoding with 3 cleartext bits
cannot be multiplied by 16.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#encoding</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.bit_field_encoding</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cleartext_start=</span><span style=color:#0000cf;font-weight:700>30</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>cleartext_bitwidth=</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#params</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.lwe_params</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cmod=</span><span style=color:#0000cf;font-weight:700>7917</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>dimension=</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>ciphertext =</span> <span style=color:#000;font-weight:700>!</span>lwe<span style=color:#000;font-weight:700>.</span>lwe_ciphertext<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>encoding =</span> <span style=color:#000>#encoding</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>lwe_params =</span> <span style=color:#000>#params</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> cggi<span style=color:#000;font-weight:700>.</span>lut_lincomb <span style=color:#000>%c0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c3</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>coefficients =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#f57900>lookup_table =</span> <span style=color:#0000cf;font-weight:700>68</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>ciphertext
</span></span></code></pre></div><p>Represents applying the lut</p><pre tabindex=0><code>  68 &gt;&gt; (1 * c0 + 2 * c1 + 3 * c2 + 2 * c3)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>lookup_table</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=cggimax-heircggimaxop><code>cggi.max</code> (heir::cggi::MaxOp)</h3><p><em>High level operation to return maximum of two ciphertexts. Note this operations to mirror the TFHE-rs implmementation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.max` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or A ciphertext type</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=cggimin-heircggiminop><code>cggi.min</code> (heir::cggi::MinOp)</h3><p><em>High level operation to return minimum of two ciphertexts. Note this operations to mirror the TFHE-rs implmementation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.min` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or A ciphertext type</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=cggimul-heircggimulop><code>cggi.mul</code> (heir::cggi::MulOp)</h3><p><em>Arithmetic multiplication of two ciphertexts. One of the two ciphertext is allowed to be a scalar, this will result in the scalar multiplication to a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>While CGGI does not have a native multiplication operation,
some backend targets provide a multiplication
operation that is implemented via a sequence
of other atomic CGGI ops. When lowering to
backends that do not have this, one must lower
to this op the appropriate CGGI ops.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or A ciphertext type</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=cggimulti_lut_lincomb-heircggimultilutlincombop><code>cggi.multi_lut_lincomb</code> (heir::cggi::MultiLutLinCombOp)</h3><p><em>A multi-output version of lut_lincomb with one LUT per output.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.multi_lut_lincomb` operands attr-dict `:` functional-type($inputs, $outputs)
</code></pre><p>An op representing multiple lookup tables applied to a shared input, which
is prepared via a static linear combination. This is equivalent to
<code>cggi.lut_lincomb</code>, but where the linear combination is given to multiple
lookup tables, each producing a separate output.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#encoding</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.bit_field_encoding</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cleartext_start=</span><span style=color:#0000cf;font-weight:700>30</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>cleartext_bitwidth=</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#params</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.lwe_params</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cmod=</span><span style=color:#0000cf;font-weight:700>7917</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>dimension=</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>ciphertext =</span> <span style=color:#000;font-weight:700>!</span>lwe<span style=color:#000;font-weight:700>.</span>lwe_ciphertext<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>encoding =</span> <span style=color:#000>#encoding</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>lwe_params =</span> <span style=color:#000>#params</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> cggi<span style=color:#000;font-weight:700>.</span>multi_lut_lincomb <span style=color:#000>%c0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c3</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#f57900>coefficients =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;,</span>
</span></span><span style=display:flex><span>    <span style=color:#f57900>lookup_tables =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>68</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>70</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Represents applying the following LUTs. Performance-wise, this is
comparable to applying a single LUT to a linear combination.</p><pre tabindex=0><code>x = (1 * c0 + 2 * c1 + 3 * c2 + 2 * c3)
return (
  (68 &gt;&gt; x) &amp; 1,
  (70 &gt;&gt; x) &amp; 1,
  (4 &gt;&gt; x) &amp; 1,
  (8 &gt;&gt; x) &amp; 1
)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>lookup_tables</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of lwe-ciphertext-like</td></tr></tbody></table><h3 id=cgginand-heircgginandop><code>cggi.nand</code> (heir::cggi::NandOp)</h3><p><em>Logical NAND of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.nand` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggineq-heircggineqop><code>cggi.neq</code> (heir::cggi::NeqOp)</h3><p><em>High level operation to check inequality of two ciphertexts. Note this operations to mirror the TFHE-rs implmementation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.neq` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or A ciphertext type</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=cgginor-heircgginorop><code>cggi.nor</code> (heir::cggi::NorOp)</h3><p><em>Logical NOR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.nor` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cgginot-heircgginotop><code>cggi.not</code> (heir::cggi::NotOp)</h3><p><em>Logical NOT of two ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.not` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Involution</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggior-heircggiorop><code>cggi.or</code> (heir::cggi::OrOp)</h3><p><em>Logical OR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.or` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggipacked_lut3-heircggipackedlut3op><code>cggi.packed_lut3</code> (heir::cggi::PackedLut3Op)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.packed_lut3` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookup_tables</code></td><td>::mlir::ArrayAttr</td><td>Array of integers</td></tr></table><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>b</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>c</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggipacked_gates-heircggipackedop><code>cggi.packed_gates</code> (heir::cggi::PackedOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.packed_gates` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Operation to where different Boolean gates are executed pairwise between elements of two ciphertext arrays.</p><p>For example,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> cggi<span style=color:#000;font-weight:700>.</span>packed_gates <span style=color:#000>%a</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%b</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>gates =</span> <span style=color:#000>#cggi.cggi_gate</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;and&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;xor&#34;</span><span style=color:#000;font-weight:700>&gt;}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>2x</span><span style=color:#000;font-weight:700>!</span>lwe<span style=color:#000;font-weight:700>.</span>lwe_ciphertext<span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>applies an &ldquo;and&rdquo; gate to the first elements of %a and %b and an xor gate to the
second elements.</p><p>Mapping is defined in the BooleanGates.td file.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>gates</code></td><td>::mlir::heir::cggi::CGGIBoolGatesAttr</td><td>An attribute containing an array of strings to store bool gates</td></tr></table><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggiprogrammable_bootstrap-heircggiprogrammablebootstrapop><code>cggi.programmable_bootstrap</code> (heir::cggi::ProgrammableBootstrapOp)</h3><p><em>Programmable Bootstrap with a given lookup table.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.programmable_bootstrap` operands attr-dict `:` qualified(type($output))
</code></pre><p>An op representing a programmable bootstrap applied to an LWE ciphertext.</p><p>This operation evaluates a univariate function homomorphically on the
ciphertext by selecting the correct value from a lookup table. The bit size
of the lookup table integer attribute should be equal to the plaintext space
size. For example, if there ciphertext can hold 3 plaintext message bits,
then the lookup table must be represented at most by an integer with 8 bits.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookup_table</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggisshl-heircggiscalarshiftleftop><code>cggi.sshl</code> (heir::cggi::ScalarShiftLeftOp)</h3><p><em>Arithmetic shift to left of a ciphertext by an integer. Note this operations to mirror the TFHE-rs implmementation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.sshl` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>shiftAmount</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggisshr-heircggiscalarshiftrightop><code>cggi.sshr</code> (heir::cggi::ScalarShiftRightOp)</h3><p><em>Arithmetic shift to the right of a ciphertext by an integer. Note this operations to mirror the TFHE-rs implmementation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.sshr` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>shiftAmount</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggicmux-heircggiselectop><code>cggi.cmux</code> (heir::cggi::SelectOp)</h3><p><em>Multiplexer operations, the <code>select</code> ciphertext will return the <code>trueCtxt</code>
if in contains a 1. In the other case, it will will return the <code>falseCtxt</code>.
Note this operations to mirror the TFHE-rs implmementation."</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.cmux` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>select</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>trueCtxt</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>falseCtxt</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggiselector_lut_lincomb-heircggiselectorlutlincombop><code>cggi.selector_lut_lincomb</code> (heir::cggi::SelectorLutLinCombOp)</h3><p><em>A multi-value version of lut_lincomb</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.selector_lut_lincomb` operands attr-dict `:` functional-type($inputs, $outputs)
</code></pre><p>An op representing a lookup table applied to a shared input, which
is prepared via a static linear combination. This is equivalent to
<code>cggi.lut_lincomb</code>, but where the linear combination is given to a
single LUT, but producing an single n-bit output.</p><p>The linear combination will select a value for a lookup table with 2^n outputs
where each output is a n-bit number.
For instance, in the case of the default i4 ciphertext, a 16 element lookup table
will be used, and the output will be a i4 number.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#encoding</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.bit_field_encoding</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cleartext_start=</span><span style=color:#0000cf;font-weight:700>30</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>cleartext_bitwidth=</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#params</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.lwe_params</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cmod=</span><span style=color:#0000cf;font-weight:700>7917</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>dimension=</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>ciphertext =</span> <span style=color:#000;font-weight:700>!</span>lwe<span style=color:#000;font-weight:700>.</span>lwe_ciphertext<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>encoding =</span> <span style=color:#000>#encoding</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>lwe_params =</span> <span style=color:#000>#params</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> cggi<span style=color:#000;font-weight:700>.</span>selector_lut_lincomb <span style=color:#000>%c0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#f57900>coefficients =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;,</span>
</span></span><span style=display:flex><span>    <span style=color:#f57900>lookup_tables =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>9</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>11</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>12</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>13</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>14</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>15</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(!</span>ciphertext<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>ciphertext<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(!</span>ciphertext<span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr><tr><td><code>lookup_tables</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr></table><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggisub-heircggisubop><code>cggi.sub</code> (heir::cggi::SubOp)</h3><p><em>Subtraction of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.sub` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or A ciphertext type</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=cggixnor-heircggixnorop><code>cggi.xnor</code> (heir::cggi::XNorOp)</h3><p><em>Logical XNOR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.xnor` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=cggixor-heircggixorop><code>cggi.xor</code> (heir::cggi::XorOp)</h3><p><em>Logical XOR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.xor` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h2 id=cggi-additional-definitions>CGGI additional definitions</h2><h3 id=cggiboolgateenum>CGGIBoolGateEnum</h3><p><em>An enum attribute representing a CGGI boolean gate using u8 int</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>AND</td><td style=text-align:center><code>0</code></td><td>AND</td></tr><tr><td style=text-align:center>NAND</td><td style=text-align:center><code>1</code></td><td>NAND</td></tr><tr><td style=text-align:center>OR</td><td style=text-align:center><code>2</code></td><td>OR</td></tr><tr><td style=text-align:center>NOR</td><td style=text-align:center><code>3</code></td><td>NOR</td></tr><tr><td style=text-align:center>XOR</td><td style=text-align:center><code>4</code></td><td>XOR</td></tr><tr><td style=text-align:center>XNOR</td><td style=text-align:center><code>5</code></td><td>XNOR</td></tr><tr><td style=text-align:center>NOT</td><td style=text-align:center><code>6</code></td><td>NOT</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-818a3660f61ebf5859b5c98635beacc8>3 - CKKS</h1><h1 id=ckks-dialect>&lsquo;ckks&rsquo; Dialect</h1><p>The CKKS dialect defines the types and operations of the CKKS cryptosystem.</p><h2 id=ckks-attributes>CKKS attributes</h2><h3 id=schemeparamattr>SchemeParamAttr</h3><p><em>CKKS Scheme Parameters</em></p><p>Syntax:</p><pre tabindex=0><code>#ckks.scheme_param&lt;
  int,   # logN
  DenseI64ArrayAttr,   # Q
  DenseI64ArrayAttr,   # P
  int,   # logDefaultScale
  CKKSEncryptionType,   # encryptionType
  CKKSEncryptionTechnique   # encryptionTechnique
&gt;
</code></pre><p>This attribute is used for recording the scheme parameters for CKKS.</p><p>The attribute is a struct with the following fields:</p><ul><li><code>int</code> logN: The log of the degree of the polynomial modulus.</li><li><code>DenseI64ArrayAttr</code> Q: The array of primes in the ciphertext modulus.</li><li><code>DenseI64ArrayAttr</code> P: The array of primes in the special modulus, used for key switching.</li><li><code>int</code> logDefaultScale: The log of the default scale.</li></ul><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>logN</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>Q</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>P</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logDefaultScale</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>encryptionType</td><td style=text-align:center><code>CKKSEncryptionType</code></td><td></td></tr><tr><td style=text-align:center>encryptionTechnique</td><td style=text-align:center><code>CKKSEncryptionTechnique</code></td><td></td></tr></tbody></table><h2 id=ckks-ops>CKKS ops</h2><h3 id=ckksadd-heirckksaddop><code>ckks.add</code> (heir::ckks::AddOp)</h3><p><em>Addition operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.add` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckksadd_plain-heirckksaddplainop><code>ckks.add_plain</code> (heir::ckks::AddPlainOp)</h3><p><em>Addition operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.add_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AllCiphertextTypesMatch</code>, <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>IsCiphertextPlaintextOp</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckksbootstrap-heirckksbootstrapop><code>ckks.bootstrap</code> (heir::ckks::BootstrapOp)</h3><p><em>Bootstrap the ciphertext to reduce noise and refresh its parameters.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.bootstrap` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Bootstrapping is a technique used in FHE to reduce the noise in a ciphertext
and refresh its parameters, allowing for further computations on the ciphertext.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckksextract-heirckksextractop><code>ckks.extract</code> (heir::ckks::ExtractOp)</h3><p><em>Extract the i-th element of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.extract` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>While this operation is costly to compute in FHE, we represent it so we can
implement efficient lowerings and folders.</p><p>This op can be implemented as a plaintext multiplication with a one-hot
vector and a rotate into the zero-th index.</p><p>An extraction op&rsquo;s input ciphertext type is asserted to have an <code>underlying_type</code>
corresponding to a ranked tensor type, and this op&rsquo;s return type is
inferred to have the <code>underlying_type</code> corresponding to the element type of
that tensor type.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>offset</code></td><td>signless integer or index</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckkslevel_reduce-heirckkslevelreduceop><code>ckks.level_reduce</code> (heir::ckks::LevelReduceOp)</h3><p><em>Lower the modulus level of the ciphertext via dropping RNS limbs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.level_reduce` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>levelToDrop</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckksmul-heirckksmulop><code>ckks.mul</code> (heir::ckks::MulOp)</h3><p><em>Multiplication operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.mul` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckksmul_plain-heirckksmulplainop><code>ckks.mul_plain</code> (heir::ckks::MulPlainOp)</h3><p><em>Multiplication operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.mul_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>IsCiphertextPlaintextOp</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckksnegate-heirckksnegateop><code>ckks.negate</code> (heir::ckks::NegateOp)</h3><p><em>Negate the coefficients of the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.negate` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Involution</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckksrelinearize-heirckksrelinearizeop><code>ckks.relinearize</code> (heir::ckks::RelinearizeOp)</h3><p><em>Relinearize the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.relinearize` $input (`,` $keySwitchingKey^)? attr-dict `:` functional-type(operands, results)
</code></pre><p>This op takes integer array attributes <code>from_basis</code> and <code>to_basis</code> that are
used to indicate the key basis from which and to which the ciphertext is
encrypted against. A ciphertext is canonically encrypted against key basis
<code>(1, s)</code>. After a multiplication, its size will increase and the basis will be
<code>(1, s, s^2)</code>. The array that represents the key basis is constructed by
listing the powers of <code>s</code> at each position of the array. For example, <code>(1, s, s^2)</code> corresponds to <code>[0, 1, 2]</code>, while <code>(1, s^2)</code> corresponds to <code>[0, 2]</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>SameOperandsAndResultRings</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ElementwiseByOperandOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>from_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>to_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>keySwitchingKey</code></td><td>ranked tensor of lwe-ciphertext-like values</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckksrescale-heirckksrescaleop><code>ckks.rescale</code> (heir::ckks::RescaleOp)</h3><p><em>Rescales the ciphertext, which is the CKKS version of modulus switching in BGV/BFV.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.rescale` operands attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>to_ring</code></td><td>::mlir::heir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckksrotate-heirckksrotateop><code>ckks.rotate</code> (heir::ckks::RotateOp)</h3><p><em>Rotate the coefficients of the ciphertext using a Galois automorphism.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.rotate` operands attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckkssub-heirckkssubop><code>ckks.sub</code> (heir::ckks::SubOp)</h3><p><em>Subtraction operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.sub` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=ckkssub_plain-heirckkssubplainop><code>ckks.sub_plain</code> (heir::ckks::SubPlainOp)</h3><p><em>Subtraction operation between ciphertext-plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ckks.sub_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AllCiphertextTypesMatch</code>, <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>IsCiphertextPlaintextOp</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>lwe-plaintext-or-ciphertext-like</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h2 id=ckks-additional-definitions>CKKS additional definitions</h2><h3 id=ckksencryptiontechnique>CKKSEncryptionTechnique</h3><p><em>An enum attribute representing an encryption technique</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>standard</td><td style=text-align:center><code>0</code></td><td>standard</td></tr><tr><td style=text-align:center>extended</td><td style=text-align:center><code>1</code></td><td>extended</td></tr></tbody></table><h3 id=ckksencryptiontype>CKKSEncryptionType</h3><p><em>An enum attribute representing an encryption method</em></p><h4 id=cases-1>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>pk</td><td style=text-align:center><code>0</code></td><td>pk</td></tr><tr><td style=text-align:center>sk</td><td style=text-align:center><code>1</code></td><td>sk</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-80cc312dd83f43a069330083f04eb4f2>4 - Comb</h1><h1 id=comb-dialect>&lsquo;comb&rsquo; Dialect</h1><p><em>Types and operations for comb dialect</em></p><p>This dialect defines the <code>comb</code> dialect, which is intended to be a generic
representation of combinational logic outside of a particular use-case.</p><h2 id=operations>Operations</h2><h3 id=combadd-heircombaddop><code>comb.add</code> (heir::comb::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comband-heircombandop><code>comb.and</code> (heir::comb::AndOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combconcat-heircombconcatop><code>comb.concat</code> (heir::comb::ConcatOp)</h3><p><em>Concatenate a variadic list of operands together.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
</code></pre><p>See the comb rationale document for details on operand ordering.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combextract-heircombextractop><code>comb.extract</code> (heir::comb::ExtractOp)</h3><p><em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combicmp-heircombicmpop><code>comb.icmp</code> (heir::comb::ICmpOp)</h3><p><em>Compare two integer values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre tabindex=0><code>    %r = comb.icmp eq %a, %b : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::heir::comb::ICmpPredicateAttr</td><td>hw.icmp comparison predicate</td></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combinv-heircombinvop><code>comb.inv</code> (heir::comb::InvOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comblut-heircomblutop><code>comb.lut</code> (heir::comb::LUTOp)</h3><p><em>Return an integer based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.lut` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation is similar to <code>truth_table</code>, but it allows for an integer output instead of a boolean.
Requers an vector of integers as the lookup table, where each integer represents the output for a specific combination of inputs.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr><tr><td><code>lookupTable</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 8-bit signless integer</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8-bit signless integer</td></tr></tbody></table><h3 id=combmul-heircombmulop><code>comb.mul</code> (heir::comb::MulOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmux-heircombmuxop><code>comb.mux</code> (heir::comb::MuxOp)</h3><p><em>Return one or the other operand depending on a selector bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))
</code></pre><pre tabindex=0><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=combnand-heircombnandop><code>comb.nand</code> (heir::comb::NandOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combnor-heircombnorop><code>comb.nor</code> (heir::comb::NorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combor-heircomborop><code>comb.or</code> (heir::comb::OrOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combparity-heircombparityop><code>comb.parity</code> (heir::comb::ParityOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combreplicate-heircombreplicateop><code>comb.replicate</code> (heir::comb::ReplicateOp)</h3><p><em>Concatenate the operand a constant number of times</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combtruth_table-heircombtruthtableop><code>comb.truth_table</code> (heir::comb::TruthTableOp)</h3><p><em>Return a true/false based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.truth_table` $inputs `-&gt;` $lookupTable attr-dict
</code></pre><pre tabindex=0><code>  %a = ... : i1
  %b = ... : i1
  %0 = comb.truth_table %a, %b -&gt; 6 : ui4
</code></pre><p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -> LSB from left
to right and the offset into <code>lookupTable</code> is computed from them. The
integer containing the truth table value&rsquo;s LSB is the output for the input
&ldquo;all false&rdquo;, and the MSB is the output for the input &ldquo;all true&rdquo;.</p><p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &lsquo;x&rsquo; &ndash; it should be the well-known result.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookupTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combxnor-heircombxnorop><code>comb.xnor</code> (heir::comb::XNorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combxor-heircombxorop><code>comb.xor</code> (heir::comb::XorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h2 id=enums>Enums</h2><h3 id=icmppredicate>ICmpPredicate</h3><p><em>Hw.icmp comparison predicate</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>eq</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>ne</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>slt</td><td style=text-align:center><code>2</code></td><td>slt</td></tr><tr><td style=text-align:center>sle</td><td style=text-align:center><code>3</code></td><td>sle</td></tr><tr><td style=text-align:center>sgt</td><td style=text-align:center><code>4</code></td><td>sgt</td></tr><tr><td style=text-align:center>sge</td><td style=text-align:center><code>5</code></td><td>sge</td></tr><tr><td style=text-align:center>ult</td><td style=text-align:center><code>6</code></td><td>ult</td></tr><tr><td style=text-align:center>ule</td><td style=text-align:center><code>7</code></td><td>ule</td></tr><tr><td style=text-align:center>ugt</td><td style=text-align:center><code>8</code></td><td>ugt</td></tr><tr><td style=text-align:center>uge</td><td style=text-align:center><code>9</code></td><td>uge</td></tr><tr><td style=text-align:center>ceq</td><td style=text-align:center><code>10</code></td><td>ceq</td></tr><tr><td style=text-align:center>cne</td><td style=text-align:center><code>11</code></td><td>cne</td></tr><tr><td style=text-align:center>weq</td><td style=text-align:center><code>12</code></td><td>weq</td></tr><tr><td style=text-align:center>wne</td><td style=text-align:center><code>13</code></td><td>wne</td></tr></tbody></table><h2 id=comb-types>Comb types</h2><h3 id=bfloat16type>BFloat16Type</h3><p><em>Bfloat16 floating-point type</em></p><h3 id=complextype>ComplexType</h3><p><em>Complex number with a parameterized element type</em></p><p>Syntax:</p><pre tabindex=0><code>complex-type ::= `complex` `&lt;` type `&gt;`
</code></pre><p>The value of <code>complex</code> type represents a complex number with a parameterized
element type, which is composed of a real and imaginary value of that
element type. The element must be a floating point or integer scalar type.</p><h4 id=example>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>complex<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>complex<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=float4e2m1fntype>Float4E2M1FNType</h3><p><em>4-bit floating point with 2-bit exponent and 1-bit mantissa</em></p><p>An 4-bit floating point type with 1 sign bit, 2 bits exponent and 1 bit
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E2M1</li><li>exponent bias: 1</li><li>infinities: Not supported</li><li>NaNs: Not supported</li><li>denormals when exponent is 0</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float6e2m3fntype>Float6E2M3FNType</h3><p><em>6-bit floating point with 2-bit exponent and 3-bit mantissa</em></p><p>An 6-bit floating point type with 1 sign bit, 2 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E2M3</li><li>exponent bias: 1</li><li>infinities: Not supported</li><li>NaNs: Not supported</li><li>denormals when exponent is 0</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float6e3m2fntype>Float6E3M2FNType</h3><p><em>6-bit floating point with 3-bit exponent and 2-bit mantissa</em></p><p>An 6-bit floating point type with 1 sign bit, 3 bits exponent and 2 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E3M2</li><li>exponent bias: 3</li><li>infinities: Not supported</li><li>NaNs: Not supported</li><li>denormals when exponent is 0</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float8e3m4type>Float8E3M4Type</h3><p><em>8-bit floating point with 3 bits exponent and 4 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 3 bits exponent and 4 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E3M4</li><li>exponent bias: 3</li><li>infinities: supported with exponent set to all 1s and mantissa 0s</li><li>NaNs: supported with exponent bits set to all 1s and mantissa values of
{0,1}⁴ except S.111.0000</li><li>denormals when exponent is 0</li></ul><h3 id=float8e4m3type>Float8E4M3Type</h3><p><em>8-bit floating point with 3 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 7</li><li>infinities: supported with exponent set to all 1s and mantissa 0s</li><li>NaNs: supported with exponent bits set to all 1s and mantissa of
(001, 010, 011, 100, 101, 110, 111)</li><li>denormals when exponent is 0</li></ul><h3 id=float8e4m3b11fnuztype>Float8E4M3B11FNUZType</h3><p><em>8-bit floating point with 3 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values,
no negative zero, and only one NaN representation. This type has the
following characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 11</li><li>infinities: Not supported</li><li>NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s</li><li>denormals when exponent is 0</li></ul><p>Related to: <a href=https://dl.acm.org/doi/10.5555/3454287.3454728>https://dl.acm.org/doi/10.5555/3454287.3454728</a></p><h3 id=float8e4m3fntype>Float8E4M3FNType</h3><p><em>8-bit floating point with 3 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values
and only two NaN representations. This type has the following
characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 7</li><li>infinities: Not supported</li><li>NaNs: supported with exponent bits and mantissa bits set to all 1s</li><li>denormals when exponent is 0</li></ul><p>Described in: <a href=https://arxiv.org/abs/2209.05433>https://arxiv.org/abs/2209.05433</a></p><h3 id=float8e4m3fnuztype>Float8E4M3FNUZType</h3><p><em>8-bit floating point with 3 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values,
no negative zero, and only one NaN representation. This type has the
following characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 8</li><li>infinities: Not supported</li><li>NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s</li><li>denormals when exponent is 0</li></ul><p>Described in: <a href=https://arxiv.org/abs/2209.05433>https://arxiv.org/abs/2209.05433</a></p><h3 id=float8e5m2type>Float8E5M2Type</h3><p><em>8-bit floating point with 2 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 5 bits exponent and 2 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E5M2</li><li>exponent bias: 15</li><li>infinities: supported with exponent set to all 1s and mantissa 0s</li><li>NaNs: supported with exponent bits set to all 1s and mantissa of
(01, 10, or 11)</li><li>denormals when exponent is 0</li></ul><p>Described in: <a href=https://arxiv.org/abs/2209.05433>https://arxiv.org/abs/2209.05433</a></p><h3 id=float8e5m2fnuztype>Float8E5M2FNUZType</h3><p><em>8-bit floating point with 2 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 5 bits exponent and 2 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values,
no negative zero, and only one NaN representation. This type has the
following characteristics:</p><ul><li>bit encoding: S1E5M2</li><li>exponent bias: 16</li><li>infinities: Not supported</li><li>NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s</li><li>denormals when exponent is 0</li></ul><p>Described in: <a href=https://arxiv.org/abs/2206.02915>https://arxiv.org/abs/2206.02915</a></p><h3 id=float8e8m0fnutype>Float8E8M0FNUType</h3><p><em>8-bit floating point with 8-bit exponent, no mantissa or sign</em></p><p>An 8-bit floating point type with no sign bit, 8 bits exponent and no
mantissa. This is not a standard type as defined by IEEE-754; it is intended
to be used for representing scaling factors, so it cannot represent zeros
and negative numbers. The values it can represent are powers of two in the
range [-127,127] and NaN.</p><ul><li>bit encoding: S0E8M0</li><li>exponent bias: 127</li><li>infinities: Not supported</li><li>NaNs: Supported with all bits set to 1</li><li>denormals: Not supported</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float16type>Float16Type</h3><p><em>16-bit floating-point type</em></p><h3 id=float32type>Float32Type</h3><p><em>32-bit floating-point type</em></p><h3 id=float64type>Float64Type</h3><p><em>64-bit floating-point type</em></p><h3 id=float80type>Float80Type</h3><p><em>80-bit floating-point type</em></p><h3 id=float128type>Float128Type</h3><p><em>128-bit floating-point type</em></p><h3 id=floattf32type>FloatTF32Type</h3><p><em>TF32 floating-point type</em></p><h3 id=functiontype>FunctionType</h3><p><em>Map from a list of inputs to a list of results</em></p><p>Syntax:</p><pre tabindex=0><code>// Function types may have multiple results.
function-result-type ::= type-list-parens | non-function-type
function-type ::= type-list-parens `-&gt;` function-result-type
</code></pre><p>The function type can be thought of as a function signature. It consists of
a list of formal parameter types and a list of formal result types.</p><h4 id=example-1>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@add_one</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i64</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>inputs</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr><tr><td style=text-align:center>results</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=graphtype>GraphType</h3><p><em>Map from a list of inputs to a list of results</em></p><p>Syntax:</p><pre tabindex=0><code>// Function types may have multiple results.
function-result-type ::= type-list-parens | non-function-type
function-type ::= type-list-parens `-&gt;` function-result-type
</code></pre><p>The function type can be thought of as a function signature. It consists of
a list of formal parameter types and a list of formal result types.</p><h4 id=example-2>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@add_one</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i64</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>inputs</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr><tr><td style=text-align:center>results</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=indextype>IndexType</h3><p><em>Integer-like type with unknown platform-dependent bit width</em></p><p>Syntax:</p><pre tabindex=0><code>// Target word-sized integer.
index-type ::= `index`
</code></pre><p>The index type is a signless integer whose size is equal to the natural
machine word of the target ( <a href=../../Rationale/Rationale/#integer-signedness-semantics>rationale</a> )
and is used by the affine constructs in MLIR.</p><p><strong>Rationale:</strong> integers of platform-specific bit widths are practical to
express sizes, dimensionalities and subscripts.</p><h3 id=integertype>IntegerType</h3><p><em>Integer type with arbitrary precision up to a fixed limit</em></p><p>Syntax:</p><pre tabindex=0><code>// Sized integers like i1, i4, i8, i16, i32.
signed-integer-type ::= `si` [1-9][0-9]*
unsigned-integer-type ::= `ui` [1-9][0-9]*
signless-integer-type ::= `i` [1-9][0-9]*
integer-type ::= signed-integer-type |
                 unsigned-integer-type |
                 signless-integer-type
</code></pre><p>Integer types have a designated bit width and may optionally have signedness
semantics.</p><p><strong>Rationale:</strong> low precision integers (like <code>i2</code>, <code>i4</code> etc) are useful for
low-precision inference chips, and arbitrary precision integers are useful
for hardware synthesis (where a 13 bit multiplier is a lot cheaper/smaller
than a 16 bit one).</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>width</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>signedness</td><td style=text-align:center><code>SignednessSemantics</code></td><td></td></tr></tbody></table><h3 id=memreftype>MemRefType</h3><p><em>Shaped reference to a region of memory</em></p><p>Syntax:</p><pre tabindex=0><code>layout-specification ::= attribute-value
memory-space ::= attribute-value
memref-type ::= `memref` `&lt;` dimension-list-ranked type
                (`,` layout-specification)? (`,` memory-space)? `&gt;`
</code></pre><p>A <code>memref</code> type is a reference to a region of memory (similar to a buffer
pointer, but more powerful). The buffer pointed to by a memref can be
allocated, aliased and deallocated. A memref can be used to read and write
data from/to the memory region which it references. Memref types use the
same shape specifier as tensor types. Note that <code>memref&lt;f32></code>,
<code>memref&lt;0 x f32></code>, <code>memref&lt;1 x 0 x f32></code>, and <code>memref&lt;0 x 1 x f32></code> are all
different types.</p><p>A <code>memref</code> is allowed to have an unknown rank (e.g. <code>memref&lt;*xf32></code>). The
purpose of unranked memrefs is to allow external library functions to
receive memref arguments of any rank without versioning the functions based
on the rank. Other uses of this type are disallowed or will have undefined
behavior.</p><p>Are accepted as elements:</p><ul><li>built-in integer types;</li><li>built-in index type;</li><li>built-in floating point types;</li><li>built-in vector types with elements of the above types;</li><li>another memref type;</li><li>any other type implementing <code>MemRefElementTypeInterface</code>.</li></ul><h5 id=layout>Layout</h5><p>A memref may optionally have a layout that indicates how indices are
transformed from the multi-dimensional form into a linear address. The
layout must avoid internal aliasing, i.e., two distinct tuples of
<em>in-bounds</em> indices must be pointing to different elements in memory. The
layout is an attribute that implements <code>MemRefLayoutAttrInterface</code>. The
bulitin dialect offers two kinds of layouts: strided and affine map, each
of which is available as an attribute. Other attributes may be used to
represent the layout as long as they can be converted to a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a> and implement the required
interface. Users of memref are expected to fallback to the affine
representation when handling unknown memref layouts. Multi-dimensional
affine forms are interpreted in <em>row-major</em> fashion.</p><p>In absence of an explicit layout, a memref is considered to have a
multi-dimensional identity affine map layout. Identity layout maps do not
contribute to the MemRef type identification and are discarded on
construction. That is, a type with an explicit identity map is
<code>memref&lt;?x?xf32, (i,j)->(i,j)></code> is strictly the same as the one without a
layout, <code>memref&lt;?x?xf32></code>.</p><h5 id=affine-map-layout>Affine Map Layout</h5><p>The layout may be represented directly as an affine map from the index space
to the storage space. For example, the following figure shows an index map
which maps a 2-dimensional index from a 2x2 index space to a 3x3 index
space, using symbols <code>S0</code> and <code>S1</code> as offsets.</p><p><img src=/includes/img/index-map.svg alt="Index Map Example"></p><p>Semi-affine maps are sufficiently flexible to represent a wide variety of
dense storage layouts, including row- and column-major and tiled:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// MxN matrix stored in row major layout in memory:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#layout_map_row_major</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span>i<span style=color:#000;font-weight:700>,</span> j<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>i<span style=color:#000;font-weight:700>,</span> j<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// MxN matrix stored in column major layout in memory:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#layout_map_col_major</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span>i<span style=color:#000;font-weight:700>,</span> j<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>j<span style=color:#000;font-weight:700>,</span> i<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// MxN matrix stored in a 2-d blocked/tiled layout with 64x64 tiles.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#layout_tiled</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span>i<span style=color:#000;font-weight:700>,</span> j<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>i floordiv <span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>,</span> j floordiv <span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>,</span> i mod <span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>,</span> j mod <span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><h5 id=strided-layout>Strided Layout</h5><p>Memref layout can be expressed using strides to encode the distance, in
number of elements, in (linear) memory between successive entries along a
particular dimension. For example, a row-major strided layout for
<code>memref&lt;2x3x4xf32></code> is <code>strided&lt;[12, 4, 1]></code>, where the last dimension is
contiguous as indicated by the unit stride and the remaining strides are
products of the sizes of faster-variying dimensions. Strided layout can also
express non-contiguity, e.g., <code>memref&lt;2x3, strided&lt;[6, 2]>></code> only accesses
even elements of the dense consecutive storage along the innermost
dimension.</p><p>The strided layout supports an optional <em>offset</em> that indicates the
distance, in the number of elements, between the beginning of the memref
and the first accessed element. When omitted, the offset is considered to
be zero. That is, <code>memref&lt;2, strided&lt;[2], offset: 0>></code> and
<code>memref&lt;2, strided&lt;[2]>></code> are strictly the same type.</p><p>Both offsets and strides may be <em>dynamic</em>, that is, unknown at compile time.
This is represented by using a question mark (<code>?</code>) instead of the value in
the textual form of the IR.</p><p>The strided layout converts into the following canonical one-dimensional
affine form through explicit linearization:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>...</span> dN<span style=color:#000;font-weight:700>)[</span>offset<span style=color:#000;font-weight:700>,</span> stride0<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>...</span> strideN<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>(</span>offset <span style=color:#a40000>+</span> d0 <span style=color:#000;font-weight:700>*</span> stride0 <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>...</span> dN <span style=color:#000;font-weight:700>*</span> strideN<span style=color:#000;font-weight:700>)&gt;</span>
</span></span></code></pre></div><p>Therefore, it is never subject to the implicit row-major layout
interpretation.</p><h5 id=codegen-of-unranked-memref>Codegen of Unranked Memref</h5><p>Using unranked memref in codegen besides the case mentioned above is highly
discouraged. Codegen is concerned with generating loop nests and specialized
instructions for high-performance, unranked memref is concerned with hiding
the rank and thus, the number of enclosing loops required to iterate over
the data. However, if there is a need to code-gen unranked memref, one
possible path is to cast into a static ranked type based on the dynamic
rank. Another possible path is to emit a single while loop conditioned on a
linear index and perform delinearization of the linear index to a dynamic
array containing the (unranked) indices. While this is possible, it is
expected to not be a good idea to perform this during codegen as the cost
of the translations is expected to be prohibitive and optimizations at this
level are not expected to be worthwhile. If expressiveness is the main
concern, irrespective of performance, passing unranked memrefs to an
external C++ library and implementing rank-agnostic logic there is expected
to be significantly simpler.</p><p>Unranked memrefs may provide expressiveness gains in the future and help
bridge the gap with unranked tensors. Unranked memrefs will not be expected
to be exposed to codegen but one may query the rank of an unranked memref
(a special op will be needed for this purpose) and perform a switch and cast
to a ranked memref as a prerequisite to codegen.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// With static ranks, we need a function for each possible argument type
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%A</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%B</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>call <span style=color:#000>@helper_2D</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%A</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;)-&gt;()</span>
</span></span><span style=display:flex><span>call <span style=color:#000>@helper_3D</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%B</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;)-&gt;()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// With unknown rank, the functions can be unified under one unranked type
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%A</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%B</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Remove rank info
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%A_u</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>memref</span>_cast <span style=color:#000>%A</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%B_u</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>memref</span>_cast <span style=color:#000>%B</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// call same function with dynamic ranks
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>call <span style=color:#000>@helper</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%A_u</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;)-&gt;()</span>
</span></span><span style=display:flex><span>call <span style=color:#000>@helper</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%B_u</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;)-&gt;()</span>
</span></span></code></pre></div><p>The core syntax and representation of a layout specification is a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a>. Additionally,
syntactic sugar is supported to make certain layout specifications more
intuitive to read. For the moment, a <code>memref</code> supports parsing a strided
form which is converted to a semi-affine map automatically.</p><p>The memory space of a memref is specified by a target-specific attribute.
It might be an integer value, string, dictionary or custom dialect attribute.
The empty memory space (attribute is None) is target specific.</p><p>The notionally dynamic value of a memref value includes the address of the
buffer allocated, as well as the symbols referred to by the shape, layout
map, and index maps.</p><p>Examples of memref static type</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Identity index/layout map
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#identity</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Column major layout.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#col_major</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>,</span> d2<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d2<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>,</span> d0<span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2-d tiled layout with tiles of size 128 x 256.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#tiled_2d_128x256</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0 div <span style=color:#0000cf;font-weight:700>128</span><span style=color:#000;font-weight:700>,</span> d1 div <span style=color:#0000cf;font-weight:700>256</span><span style=color:#000;font-weight:700>,</span> d0 mod <span style=color:#0000cf;font-weight:700>128</span><span style=color:#000;font-weight:700>,</span> d1 mod <span style=color:#0000cf;font-weight:700>256</span><span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A tiled data layout with non-constant tile sizes.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#tiled_dynamic</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)[</span>s0<span style=color:#000;font-weight:700>,</span> s1<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0 floordiv s0<span style=color:#000;font-weight:700>,</span> d1 floordiv s1<span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>                             d0 mod s0<span style=color:#000;font-weight:700>,</span> d1 mod s1<span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A layout that yields a padding on two at either end of the minor dimension.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#padded</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>(</span>d1 <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span> floordiv <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>(</span>d1 <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span> mod <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// The dimension list &#34;16x32&#34; defines the following 2D index space:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//   { (i, j) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 32 }
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#identity</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// The dimension list &#34;16x4x?&#34; defines the following 3D index space:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//   { (i, j, k) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 4, 0 &lt;= k &lt; N }
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// where N is a symbol which represents the runtime value of the size of
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// the third dimension.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// %N here binds to the size of the third dimension.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%A</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>(</span><span style=color:#000>%N</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x4x?x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#col_major</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2-d dynamic shaped memref that also has a dynamically sized tiled
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// layout. The memref index space is of size %M x %N, while %B1 and %B2
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// bind to the symbols s0, s1 respectively of the layout map #tiled_dynamic.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Data tiles of size %B1 x %B2 in the logical space will be stored
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// contiguously in memory. The allocation size will be
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// (%M ceildiv %B1) * %B1 * (%N ceildiv %B2) * %B2 f32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%T</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>(</span><span style=color:#000>%M</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%N</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>%B1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%B2</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>?x?x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#tiled_dynamic</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A memref that has a two-element padding at either end. The allocation
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// size will fit 16 * 64 float elements of data.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%P</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#padded</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Affine map with symbol &#39;s0&#39; used as offset for the first dimension.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#imapS</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>[</span>s0<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0 <span style=color:#a40000>+</span> s0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Allocate memref and bind the following symbols:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// &#39;%n&#39; is bound to the dynamic second dimension of the memref type.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// &#39;%o&#39; is bound to the symbol &#39;s0&#39; in the affine map of the memref type.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%n</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000>%o</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000>%A</span> <span style=color:#000;font-weight:700>=</span> alloc <span style=color:#000;font-weight:700>(</span><span style=color:#000>%n</span><span style=color:#000;font-weight:700>)[</span><span style=color:#000>%o</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x?x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#imapS</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>layout</td><td style=text-align:center><code>MemRefLayoutAttrInterface</code></td><td></td></tr><tr><td style=text-align:center>memorySpace</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=nonetype>NoneType</h3><p><em>A unit type</em></p><p>Syntax:</p><pre tabindex=0><code>none-type ::= `none`
</code></pre><p>NoneType is a unit type, i.e. a type with exactly one possible value, where
its value does not have a defined dynamic representation.</p><h4 id=example-3>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@none_type</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%none_val</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#4e9a06>&#34;foo.unknown_op&#34;</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>-&gt;</span> none
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h3 id=opaquetype>OpaqueType</h3><p><em>Type of a non-registered dialect</em></p><p>Syntax:</p><pre tabindex=0><code>opaque-type ::= `opaque` `&lt;` type `&gt;`
</code></pre><p>Opaque types represent types of non-registered dialects. These are types
represented in their raw string form, and can only usefully be tested for
type equality.</p><h4 id=example-4>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>opaque<span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;llvm&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;struct&lt;(i32, float)&gt;&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>opaque<span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;pdl&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;value&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>dialectNamespace</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>typeData</td><td style=text-align:center><code>::llvm::StringRef</code></td><td></td></tr></tbody></table><h3 id=rankedtensortype>RankedTensorType</h3><p><em>Multi-dimensional array with a fixed number of dimensions</em></p><p>Syntax:</p><pre tabindex=0><code>tensor-type ::= `tensor` `&lt;` dimension-list type (`,` encoding)? `&gt;`
dimension-list ::= (dimension `x`)*
dimension ::= `?` | decimal-literal
encoding ::= attribute-value
</code></pre><p>Values with tensor type represents aggregate N-dimensional data values, and
have a known element type and a fixed rank with a list of dimensions. Each
dimension may be a static non-negative decimal constant or be dynamically
determined (indicated by <code>?</code>).</p><p>The runtime representation of the MLIR tensor type is intentionally
abstracted - you cannot control layout or get a pointer to the data. For
low level buffer access, MLIR has a <a href=#memreftype><code>memref</code> type</a>. This
abstracted runtime representation holds both the tensor data values as well
as information about the (potentially dynamic) shape of the tensor. The
<a href=MemRef.md/#memrefdim-mlirmemrefdimop><code>dim</code> operation</a> returns the size of a
dimension from a value of tensor type.</p><p>The <code>encoding</code> attribute provides additional information on the tensor.
An empty attribute denotes a straightforward tensor without any specific
structure. But particular properties, like sparsity or other specific
characteristics of the data of the tensor can be encoded through this
attribute. The semantics are defined by a type and attribute interface
and must be respected by all passes that operate on tensor types.
TODO: provide this interface, and document it further.</p><p>Note: hexadecimal integer literals are not allowed in tensor type
declarations to avoid confusion between <code>0xf32</code> and <code>0 x f32</code>. Zero sizes
are allowed in tensors and treated as other sizes, e.g.,
<code>tensor&lt;0 x 1 x i32></code> and <code>tensor&lt;1 x 0 x i32></code> are different types. Since
zero sizes are not allowed in some other types, such tensors should be
optimized away before lowering tensors to vectors.</p><h4 id=example-5>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Known rank but unknown dimensions.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Partially known dimensions.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>13 x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Full static shape.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>17 x</span> <span style=color:#0000cf;font-weight:700>4 x</span> <span style=color:#0000cf;font-weight:700>13 x</span> <span style=color:#0000cf;font-weight:700>4 x</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Tensor with rank zero. Represents a scalar.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Zero-element dimensions are allowed.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>x</span> <span style=color:#0000cf;font-weight:700>42 x</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Zero-element tensor of f32 type (hexadecimal literals not allowed here).
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>0xf32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Tensor with an encoding attribute (where #ENCODING is a named alias).
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>?x?x</span><span style=color:#204a87;font-weight:700>f64</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#ENCODING</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=tupletype>TupleType</h3><p><em>Fixed-sized collection of other types</em></p><p>Syntax:</p><pre tabindex=0><code>tuple-type ::= `tuple` `&lt;` (type ( `,` type)*)? `&gt;`
</code></pre><p>The value of <code>tuple</code> type represents a fixed-size collection of elements,
where each element may be of a different type.</p><p><strong>Rationale:</strong> Though this type is first class in the type system, MLIR
provides no standard operations for operating on <code>tuple</code> types
(<a href=../../Rationale/Rationale/#tuple-types>rationale</a>).</p><h4 id=example-6>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Empty tuple.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>tuple<span style=color:#000;font-weight:700>&lt;&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Single element
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>tuple<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Many elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>tuple<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i1</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>i5</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>types</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=unrankedmemreftype>UnrankedMemRefType</h3><p><em>Shaped reference, with unknown rank, to a region of memory</em></p><p>Syntax:</p><pre tabindex=0><code>unranked-memref-type ::= `memref` `&lt;*x` type (`,` memory-space)? `&gt;`
memory-space ::= attribute-value
</code></pre><p>A <code>memref</code> type with an unknown rank (e.g. <code>memref&lt;*xf32></code>). The purpose of
unranked memrefs is to allow external library functions to receive memref
arguments of any rank without versioning the functions based on the rank.
Other uses of this type are disallowed or will have undefined behavior.</p><p>See <a href=#memreftype>MemRefType</a> for more information on
memref types.</p><h4 id=examples>Examples:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// An unranked memref with a memory space of 10.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>memorySpace</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=unrankedtensortype>UnrankedTensorType</h3><p><em>Multi-dimensional array with unknown dimensions</em></p><p>Syntax:</p><pre tabindex=0><code>tensor-type ::= `tensor` `&lt;` `*` `x` type `&gt;`
</code></pre><p>An unranked tensor is a type of tensor in which the set of dimensions have
unknown rank. See <a href=#rankedtensortype>RankedTensorType</a>
for more information on tensor types.</p><h4 id=examples-1>Examples:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=vectortype>VectorType</h3><p><em>Multi-dimensional SIMD vector type</em></p><p>Syntax:</p><pre tabindex=0><code>vector-type ::= `vector` `&lt;` vector-dim-list vector-element-type `&gt;`
vector-element-type ::= float-type | integer-type | index-type
vector-dim-list := (static-dim-list `x`)?
static-dim-list ::= static-dim (`x` static-dim)*
static-dim ::= (decimal-literal | `[` decimal-literal `]`)
</code></pre><p>The vector type represents a SIMD style vector used by target-specific
operation sets like AVX or SVE. While the most common use is for 1D
vectors (e.g. vector&lt;16 x f32>) we also support multidimensional registers
on targets that support them (like TPUs). The dimensions of a vector type
can be fixed-length, scalable, or a combination of the two. The scalable
dimensions in a vector are indicated between square brackets ([ ]).</p><p>Vector shapes must be positive decimal integers. 0D vectors are allowed by
omitting the dimension: <code>vector&lt;f32></code>.</p><p>Note: hexadecimal integer literals are not allowed in vector type
declarations, <code>vector&lt;0x42xi32></code> is invalid because it is interpreted as a
2D vector with shape <code>(0, 42)</code> and zero shapes are not allowed.</p><h4 id=examples-2>Examples:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2D fixed-length vector of 3x42 i32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>3x42x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 1D scalable-length vector that contains a multiple of 4 f32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;[</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>]</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2D scalable-length vector that contains a multiple of 2x8 f32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;[</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>]x[</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>]</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2D mixed fixed/scalable vector that contains 4 scalable vectors of 4 f32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>4x</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>]</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 3D mixed fixed/scalable vector in which only the inner dimension is
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// scalable.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>2x</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>]</span>x8xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td>VectorElementTypeInterface instance</td></tr><tr><td style=text-align:center>scalableDims</td><td style=text-align:center><code>::llvm::ArrayRef&lt;bool></code></td><td></td></tr></tbody></table><h2 id=comb-ops>Comb ops</h2><h3 id=combadd-heircombaddop-1><code>comb.add</code> (heir::comb::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comband-heircombandop-1><code>comb.and</code> (heir::comb::AndOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combconcat-heircombconcatop-1><code>comb.concat</code> (heir::comb::ConcatOp)</h3><p><em>Concatenate a variadic list of operands together.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
</code></pre><p>See the comb rationale document for details on operand ordering.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combextract-heircombextractop-1><code>comb.extract</code> (heir::comb::ExtractOp)</h3><p><em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combicmp-heircombicmpop-1><code>comb.icmp</code> (heir::comb::ICmpOp)</h3><p><em>Compare two integer values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre tabindex=0><code>    %r = comb.icmp eq %a, %b : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-18>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::heir::comb::ICmpPredicateAttr</td><td>hw.icmp comparison predicate</td></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combinv-heircombinvop-1><code>comb.inv</code> (heir::comb::InvOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-19>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comblut-heircomblutop-1><code>comb.lut</code> (heir::comb::LUTOp)</h3><p><em>Return an integer based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.lut` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation is similar to <code>truth_table</code>, but it allows for an integer output instead of a boolean.
Requers an vector of integers as the lookup table, where each integer represents the output for a specific combination of inputs.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-20>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr><tr><td><code>lookupTable</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr></table><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 8-bit signless integer</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8-bit signless integer</td></tr></tbody></table><h3 id=combmul-heircombmulop-1><code>comb.mul</code> (heir::comb::MulOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmux-heircombmuxop-1><code>comb.mux</code> (heir::comb::MuxOp)</h3><p><em>Return one or the other operand depending on a selector bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))
</code></pre><pre tabindex=0><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=combnand-heircombnandop-1><code>comb.nand</code> (heir::comb::NandOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-23>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combnor-heircombnorop-1><code>comb.nor</code> (heir::comb::NorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-24>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combor-heircomborop-1><code>comb.or</code> (heir::comb::OrOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-25>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-28>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combparity-heircombparityop-1><code>comb.parity</code> (heir::comb::ParityOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-26>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combreplicate-heircombreplicateop-1><code>comb.replicate</code> (heir::comb::ReplicateOp)</h3><p><em>Concatenate the operand a constant number of times</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combtruth_table-heircombtruthtableop-1><code>comb.truth_table</code> (heir::comb::TruthTableOp)</h3><p><em>Return a true/false based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.truth_table` $inputs `-&gt;` $lookupTable attr-dict
</code></pre><pre tabindex=0><code>  %a = ... : i1
  %b = ... : i1
  %0 = comb.truth_table %a, %b -&gt; 6 : ui4
</code></pre><p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -> LSB from left
to right and the offset into <code>lookupTable</code> is computed from them. The
integer containing the truth table value&rsquo;s LSB is the output for the input
&ldquo;all false&rdquo;, and the MSB is the output for the input &ldquo;all true&rdquo;.</p><p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &lsquo;x&rsquo; &ndash; it should be the well-known result.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-27>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookupTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combxnor-heircombxnorop-1><code>comb.xnor</code> (heir::comb::XNorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-28>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-32>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-32>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combxor-heircombxorop-1><code>comb.xor</code> (heir::comb::XorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-29>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-33>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-33>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h2 id=comb-additional-definitions>Comb additional definitions</h2><h3 id=icmppredicate-1>ICmpPredicate</h3><p><em>Hw.icmp comparison predicate</em></p><h4 id=cases-1>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>eq</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>ne</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>slt</td><td style=text-align:center><code>2</code></td><td>slt</td></tr><tr><td style=text-align:center>sle</td><td style=text-align:center><code>3</code></td><td>sle</td></tr><tr><td style=text-align:center>sgt</td><td style=text-align:center><code>4</code></td><td>sgt</td></tr><tr><td style=text-align:center>sge</td><td style=text-align:center><code>5</code></td><td>sge</td></tr><tr><td style=text-align:center>ult</td><td style=text-align:center><code>6</code></td><td>ult</td></tr><tr><td style=text-align:center>ule</td><td style=text-align:center><code>7</code></td><td>ule</td></tr><tr><td style=text-align:center>ugt</td><td style=text-align:center><code>8</code></td><td>ugt</td></tr><tr><td style=text-align:center>uge</td><td style=text-align:center><code>9</code></td><td>uge</td></tr><tr><td style=text-align:center>ceq</td><td style=text-align:center><code>10</code></td><td>ceq</td></tr><tr><td style=text-align:center>cne</td><td style=text-align:center><code>11</code></td><td>cne</td></tr><tr><td style=text-align:center>weq</td><td style=text-align:center><code>12</code></td><td>weq</td></tr><tr><td style=text-align:center>wne</td><td style=text-align:center><code>13</code></td><td>wne</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-df73b993320a0b803398dca1b5f7c3cd>5 - Jaxite</h1><h1 id=jaxite-dialect>&lsquo;jaxite&rsquo; Dialect</h1><p>The <code>jaxite</code> dialect is an exit dialect for generating py code against the jaxite library API,
using the jaxite parameters and encoding scheme.</p><p>See <a href=https://github.com/google/jaxite>https://github.com/google/jaxite</a></p><h2 id=jaxite-types>Jaxite types</h2><h3 id=paramstype>ParamsType</h3><p><em>The jaxite security params required to perform homomorphic operations.</em></p><p>Syntax: <code>!jaxite.params</code></p><h3 id=pmaplut3tupletype>PmapLut3TupleType</h3><p><em>A tuple of pmap_lut3 args.</em></p><p>Syntax: <code>!jaxite.pmap_lut3_tuple</code></p><h3 id=serverkeysettype>ServerKeySetType</h3><p><em>The jaxite server key set required to perform homomorphic operations.</em></p><p>Syntax: <code>!jaxite.server_key_set</code></p><h2 id=jaxite-ops>Jaxite ops</h2><h3 id=jaxiteconstant-heirjaxiteconstantop><code>jaxite.constant</code> (heir::jaxite::ConstantOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `jaxite.constant` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>params</code></td><td>The jaxite security params required to perform homomorphic operations.</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=jaxitelut3_args-heirjaxitelut3argsop><code>jaxite.lut3_args</code> (heir::jaxite::Lut3ArgsOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `jaxite.lut3_args` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The operation computed by this function is generating tuples for pmap_lut3.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>b</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>c</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>truth_table</code></td><td>8-bit signless integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A tuple of pmap_lut3 args.</td></tr></tbody></table><h3 id=jaxitelut3-heirjaxitelut3op><code>jaxite.lut3</code> (heir::jaxite::Lut3Op)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `jaxite.lut3` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The operation computed by this function can be
interpreted as</p><p>truth_table &#187; {c, b, a}</p><p>where {c, b, a} is the unsigned 3-bit integer with bits c, b, a from most
significant bit to least-significant bit.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>b</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>c</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>truth_table</code></td><td>8-bit signless integer</td></tr><tr><td style=text-align:center><code>serverKeySet</code></td><td>The jaxite server key set required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>params</code></td><td>The jaxite security params required to perform homomorphic operations.</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=jaxitepmap_lut3-heirjaxitepmaplut3op><code>jaxite.pmap_lut3</code> (heir::jaxite::PmapLut3Op)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `jaxite.pmap_lut3` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The operation computed by this function is a bacthed Lut3Op.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lut3_args</code></td><td>pmap_lut3_tuples</td></tr><tr><td style=text-align:center><code>serverKeySet</code></td><td>The jaxite server key set required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>params</code></td><td>The jaxite security params required to perform homomorphic operations.</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-63d08712eb5ec0da1ca62003de70e7f1>6 - JaxiteWord</h1><h1 id=jaxiteword-dialect>&lsquo;jaxiteword&rsquo; Dialect</h1><p>The <code>jaxiteword</code> dialect is an exit dialect for generating py code against the jaxiteword library API,
using the jaxiteword parameters and encoding scheme.</p><p>See <a href=https://github.com/google/jaxite/jaxite_word>https://github.com/google/jaxite/jaxite_word</a></p><h2 id=jaxiteword-types>JaxiteWord types</h2><h3 id=ccparamstype>CCParamsType</h3><p><em>The CCParams required to create CryptoContext.</em></p><p>Syntax: <code>!jaxiteword.cc_params</code></p><h3 id=ciphertexttype>CiphertextType</h3><p>Syntax:</p><pre tabindex=0><code>!jaxiteword.ciphertext&lt;
  int,   # polys
  int,   # towers
  int   # degrees
&gt;
</code></pre><p>A ciphertext - a three dimensional array.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>polys</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>towers</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>degrees</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=cryptocontexttype>CryptoContextType</h3><p><em>The CryptoContext required to perform homomorphic operations in JaxiteWord.</em></p><p>Syntax: <code>!jaxiteword.crypto_context</code></p><h3 id=evalkeytype>EvalKeyType</h3><p><em>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in JaxiteWord.</em></p><p>Syntax: <code>!jaxiteword.eval_key</code></p><h3 id=moduluslisttype>ModulusListType</h3><p>Syntax:</p><pre tabindex=0><code>!jaxiteword.modulus_list&lt;
  ::llvm::ArrayRef&lt;::mlir::IntegerAttr&gt;   # modulus_list
&gt;
</code></pre><p>A list of modulus values.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>modulus_list</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::IntegerAttr></code></td><td></td></tr></tbody></table><h3 id=privatekeytype>PrivateKeyType</h3><p><em>The private key required to decrypt a ciphertext in JaxiteWord.</em></p><p>Syntax: <code>!jaxiteword.private_key</code></p><h3 id=publickeytype>PublicKeyType</h3><p><em>The public key required to encrypt plaintext in JaxiteWord.</em></p><p>Syntax: <code>!jaxiteword.public_key</code></p><h2 id=jaxiteword-ops>JaxiteWord ops</h2><h3 id=jaxitewordadd-heirjaxitewordaddop><code>jaxiteword.add</code> (heir::jaxiteword::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `jaxiteword.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The operation computed by this function is homomorphic addition.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value_a</code></td><td></td></tr><tr><td style=text-align:center><code>value_b</code></td><td></td></tr><tr><td style=text-align:center><code>modulus_list</code></td><td></td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=jaxitewordmake_ciphertext-heirjaxitewordmakeciphertextop><code>jaxiteword.make_ciphertext</code> (heir::jaxiteword::MakeCiphertextOp)</h3><p><em>Create a JaxiteWord ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `jaxiteword.make_ciphertext` $polys `,` $towers `,` $degrees attr-dict `:` type($ciphertext)
</code></pre><p>Creates a JaxiteWord ciphertext with the given dimensions.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>polys</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>towers</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>degrees</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertext</code></td><td></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-6857a323f6f4a36b66d9290a3b2c84fc>7 - Lattigo</h1><h1 id=lattigo-dialect>&rsquo;lattigo&rsquo; Dialect</h1><p>The <code>lattigo</code> dialect is an exit dialect for generating GO code against the Lattigo library API.</p><p>See <a href=https://github.com/tuneinsight/lattigo>https://github.com/tuneinsight/lattigo</a></p><h2 id=lattigo-attributes>Lattigo attributes</h2><h3 id=bgvparametersliteralattr>BGVParametersLiteralAttr</h3><p><em>Literal parameters for Lattigo BGV</em></p><p>Syntax:</p><pre tabindex=0><code>#lattigo.bgv.parameters_literal&lt;
  int,   # logN
  DenseI64ArrayAttr,   # Q
  DenseI64ArrayAttr,   # P
  DenseI32ArrayAttr,   # logQ
  DenseI32ArrayAttr,   # logP
  int64_t   # plaintextModulus
&gt;
</code></pre><p>This attribute represents the literal parameters for Lattigo BGV.</p><p>This is in accordance with <a href=https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/bgv#ParametersLiteral>https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/bgv#ParametersLiteral</a>
where some field are not present in the current implementation.</p><p>Users must set the polynomial degree (LogN) and the coefficient modulus,
by either setting the Q and P fields to the desired moduli chain,
or by setting the LogQ and LogP fields to the desired moduli sizes.</p><p>Note that for Lattigo, Q/P requires []uint64, where this attribute
only provides int64. We assume user should not select moduli so large
to consider the signedness issue.</p><p>Users must also specify the coefficient modulus in plaintext-space (T).
This modulus must be an NTT-friendly prime in the plaintext space:
it must be equal to 1 modulo 2n where n is the plaintext ring degree
(i.e., the plaintext space has n slots).</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>logN</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>Q</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>P</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logQ</td><td style=text-align:center><code>DenseI32ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logP</td><td style=text-align:center><code>DenseI32ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintextModulus</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=ckksparametersliteralattr>CKKSParametersLiteralAttr</h3><p><em>Literal parameters for Lattigo CKKS</em></p><p>Syntax:</p><pre tabindex=0><code>#lattigo.ckks.parameters_literal&lt;
  int,   # logN
  DenseI64ArrayAttr,   # Q
  DenseI64ArrayAttr,   # P
  DenseI32ArrayAttr,   # logQ
  DenseI32ArrayAttr,   # logP
  int   # logDefaultScale
&gt;
</code></pre><p>This attribute represents the literal parameters for Lattigo CKKS.</p><p>This is in accordance with <a href=https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/ckks#ParametersLiteral>https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/ckks#ParametersLiteral</a>
where some field are not present in the current implementation.</p><p>Users must set the polynomial degree (LogN) and the coefficient modulus,
by either setting the Q and P fields to the desired moduli chain,
or by setting the LogQ and LogP fields to the desired moduli sizes.</p><p>Note that for Lattigo, Q/P requires []uint64, where this attribute
only provides int64. We assume user should not select moduli so large
to consider the signedness issue.</p><p>Users must also specify a default initial scale for the plaintexts1.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>logN</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>Q</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>P</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logQ</td><td style=text-align:center><code>DenseI32ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logP</td><td style=text-align:center><code>DenseI32ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logDefaultScale</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h2 id=lattigo-types>Lattigo types</h2><h3 id=bgvencodertype>BGVEncoderType</h3><p>Syntax: <code>!lattigo.bgv.encoder</code></p><p>This type represents the encoder for the BGV encryption scheme.</p><h3 id=bgvevaluatortype>BGVEvaluatorType</h3><p>Syntax: <code>!lattigo.bgv.evaluator</code></p><p>This type represents the evaluator for the BGV encryption scheme.</p><h3 id=bgvparametertype>BGVParameterType</h3><p>Syntax: <code>!lattigo.bgv.parameter</code></p><p>This type represents the parameters for the BGV encryption scheme.</p><h3 id=ckksencodertype>CKKSEncoderType</h3><p>Syntax: <code>!lattigo.ckks.encoder</code></p><p>This type represents the encoder for the CKKS encryption scheme.</p><h3 id=ckksevaluatortype>CKKSEvaluatorType</h3><p>Syntax: <code>!lattigo.ckks.evaluator</code></p><p>This type represents the evaluator for the CKKS encryption scheme.</p><h3 id=ckksparametertype>CKKSParameterType</h3><p>Syntax: <code>!lattigo.ckks.parameter</code></p><p>This type represents the parameters for the CKKS encryption scheme.</p><h3 id=rlweciphertexttype>RLWECiphertextType</h3><p>Syntax: <code>!lattigo.rlwe.ciphertext</code></p><p>This type represents the ciphertext for the RLWE encryption scheme.</p><h3 id=rlwedecryptortype>RLWEDecryptorType</h3><p>Syntax: <code>!lattigo.rlwe.decryptor</code></p><p>This type represents the decryptor for the RLWE encryption scheme.</p><h3 id=rlweencryptortype>RLWEEncryptorType</h3><p>Syntax:</p><pre tabindex=0><code>!lattigo.rlwe.encryptor&lt;
  bool   # publicKey
&gt;
</code></pre><p>This type represents the encryptor for the RLWE encryption scheme.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>publicKey</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=rlweevaluationkeysettype>RLWEEvaluationKeySetType</h3><p>Syntax: <code>!lattigo.rlwe.evaluation_key_set</code></p><p>This type represents the evaluation key set for the RLWE encryption scheme.</p><h3 id=rlwegaloiskeytype>RLWEGaloisKeyType</h3><p>Syntax:</p><pre tabindex=0><code>!lattigo.rlwe.galois_key&lt;
  ::mlir::IntegerAttr   # galoisElement
&gt;
</code></pre><p>This type represents the Galois key for the RLWE encryption scheme.</p><p>galoisElement: Enabling the automorphism X -> X^{galoisElement}.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>galoisElement</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td>An Attribute containing a integer value</td></tr></tbody></table><h3 id=rlwekeygeneratortype>RLWEKeyGeneratorType</h3><p>Syntax: <code>!lattigo.rlwe.key_generator</code></p><p>This type represents the key generator for the RLWE encryption scheme.</p><h3 id=rlweplaintexttype>RLWEPlaintextType</h3><p>Syntax: <code>!lattigo.rlwe.plaintext</code></p><p>This type represents the plaintext for the RLWE encryption scheme.</p><h3 id=rlwepublickeytype>RLWEPublicKeyType</h3><p>Syntax: <code>!lattigo.rlwe.public_key</code></p><p>This type represents the public key for the RLWE encryption scheme.</p><h3 id=rlwerelinearizationkeytype>RLWERelinearizationKeyType</h3><p>Syntax: <code>!lattigo.rlwe.relinearization_key</code></p><p>This type represents the relinearization key for the RLWE encryption scheme.</p><h3 id=rlwesecretkeytype>RLWESecretKeyType</h3><p>Syntax: <code>!lattigo.rlwe.secret_key</code></p><p>This type represents the secret key for the RLWE encryption scheme.</p><h2 id=lattigo-ops>Lattigo ops</h2><h3 id=lattigobgvadd_new-heirlattigobgvaddnewop><code>lattigo.bgv.add_new</code> (heir::lattigo::BGVAddNewOp)</h3><p><em>Add two ciphertexts in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.add_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation adds two ciphertext values in the Lattigo BGV dialect.</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvadd-heirlattigobgvaddop><code>lattigo.bgv.add</code> (heir::lattigo::BGVAddOp)</h3><p><em>Add two ciphertexts in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation adds two ciphertext values in the Lattigo BGV dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvdecode-heirlattigobgvdecodeop><code>lattigo.bgv.decode</code> (heir::lattigo::BGVDecodeOp)</h3><p><em>Decode a plaintext value in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.decode` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation decodes a plaintext value using the specified encoder in the Lattigo BGV dialect.</p><p>The input value tensor should have elements of integer type.</p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encoder</code></td><td></td></tr><tr><td style=text-align:center><code>plaintext</code></td><td></td></tr><tr><td style=text-align:center><code>value</code></td><td>ranked tensor of integer values</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>decoded</code></td><td>ranked tensor of integer values</td></tr></tbody></table><h3 id=lattigobgvencode-heirlattigobgvencodeop><code>lattigo.bgv.encode</code> (heir::lattigo::BGVEncodeOp)</h3><p><em>Encode a plaintext value in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.encode` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation encodes a plaintext value using the specified encoder in the Lattigo BGV dialect.</p><p>The input value tensor should have elements of integer type.</p><p>The <code>scale</code> attribute indicates the scaling factor for encoding.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scale</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encoder</code></td><td></td></tr><tr><td style=text-align:center><code>value</code></td><td>ranked tensor of integer values</td></tr><tr><td style=text-align:center><code>plaintext</code></td><td></td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encoded</code></td><td></td></tr></tbody></table><h3 id=lattigobgvmul_new-heirlattigobgvmulnewop><code>lattigo.bgv.mul_new</code> (heir::lattigo::BGVMulNewOp)</h3><p><em>Multiply two ciphertexts in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.mul_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation multiplies two ciphertext values in the Lattigo BGV dialect.</p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvmul-heirlattigobgvmulop><code>lattigo.bgv.mul</code> (heir::lattigo::BGVMulOp)</h3><p><em>Multiply two ciphertexts in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation multiplies two ciphertext values in the Lattigo BGV dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvnew_encoder-heirlattigobgvnewencoderop><code>lattigo.bgv.new_encoder</code> (heir::lattigo::BGVNewEncoderOp)</h3><p><em>Create a new encoder in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.new_encoder` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates a new encoder for encoding plaintext values in the Lattigo BGV dialect.</p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td></td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encoder</code></td><td></td></tr></tbody></table><h3 id=lattigobgvnew_evaluator-heirlattigobgvnewevaluatorop><code>lattigo.bgv.new_evaluator</code> (heir::lattigo::BGVNewEvaluatorOp)</h3><p><em>Create a new evaluator in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.new_evaluator` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates a new evaluator for performing operations on ciphertexts in the Lattigo BGV dialect.</p><p>By default, the evaluator is created with the provided parameters and could execute
operations which does not relying on evaluation keys.</p><p>To support operations that require evaluation keys,
the optional evaluation key set should be provided.</p><p>The scaleInvariant flag is used to indicate whether the evaluator is for B/FV or BGV.
If it is set to true, the evaluator will evaluate operations in B/FV style.</p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleInvariant</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td></td></tr><tr><td style=text-align:center><code>evaluationKeySet</code></td><td></td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr></tbody></table><h3 id=lattigobgvnew_parameters_from_literal-heirlattigobgvnewparametersfromliteralop><code>lattigo.bgv.new_parameters_from_literal</code> (heir::lattigo::BGVNewParametersFromLiteralOp)</h3><p><em>Create new BGV parameters from a literal in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.new_parameters_from_literal` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates new BGV parameters from a given literal value in the Lattigo BGV dialect.</p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>paramsLiteral</code></td><td>::mlir::heir::lattigo::BGVParametersLiteralAttr</td><td>Literal parameters for Lattigo BGV</td></tr></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td></td></tr></tbody></table><h3 id=lattigobgvnew_plaintext-heirlattigobgvnewplaintextop><code>lattigo.bgv.new_plaintext</code> (heir::lattigo::BGVNewPlaintextOp)</h3><p><em>Create a new plaintext in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.new_plaintext` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates a new plaintext value in the Lattigo BGV dialect.</p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td></td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td></td></tr></tbody></table><h3 id=lattigobgvrelinearize_new-heirlattigobgvrelinearizenewop><code>lattigo.bgv.relinearize_new</code> (heir::lattigo::BGVRelinearizeNewOp)</h3><p><em>Relinearize a ciphertext in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.relinearize_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation relinearizes a ciphertext value in the Lattigo BGV dialect.</p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvrelinearize-heirlattigobgvrelinearizeop><code>lattigo.bgv.relinearize</code> (heir::lattigo::BGVRelinearizeOp)</h3><p><em>Relinearize a ciphertext in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.relinearize` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation relinearizes a ciphertext value in the Lattigo BGV dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvrescale_new-heirlattigobgvrescalenewop><code>lattigo.bgv.rescale_new</code> (heir::lattigo::BGVRescaleNewOp)</h3><p><em>Rescale a ciphertext in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.rescale_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation rescales a ciphertext value in the Lattigo BGV dialect.</p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvrescale-heirlattigobgvrescaleop><code>lattigo.bgv.rescale</code> (heir::lattigo::BGVRescaleOp)</h3><p><em>Rescale a ciphertext in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.rescale` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation rescales a ciphertext value in the Lattigo BGV dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvrotate_columns_new-heirlattigobgvrotatecolumnsnewop><code>lattigo.bgv.rotate_columns_new</code> (heir::lattigo::BGVRotateColumnsNewOp)</h3><p><em>Rotate columns of a ciphertext in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.rotate_columns_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation rotates the columns of a ciphertext value in the Lattigo BGV dialect.</p><p>Lattigo exposes the SIMD slot of BGV as a N/2 x 2 matrix, where N/2 is the column.</p><p>Offset is valid for both positive and negative number.</p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvrotate_columns-heirlattigobgvrotatecolumnsop><code>lattigo.bgv.rotate_columns</code> (heir::lattigo::BGVRotateColumnsOp)</h3><p><em>Rotate columns of a ciphertext in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.rotate_columns` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation rotates the columns of a ciphertext value in the Lattigo BGV dialect.</p><p>Lattigo exposes the SIMD slot of BGV as a N/2 x 2 matrix, where N/2 is the column.</p><p>Offset is valid for both positive and negative number.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvrotate_rows_new-heirlattigobgvrotaterowsnewop><code>lattigo.bgv.rotate_rows_new</code> (heir::lattigo::BGVRotateRowsNewOp)</h3><p><em>Rotate rows of a ciphertext in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.rotate_rows_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation swap the rows of a ciphertext value in the Lattigo BGV dialect.</p><p>Lattigo exposes the SIMD slot of BGV as a N/2 x 2 matrix, where 2 is the row.</p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvrotate_rows-heirlattigobgvrotaterowsop><code>lattigo.bgv.rotate_rows</code> (heir::lattigo::BGVRotateRowsOp)</h3><p><em>Rotate rows of a ciphertext in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.rotate_rows` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation swap the rows of a ciphertext value in the Lattigo BGV dialect.</p><p>Lattigo exposes the SIMD slot of BGV as a N/2 x 2 matrix, where 2 is the row.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvsub_new-heirlattigobgvsubnewop><code>lattigo.bgv.sub_new</code> (heir::lattigo::BGVSubNewOp)</h3><p><em>Subtract two ciphertexts in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.sub_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation subtracts one ciphertext value from another in the Lattigo BGV dialect.</p><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigobgvsub-heirlattigobgvsubop><code>lattigo.bgv.sub</code> (heir::lattigo::BGVSubOp)</h3><p><em>Subtract two ciphertexts in the Lattigo BGV dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.bgv.sub` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation subtracts one ciphertext value from another in the Lattigo BGV dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksadd_new-heirlattigockksaddnewop><code>lattigo.ckks.add_new</code> (heir::lattigo::CKKSAddNewOp)</h3><p><em>Add two ciphertexts in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.add_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation adds two ciphertext values in the Lattigo CKKS dialect.</p><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksadd-heirlattigockksaddop><code>lattigo.ckks.add</code> (heir::lattigo::CKKSAddOp)</h3><p><em>Add two ciphertexts in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation adds two ciphertext values in the Lattigo CKKS dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksdecode-heirlattigockksdecodeop><code>lattigo.ckks.decode</code> (heir::lattigo::CKKSDecodeOp)</h3><p><em>Decode a plaintext value in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.decode` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation decodes a plaintext value using the specified encoder in the Lattigo CKKS dialect.</p><p>The input value tensor should have elements of float type or complex type.</p><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encoder</code></td><td></td></tr><tr><td style=text-align:center><code>plaintext</code></td><td></td></tr><tr><td style=text-align:center><code>value</code></td><td>ranked tensor of floating-point or complex-type values</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>decoded</code></td><td>ranked tensor of floating-point or complex-type values</td></tr></tbody></table><h3 id=lattigockksencode-heirlattigockksencodeop><code>lattigo.ckks.encode</code> (heir::lattigo::CKKSEncodeOp)</h3><p><em>Encode a plaintext value in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.encode` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation encodes a plaintext value using the specified encoder in the Lattigo CKKS dialect.</p><p>The input value tensor should have elements of float type or complex type.</p><p>The <code>scale</code> attribute indicates the scaling factor for encoding.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scale</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encoder</code></td><td></td></tr><tr><td style=text-align:center><code>value</code></td><td>ranked tensor of floating-point or complex-type values</td></tr><tr><td style=text-align:center><code>plaintext</code></td><td></td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encoded</code></td><td></td></tr></tbody></table><h3 id=lattigockksmul_new-heirlattigockksmulnewop><code>lattigo.ckks.mul_new</code> (heir::lattigo::CKKSMulNewOp)</h3><p><em>Multiply two ciphertexts in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.mul_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation multiplies two ciphertext values in the Lattigo CKKS dialect.</p><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksmul-heirlattigockksmulop><code>lattigo.ckks.mul</code> (heir::lattigo::CKKSMulOp)</h3><p><em>Multiply two ciphertexts in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation multiplies two ciphertext values in the Lattigo CKKS dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksnew_encoder-heirlattigockksnewencoderop><code>lattigo.ckks.new_encoder</code> (heir::lattigo::CKKSNewEncoderOp)</h3><p><em>Create a new encoder in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.new_encoder` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates a new encoder for encoding plaintext values in the Lattigo CKKS dialect.</p><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td></td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encoder</code></td><td></td></tr></tbody></table><h3 id=lattigockksnew_evaluator-heirlattigockksnewevaluatorop><code>lattigo.ckks.new_evaluator</code> (heir::lattigo::CKKSNewEvaluatorOp)</h3><p><em>Create a new evaluator in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.new_evaluator` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates a new evaluator for performing operations on ciphertexts in the Lattigo CKKS dialect.</p><p>By default, the evaluator is created with the provided parameters and could execute
operations which does not relying on evaluation keys.</p><p>To support operations that require evaluation keys,
the optional evaluation key set should be provided.</p><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td></td></tr><tr><td style=text-align:center><code>evaluationKeySet</code></td><td></td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr></tbody></table><h3 id=lattigockksnew_parameters_from_literal-heirlattigockksnewparametersfromliteralop><code>lattigo.ckks.new_parameters_from_literal</code> (heir::lattigo::CKKSNewParametersFromLiteralOp)</h3><p><em>Create new CKKS parameters from a literal in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.new_parameters_from_literal` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates new CKKS parameters from a given literal value in the Lattigo CKKS dialect.</p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>paramsLiteral</code></td><td>::mlir::heir::lattigo::CKKSParametersLiteralAttr</td><td>Literal parameters for Lattigo CKKS</td></tr></table><h4 id=results-28>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td></td></tr></tbody></table><h3 id=lattigockksnew_plaintext-heirlattigockksnewplaintextop><code>lattigo.ckks.new_plaintext</code> (heir::lattigo::CKKSNewPlaintextOp)</h3><p><em>Create a new plaintext in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.new_plaintext` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates a new plaintext value in the Lattigo CKKS dialect.</p><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td></td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td></td></tr></tbody></table><h3 id=lattigockksrelinearize_new-heirlattigockksrelinearizenewop><code>lattigo.ckks.relinearize_new</code> (heir::lattigo::CKKSRelinearizeNewOp)</h3><p><em>Relinearize a ciphertext in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.relinearize_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation relinearizes a ciphertext value in the Lattigo CKKS dialect.</p><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksrelinearize-heirlattigockksrelinearizeop><code>lattigo.ckks.relinearize</code> (heir::lattigo::CKKSRelinearizeOp)</h3><p><em>Relinearize a ciphertext in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.relinearize` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation relinearizes a ciphertext value in the Lattigo CKKS dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksrescale_new-heirlattigockksrescalenewop><code>lattigo.ckks.rescale_new</code> (heir::lattigo::CKKSRescaleNewOp)</h3><p><em>Rescale a ciphertext in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.rescale_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation rescales a ciphertext value in the Lattigo CKKS dialect.</p><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-32>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksrescale-heirlattigockksrescaleop><code>lattigo.ckks.rescale</code> (heir::lattigo::CKKSRescaleOp)</h3><p><em>Rescale a ciphertext in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.rescale` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation rescales a ciphertext value in the Lattigo CKKS dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-33>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksrotate_new-heirlattigockksrotatenewop><code>lattigo.ckks.rotate_new</code> (heir::lattigo::CKKSRotateNewOp)</h3><p><em>Rotate slots of a ciphertext in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.rotate_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation rotates slots of a ciphertext value in the Lattigo CKKS dialect.</p><p>For vanilla CKKS, the maximum number of slots is N/2 with each slot being complex number.
Lattigo also support a conjugate-invariant version of CKKS, i.e. the ring is
Z[X + X^{-1} ]/(X^N+1), which allows for a maximum of N slots with each slot being real number.</p><p>Offset is valid for both positive and negative number.</p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-32>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-34>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockksrotate-heirlattigockksrotateop><code>lattigo.ckks.rotate</code> (heir::lattigo::CKKSRotateOp)</h3><p><em>Rotate slots of a ciphertext in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.rotate` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation rotates slots of a ciphertext value in the Lattigo CKKS dialect.</p><p>For vanilla CKKS, the maximum number of slots is N/2 with each slot being complex number.
Lattigo also support a conjugate-invariant version of CKKS, i.e. the ring is
Z[X + X^{-1} ]/(X^N+1), which allows for a maximum of N slots with each slot being real number.</p><p>Offset is valid for both positive and negative number.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-33>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-35>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockkssub_new-heirlattigockkssubnewop><code>lattigo.ckks.sub_new</code> (heir::lattigo::CKKSSubNewOp)</h3><p><em>Subtract two ciphertexts in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.sub_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation subtracts one ciphertext value from another in the Lattigo CKKS dialect.</p><h4 id=operands-34>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr></tbody></table><h4 id=results-36>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigockkssub-heirlattigockkssubop><code>lattigo.ckks.sub</code> (heir::lattigo::CKKSSubOp)</h3><p><em>Subtract two ciphertexts in the Lattigo CKKS dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.ckks.sub` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation subtracts one ciphertext value from another in the Lattigo CKKS dialect.</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-35>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td></td></tr><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>or</td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-37>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigorlwedecrypt-heirlattigorlwedecryptop><code>lattigo.rlwe.decrypt</code> (heir::lattigo::RLWEDecryptOp)</h3><p><em>Decrypts a ciphertext using RLWE</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.decrypt` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation decrypts a ciphertext using RLWE</p><h4 id=operands-36>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>decryptor</code></td><td></td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td></td></tr></tbody></table><h4 id=results-38>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td></td></tr></tbody></table><h3 id=lattigorlwedrop_level_new-heirlattigorlwedroplevelnewop><code>lattigo.rlwe.drop_level_new</code> (heir::lattigo::RLWEDropLevelNewOp)</h3><p><em>Drop level of a ciphertext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.drop_level_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>levelToDrop</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-37>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td>or</td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-39>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigorlwedrop_level-heirlattigorlwedroplevelop><code>lattigo.rlwe.drop_level</code> (heir::lattigo::RLWEDropLevelOp)</h3><p><em>Drop level of a ciphertext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.drop_level` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation drops the level of a ciphertext</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code>result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>levelToDrop</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-38>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td>or</td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-40>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigorlweencrypt-heirlattigorlweencryptop><code>lattigo.rlwe.encrypt</code> (heir::lattigo::RLWEEncryptOp)</h3><p><em>Encrypts a plaintext using RLWE</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.encrypt` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation encrypts a plaintext using RLWE</p><h4 id=operands-39>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encryptor</code></td><td></td></tr><tr><td style=text-align:center><code>plaintext</code></td><td></td></tr></tbody></table><h4 id=results-41>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertext</code></td><td></td></tr></tbody></table><h3 id=lattigorlwegen_galois_key-heirlattigorlwegengaloiskeyop><code>lattigo.rlwe.gen_galois_key</code> (heir::lattigo::RLWEGenGaloisKeyOp)</h3><p><em>Generates a new RLWE Galois key</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.gen_galois_key` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation generates a new RLWE Galois key</p><p>galoisElement: Enabling the automorphism X -> X^{galoisElement}.</p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>galoisElement</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-40>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>keyGenerator</code></td><td></td></tr><tr><td style=text-align:center><code>secretKey</code></td><td></td></tr></tbody></table><h4 id=results-42>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>galoisKey</code></td><td></td></tr></tbody></table><h3 id=lattigorlwegen_key_pair-heirlattigorlwegenkeypairop><code>lattigo.rlwe.gen_key_pair</code> (heir::lattigo::RLWEGenKeyPairOp)</h3><p><em>Generates a new RLWE key pair</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.gen_key_pair` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation generates a new RLWE key pair</p><h4 id=operands-41>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>keyGenerator</code></td><td></td></tr></tbody></table><h4 id=results-43>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>secretKey</code></td><td></td></tr><tr><td style=text-align:center><code>publicKey</code></td><td></td></tr></tbody></table><h3 id=lattigorlwegen_relinearization_key-heirlattigorlwegenrelinearizationkeyop><code>lattigo.rlwe.gen_relinearization_key</code> (heir::lattigo::RLWEGenRelinearizationKeyOp)</h3><p><em>Generates a new RLWE relinearization key</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.gen_relinearization_key` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation generates a new RLWE relinearization key</p><h4 id=operands-42>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>keyGenerator</code></td><td></td></tr><tr><td style=text-align:center><code>secretKey</code></td><td></td></tr></tbody></table><h4 id=results-44>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>relinearizationKey</code></td><td></td></tr></tbody></table><h3 id=lattigorlwenegate_new-heirlattigorlwenegatenewop><code>lattigo.rlwe.negate_new</code> (heir::lattigo::RLWENegateNewOp)</h3><p><em>Negate a ciphertext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.negate_new` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-43>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td>or</td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-45>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigorlwenegate-heirlattigorlwenegateop><code>lattigo.rlwe.negate</code> (heir::lattigo::RLWENegateOp)</h3><p><em>Negate of a ciphertext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.negate` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation negates a ciphertext</p><p>The result will be written to the <code>inplace</code> operand. The <code>output</code> result is
a transitive reference to the <code>inplace</code> operand for sake of the MLIR SSA form.</p><p>Interfaces: <code>InplaceOpInterface</code></p><h4 id=operands-44>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluator</code></td><td>or</td></tr><tr><td style=text-align:center><code>input</code></td><td></td></tr><tr><td style=text-align:center><code>inplace</code></td><td></td></tr></tbody></table><h4 id=results-46>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=lattigorlwenew_decryptor-heirlattigorlwenewdecryptorop><code>lattigo.rlwe.new_decryptor</code> (heir::lattigo::RLWENewDecryptorOp)</h3><p><em>Creates a new RLWE decryptor</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.new_decryptor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates a new RLWE decryptor</p><h4 id=operands-45>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td>or</td></tr><tr><td style=text-align:center><code>secretKey</code></td><td></td></tr></tbody></table><h4 id=results-47>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>decryptor</code></td><td></td></tr></tbody></table><h3 id=lattigorlwenew_encryptor-heirlattigorlwenewencryptorop><code>lattigo.rlwe.new_encryptor</code> (heir::lattigo::RLWENewEncryptorOp)</h3><p><em>Creates a new RLWE encryptor</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.new_encryptor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation creates a new RLWE encryptor</p><h4 id=operands-46>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td>or</td></tr><tr><td style=text-align:center><code>encryptionKey</code></td><td>or</td></tr></tbody></table><h4 id=results-48>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>encryptor</code></td><td></td></tr></tbody></table><h3 id=lattigorlwenew_evaluation_key_set-heirlattigorlwenewevaluationkeysetop><code>lattigo.rlwe.new_evaluation_key_set</code> (heir::lattigo::RLWENewEvaluationKeySetOp)</h3><p><em>Generates a new RLWE evaluation key set</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.new_evaluation_key_set` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation generates a new RLWE evaluation key set</p><h4 id=operands-47>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>keys</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-49>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>evaluationKeySet</code></td><td></td></tr></tbody></table><h3 id=lattigorlwenew_key_generator-heirlattigorlwenewkeygeneratorop><code>lattigo.rlwe.new_key_generator</code> (heir::lattigo::RLWENewKeyGeneratorOp)</h3><p><em>Generates a new RLWE key generator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lattigo.rlwe.new_key_generator` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation generates a new RLWE key generator</p><h4 id=operands-48>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td>or</td></tr></tbody></table><h4 id=results-50>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>keyGenerator</code></td><td></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c5dda3cb8e694541eacbee638af7317d>8 - LWE</h1><h1 id=lwe-dialect>&rsquo;lwe&rsquo; Dialect</h1><p>The <code>lwe</code> dialect is a dialect for concepts related to cryptosystems
in the Learning With Errors (LWE) family.</p><p>See <a href=https://en.wikipedia.org/wiki/Learning_with_errors>Wikipedia</a>
for an overview of LWE and the related
<a href=https://en.wikipedia.org/wiki/Ring_learning_with_errors>RLWE</a>
problem.</p><p>While one might expect this dialect to contain types along the lines
of LWE and RLWE ciphertexts, and operations like encryption, decryption,
adding and multiplying ciphertexts, these concepts are not centralized
here because they are too scheme-specific.</p><p>Instead, this dialect provides attributes that can be attached to tensors
of integer or <code>poly.poly</code> types, which indicate that they are semantically
LWE and RLWE ciphertexts, respectively.</p><h2 id=lwe-attributes>LWE attributes</h2><h3 id=applicationdataattr>ApplicationDataAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.application_data&lt;
  mlir::Type,   # message_type
  Attribute   # overflow
&gt;
</code></pre><p>An attribute describing the semantics of the underlying application data.</p><p>The <code>messageType</code> parameter is used to describe the type and bits of the
original application data, e.g. i1, i32, f32. This type is later mapped
into the plaintext space of an FHE scheme by embedding, scaling, or other
techniques.</p><p>This attribute also contains information about the overflow semantics of the
data in the application. By default, we assume that the application program
was written so that the overflow is not expected and the overflow attribute
can can be <code>no_overflow</code>. For LWE-based CGGI ciphertexts, the overflow
attribute will usually be <code>preserve_overflow</code>, since messages will overflow
into padding bits.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>message_type</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>overflow</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=ciphertextspaceattr>CiphertextSpaceAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.ciphertext_space&lt;
  ::mlir::heir::polynomial::RingAttr,   # ring
  ::mlir::heir::lwe::LweEncryptionType,   # encryption_type
  unsigned   # size
&gt;
</code></pre><p>An attribute describing the ciphertext space and the transformation from
plaintext space to ciphertext space of an FHE scheme.</p><p>The ciphertext space information includes the ring attribute, describing the
space that the ciphertext elements belong to. The ring attribute contains a
coefficient type attribute that describes the semantics of the coefficient.
For example, a ring modulo $1 + x^1024$ with coefficients modulo $q =
298374$ will be described as</p><pre tabindex=0><code>!cmod = !mod_arith.int&lt;298374 : i64&gt;
#ring = #polynomial.ring&lt;coefficientType = !cmod, polynomialModulus = &lt;1 + x**1024&gt;&gt;
#ciphertext_space = #lwe.ciphertext_space&lt;ring = #ring, encryption_type = lsb&gt;
</code></pre><p>Ciphertexts using an RNS representation for $q$ will use an RNS type in
their ring&rsquo;s coefficient type attribute.</p><pre tabindex=0><code>!limb1 = !mod_arith.int&lt;2251799814045697 : i64&gt;
!limb2 = !mod_arith.int&lt;65537 : i64&gt;
#rns_mod = !rns.rns&lt;!limb1, !limb2&gt;
#ring = #polynomial.ring&lt;coefficientType = #rns_mod, polynomialModulus = &lt;1 + x**1024&gt;&gt;
#ciphertext_space = #lwe.ciphertext_space&lt;ring = #ring, encryption_type = lsb&gt;
</code></pre><p>Scalar LWE ciphertexts (like those used in CGGI) use an ideal polynomial of
degree 1, $x$. CGGI ciphertexts will typically use a power of two modulus
and may use a native integer type for its coefficient modulus.</p><pre tabindex=0><code>#ring = #polynomial.ring&lt;coefficientType = i32, polynomialModulus = &lt;1 + x**1024&gt;&gt;
#ciphertext_space = #lwe.ciphertext_space&lt;ring = #ring, encryption_type = lsb&gt;
</code></pre><p>The ciphertext encoding info is used to describe the way the plaintext data
is encoded into the ciphertext (in the MSB, LSB, or mixed).</p><p>The <code>size</code> parameter is used to describe the number of polynomials
comprising the ciphertext. This is typically 2 for RLWE ciphertexts that
are made up of an $(a, b)$ pair and greater than 2 for LWE instances. For
example, after an RLWE multiplication of two size 2 ciphertexts,
the ciphertext&rsquo;s size will be 3.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr><tr><td style=text-align:center>encryption_type</td><td style=text-align:center><code>::mlir::heir::lwe::LweEncryptionType</code></td><td></td></tr><tr><td style=text-align:center>size</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=coefficientencodingattr>CoefficientEncodingAttr</h3><p><em>An encoding of cleartexts directly as coefficients.</em></p><p>Syntax:</p><pre tabindex=0><code>#lwe.coefficient_encoding&lt;
  int64_t   # scaling_factor
&gt;
</code></pre><p>A coefficient encoding of a list of integers asserts that the coefficients
of the polynomials contain the integers, with the same semantics as
<code>constant_coefficient_encoding</code> for per-coefficient encodings.</p><p>A <code>scaling_factor</code> is optionally applied on the scalar when converting from
a rounded floating point to an integer.</p><p>Example:</p><pre tabindex=0><code>#coeff_encoding = #lwe.coefficient_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=constantcoefficientencodingattr>ConstantCoefficientEncodingAttr</h3><p><em>An encoding of a scalar in the constant coefficient</em></p><p>Syntax:</p><pre tabindex=0><code>#lwe.constant_coefficient_encoding&lt;
  int64_t   # scaling_factor
&gt;
</code></pre><p>An encoding of a single scalar into the constant coefficient of the plaintext.</p><p>All other coefficients of the plaintext are set to be zero. This encoding is
used to encode scalar LWE ciphertexts where the plaintext space is viewed
as a polynomial ring modulo <code>x</code>.</p><p>The scalar is first multiplied by the <code>scaling_factor</code> and then rounded to
the nearest integer before encoding into the plaintext coefficient.</p><p>Example:</p><pre tabindex=0><code>#coeff_encoding = #lwe.constant_coefficient_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=fullcrtpackingencodingattr>FullCRTPackingEncodingAttr</h3><p><em>An encoding of cleartexts via CRT slots.</em></p><p>Syntax:</p><pre tabindex=0><code>#lwe.full_crt_packing_encoding&lt;
  int64_t   # scaling_factor
&gt;
</code></pre><p>This encoding maps a list of integers via the Chinese Remainder Theorem (CRT) into the plaintext space.</p><p>Given a ring with irreducible ideal polynomial <code>f(x)</code> and coefficient
modulus <code>q</code>, <code>f(x)</code> can be decomposed modulo <code>q</code> into a direct product of
lower-degree polynomials. This allows full SIMD-style homomorphic operations
across the slots formed from each factor.</p><p>This attribute can only be used in the context of on full CRT packing, where
the polynomial <code>f(x)</code> splits completely (into linear factors) and the number
of slots equals the degree of <code>f(x)</code>. This happens when <code>q</code> is prime and <code>q = 1 mod n</code>.</p><p>A <code>scaling_factor</code> is optionally applied on the scalar when converting from
a rounded floating point to an integer.</p><p>Example:</p><pre tabindex=0><code>#coeff_encoding = #lwe.full_crt_packing_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=inversecanonicalencodingattr>InverseCanonicalEncodingAttr</h3><p><em>An encoding of cleartexts via the inverse canonical embedding.</em></p><p>Syntax:</p><pre tabindex=0><code>#lwe.inverse_canonical_encoding&lt;
  int64_t   # scaling_factor
&gt;
</code></pre><p>Let $n$ be the degree of the polynomials in the plaintext space. An
&ldquo;inverse_canonical_encoding&rdquo; of a list of real or complex values
$v_1, \dots, v_{n/2}$ is (almost) the inverse of the following decoding
map.</p><p>Define a map $\tau_N$ that maps a polynomial $p \in \mathbb{Z}[x] / (x^N + 1)
\to \mathbb{C}^{N/2}$ by evaluating it at the following $N/2$ points,
where $\omega = e^{2 \pi i / 2N}$ is the primitive $2N$th root of unity:</p><p>[
\omega, \omega^3, \omega^5, \dots, \omega^{N-1}
]</p><p>Then the complete decoding operation is $\textup{Decode}(p) =
(1/\Delta)\tau_N(p)$, where $\Delta$ is a scaling parameter and $\tau_N$ is
the truncated canonical embedding above. The encoding operation is the
inverse of the decoding operation, with some caveats explained below.</p><p>The map $\tau_N$ is derived from the so-called <em>canonical embedding</em>
$\tau$, though in the standard canonical embedding, we evaluate at all odd
powers of the root of unity, $\omega, \omega^3, \dots, \omega^{2N-1}$. For
polynomials in the slightly larger space $\mathbb{R}[x] / (x^N + 1)$, the
image of the canonical embedding is the subspace $H \subset \mathbb{C}^N$
defined by tuples $(z_1, \dots, z_N)$ such that $\overline{z_i} =
\overline{z_{N-i+1}}$. Note that this property holds because polynomial
evaluation commutes with complex conjugates, and the second half of the
roots of unity evaluate are complex conjugates of the first half. The
converse, that any such tuple with complex conjugate symmetry has an
inverse under $\tau$ with all real coefficients, makes $\tau$ is a
bijection onto $H$. $\tau$ and its inverse are explicitly computable as
discrete Fourier Transforms.</p><p>Because of the symmetry in canonical embedding for real polynomials, inputs
to this encoding can be represented as a list of $N/2$ complex points, with
the extra symmetric structure left implicit. $\tau_N$ and its inverse can
also be explicitly computed without need to expand the vectors to length
$N$.</p><p>The rounding step is required to invert the decoding because, while
cleartexts must be (implicitly) in the subspace $H$, they need not be the
output of $\tau_N$ for an <em>integer</em> polynomial. The rounding step ensures
we can use integer polynomial plaintexts for the FHE operations. There are
multiple rounding mechanisms, and this attribute does not specify which is
used, because in theory two ciphertexts that have used different roundings
are still compatible, though they may have different noise growth patterns.</p><p>The scaling parameter $\Delta$ is specified by the <code>scaling_factor</code>, which
are applied coefficient-wise using the same semantics as the
<code>constant_coefficient_encoding</code>.</p><p>A typical flow for the CKKS scheme using this encoding would be to apply an
inverse FFT operation to invert the canonical embedding to be a polynomial
with real coefficients, then encrypt scale the resulting polynomial&rsquo;s
coefficients according to the scaling parameters, then round to get integer
coefficients.</p><p>Example:</p><pre tabindex=0><code>#canonical_encoding = #lwe.inverse_canonical_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=keyattr>KeyAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.key&lt;
  int   # slot_index
&gt;
</code></pre><p>An attribute describing the key with which the message is currently
encrypted.</p><p>The key attribute describes the key with which the message is currently
encrypted and decryption can be performed. For example, if the decryption of
a ciphertext $c = (c_0(x), c_1(x))$ is performed by computing the inner
product $(c_0(x), c_1(x)) \cdot (1, s(x))$ then the key is $(1, s(x))$.</p><p>The <code>slot_index</code> describes the key after using a Galois automorphism to
rotate the plaintext slots by <code>slot_index</code>. This will correspond to an
action $\phi_k: x \rightarrow x^k$ for some <code>k</code> that depends on the
structure of the Galois group for the chosen scheme parameters. The
corresponding key will have a new basis $(1, s(x^(k)))$.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>slot_index</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=moduluschainattr>ModulusChainAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.modulus_chain&lt;
  ::llvm::ArrayRef&lt;mlir::IntegerAttr&gt;,   # elements
  int   # current
&gt;
</code></pre><p>An attribute describing the elements of the modulus chain of an RLWE scheme.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::IntegerAttr></code></td><td></td></tr><tr><td style=text-align:center>current</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=nooverflowattr>NoOverflowAttr</h3><p><em>An attribute informing that application data never overflows.</em></p><p>Syntax: <code>#lwe.no_overflow</code></p><p>This attribute informs lowerings that a program is written so that the message data
will never overflow beyond the message type.</p><p>// FIXME: Have a separate WraparoundOverflow, which lowers the same as NoOverflow?</p><h3 id=plaintextspaceattr>PlaintextSpaceAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.plaintext_space&lt;
  ::mlir::heir::polynomial::RingAttr,   # ring
  Attribute   # encoding
&gt;
</code></pre><p>An attribute describing the plaintext space and the transformation from
application data to plaintext space of an FHE scheme.</p><p>The plaintext space information is the ring structure, which contains the
plaintext modulus $t$, which may be a power of two in the case of CGGI
ciphertexts, or a prime power for RLWE. LWE ciphertexts use the
ideal polynomial of degree 1 $x$. The plaintext modulus used in LWE-based
CGGI plaintexts describes the full message space $\mathbb{Z}_p$ including
the padding bits. The application data info attribute describes the space
$\mathbb{Z}_p&rsquo;$ where $p&rsquo; &lt; p$ that the underlying message belongs to.</p><p>For RLWE schemes, this will include the type of encoding of application data
integers to a plaintext space <code>Z_p[X]/X^N + 1</code>. This may be a constant
coefficient encoding, CRT-based packing for SIMD semantics, or other slot
packing. When using full CRT packing, the ring must split into linear
factors. The CKKS scheme will also include attributes describing the complex
encoding, including the scaling factor, which will change after
multiplication and rescaling.</p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>Attribute</code></td><td>An encoding of a scalar in the constant coefficient or An encoding of cleartexts directly as coefficients. or An encoding of cleartexts via the inverse canonical embedding. or An encoding of cleartexts via CRT slots.</td></tr></tbody></table><h3 id=preserveoverflowattr>PreserveOverflowAttr</h3><p><em>An attribute informing that application data overflows in the message type.</em></p><p>Syntax: <code>#lwe.preserve_overflow</code></p><p>This attribute informs lowerings that a program is written so that the message data
may overflow beyond the message type.</p><h2 id=lwe-types>LWE types</h2><h3 id=lweciphertexttype>LWECiphertextType</h3><p><em>A ciphertext type</em></p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_ciphertext&lt;
  ApplicationDataAttr,   # application_data
  PlaintextSpaceAttr,   # plaintext_space
  CiphertextSpaceAttr,   # ciphertext_space
  KeyAttr,   # key
  ModulusChainAttr   # modulus_chain
&gt;
</code></pre><p>An LWE ciphertext will always contain the application data, plaintext space,
ciphertext space, and key information.</p><p>A modulus chain is optionally specified for parameter choices in RLWE
schemes that use more than one of modulus. When no modulus chain is
specified, the ciphertext modulus is always the ciphertext ring&rsquo;s
coefficient modulus.</p><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>application_data</td><td style=text-align:center><code>ApplicationDataAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintext_space</td><td style=text-align:center><code>PlaintextSpaceAttr</code></td><td></td></tr><tr><td style=text-align:center>ciphertext_space</td><td style=text-align:center><code>CiphertextSpaceAttr</code></td><td></td></tr><tr><td style=text-align:center>key</td><td style=text-align:center><code>KeyAttr</code></td><td></td></tr><tr><td style=text-align:center>modulus_chain</td><td style=text-align:center><code>ModulusChainAttr</code></td><td></td></tr></tbody></table><h3 id=lweplaintexttype>LWEPlaintextType</h3><p><em>A plaintext type</em></p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_plaintext&lt;
  ApplicationDataAttr,   # application_data
  PlaintextSpaceAttr   # plaintext_space
&gt;
</code></pre><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>application_data</td><td style=text-align:center><code>ApplicationDataAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintext_space</td><td style=text-align:center><code>PlaintextSpaceAttr</code></td><td></td></tr></tbody></table><h3 id=lwepublickeytype>LWEPublicKeyType</h3><p><em>A public key for LWE</em></p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_public_key&lt;
  KeyAttr,   # key
  ::mlir::heir::polynomial::RingAttr   # ring
&gt;
</code></pre><h4 id=parameters-11>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>key</td><td style=text-align:center><code>KeyAttr</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr></tbody></table><h3 id=lwesecretkeytype>LWESecretKeyType</h3><p><em>A secret key for LWE</em></p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_secret_key&lt;
  KeyAttr,   # key
  ::mlir::heir::polynomial::RingAttr   # ring
&gt;
</code></pre><h4 id=parameters-12>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>key</td><td style=text-align:center><code>KeyAttr</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr></tbody></table><h2 id=lwe-ops>LWE ops</h2><h3 id=lweadd-heirlweaddop><code>lwe.add</code> (heir::lwe::AddOp)</h3><p><em>Add two LWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.add` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=lweencode-heirlweencodeop><code>lwe.encode</code> (heir::lwe::EncodeOp)</h3><p><em>Encode an integer to yield an LWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.encode` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
</code></pre><p>Encode an integer to yield an LWE plaintext.</p><p>This op uses an overflow attribute to indicate the overflow semantics. For
CGGI ciphertexts, this will typically be <code>preserve_overflow</code> to indicate
that the message bits can overflow into the carry bit space.</p><p>The LWE plaintext ring is constructed with a plaintext bit width using <code>plaintext_bits</code> and a
polynomial modulus of <code>x</code>.</p><p>Examples:</p><pre tabindex=0><code>%Y = lwe.encode %value {overflow = #overflow, plaintext_bits = 3}: i1 to !lwe.lwe_plaintext&lt;application_data = #app_data, plaintext_space = #space&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>plaintext_bits</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>overflow</code></td><td>::mlir::Attribute</td><td>An attribute informing that application data never overflows. or An attribute informing that application data overflows in the message type.</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless-integer-like or floating-point-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A plaintext type</td></tr></tbody></table><h3 id=lwemul_scalar-heirlwemulscalarop><code>lwe.mul_scalar</code> (heir::lwe::MulScalarOp)</h3><p><em>Multiply an LWE ciphertext by a scalar</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.mul_scalar` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertext</code></td><td>lwe-ciphertext-like</td></tr><tr><td style=text-align:center><code>scalar</code></td><td>integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=lweradd-heirlweraddop><code>lwe.radd</code> (heir::lwe::RAddOp)</h3><p><em>Add two RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.radd` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=lweradd_plain-heirlweraddplainop><code>lwe.radd_plain</code> (heir::lwe::RAddPlainOp)</h3><p><em>Addition between RLWE ciphertext-plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.radd_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>InferTypeOpAdaptor</code>, <code>IsCiphertextPlaintextOp</code>, <code>SameOperandsAndResultPlaintextTypes</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type or A plaintext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type or A plaintext type</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=lwerlwe_decode-heirlwerlwedecodeop><code>lwe.rlwe_decode</code> (heir::lwe::RLWEDecodeOp)</h3><p><em>Decode an RLWE plaintext to an underlying type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_decode` $input attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>encoding</code></td><td>::mlir::Attribute</td><td>An encoding of a scalar in the constant coefficient or An encoding of cleartexts directly as coefficients. or An encoding of cleartexts via the inverse canonical embedding. or An encoding of cleartexts via CRT slots.</td></tr><tr><td><code>ring</code></td><td>::mlir::heir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A plaintext type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like or floating-point-like</td></tr></tbody></table><h3 id=lwerlwe_decrypt-heirlwerlwedecryptop><code>lwe.rlwe_decrypt</code> (heir::lwe::RLWEDecryptOp)</h3><p><em>Decrypt an RLWE ciphertext to a RLWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_decrypt` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Decrypt an RLWE ciphertext to yield a RLWE plaintext</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>secret_key</code></td><td>A secret key for LWE</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A plaintext type</td></tr></tbody></table><h3 id=lwerlwe_encode-heirlwerlweencodeop><code>lwe.rlwe_encode</code> (heir::lwe::RLWEEncodeOp)</h3><p><em>Encode an integer to yield an RLWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_encode` $input attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Encode an integer to yield an RLWE plaintext.</p><p>This op uses a an encoding attribute to encode the bits of the integer into
an RLWE plaintext value that can then be encrypted. CKKS cleartext inputs may
be floating points, and a scaling factor described by the encoding will be
applied.</p><p>Examples:</p><pre tabindex=0><code>%Y = lwe.rlwe_encode %value {encoding = #enc, ring = #ring}: i1 to !lwe.rlwe_plaintext&lt;encoding = #enc, ring = #ring&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>encoding</code></td><td>::mlir::Attribute</td><td>An encoding of a scalar in the constant coefficient or An encoding of cleartexts directly as coefficients. or An encoding of cleartexts via the inverse canonical embedding. or An encoding of cleartexts via CRT slots.</td></tr><tr><td><code>ring</code></td><td>::mlir::heir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless-integer-like or floating-point-like</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A plaintext type</td></tr></tbody></table><h3 id=lwerlwe_encrypt-heirlwerlweencryptop><code>lwe.rlwe_encrypt</code> (heir::lwe::RLWEEncryptOp)</h3><p><em>Encrypt an RLWE plaintext to a RLWE ciphertext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_encrypt` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Encrypt an RLWE plaintext to yield a RLWE ciphertext.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A plaintext type</td></tr><tr><td style=text-align:center><code>key</code></td><td>A secret key for LWE or A public key for LWE</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=lwermul-heirlwermulop><code>lwe.rmul</code> (heir::lwe::RMulOp)</h3><p><em>Multiplies two RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rmul` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=lwermul_plain-heirlwermulplainop><code>lwe.rmul_plain</code> (heir::lwe::RMulPlainOp)</h3><p><em>Multiplication between RLWE ciphertext-plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rmul_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>InferTypeOpAdaptor</code>, <code>IsCiphertextPlaintextOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type or A plaintext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type or A plaintext type</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=lwernegate-heirlwernegateop><code>lwe.rnegate</code> (heir::lwe::RNegateOp)</h3><p><em>Negate a RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rnegate` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>lwe-ciphertext-like</td></tr></tbody></table><h3 id=lwersub-heirlwersubop><code>lwe.rsub</code> (heir::lwe::RSubOp)</h3><p><em>Subtract two RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rsub` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultPlaintextTypes</code>, <code>SameOperandsAndResultRings</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=lwersub_plain-heirlwersubplainop><code>lwe.rsub_plain</code> (heir::lwe::RSubPlainOp)</h3><p><em>Subtraction between RLWE ciphertext-plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rsub_plain` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code>, <code>IsCiphertextPlaintextOp</code>, <code>SameOperandsAndResultPlaintextTypes</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type or A plaintext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type or A plaintext type</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=lwetrivial_encrypt-heirlwetrivialencryptop><code>lwe.trivial_encrypt</code> (heir::lwe::TrivialEncryptOp)</h3><p><em>Create a trivial encryption of a plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.trivial_encrypt` $input attr-dict `:`  qualified(type(operands)) `to` qualified(type(results))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ciphertext_bits</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A plaintext type</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=lwereinterpret_application_data-heirlwereinterpretapplicationdataop><code>lwe.reinterpret_application_data</code> (heir::lwe::ReinterpretApplicationDataOp)</h3><p><em>A placeholder cast from one ciphertext type to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.reinterpret_application_data` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
</code></pre><p>The <code>cast</code> op is thus used to translate application data (e.g., <code>message_type</code>)
between ciphertexts in particular situations, such as when the bitwidth of the
message type changes, but this change is not observed in the plaintext space,
or when lowering to an API that does not keep track of types.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h2 id=lwe-additional-definitions>LWE additional definitions</h2><h3 id=lweencryptiontype>LweEncryptionType</h3><p><em>An enum attribute representing an encryption method</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>msb</td><td style=text-align:center><code>0</code></td><td>msb</td></tr><tr><td style=text-align:center>lsb</td><td style=text-align:center><code>1</code></td><td>lsb</td></tr><tr><td style=text-align:center>mix</td><td style=text-align:center><code>2</code></td><td>mix</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-024e5f7d26a5dfbbc21bb90c29119ca6>9 - MathExt</h1><h1 id=math_ext-dialect>&lsquo;math_ext&rsquo; Dialect</h1><p>Math-related operations we require for HEIR
which do not (yet) exist in upstream <code>math</code>.</p><h2 id=mathext-ops>MathExt ops</h2><h3 id=math_extsign-heirmath_extsignop><code>math_ext.sign</code> (heir::math_ext::SignOp)</h3><p><em>Returns the sign of the input value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math_ext.sign` $value attr-dict `:` type($result)
</code></pre><p>Returns -1 if the input is negative, 0 if it is zero, and 1 if it is positive.
The behavior is undefined for NaN inputs.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless-integer-like or floating-point-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like or floating-point-like</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-b15a871dcca009396e70be943220c783>10 - Mgmt</h1><h1 id=mgmt-dialect>&lsquo;mgmt&rsquo; Dialect</h1><p>The <code>mgmt</code> dialect contains scheme-agnostic ciphertext management ops
(like relinearize and mod reduce), to enable initial high-level compiler
passes to perform a first pass at parameter selection, while lower-level
passes may refine them with scheme-specific information.</p><h2 id=mgmt-attributes>Mgmt attributes</h2><h3 id=mgmtattr>MgmtAttr</h3><p><em>Container attribute for all mgmt parameter</em></p><p>Syntax:</p><pre tabindex=0><code>#mgmt.mgmt&lt;
  int,   # level
  int,   # dimension
  int64_t   # scale
&gt;
</code></pre><p>This attribute is used to store all mgmt parameters.</p><p>The attribute is a struct with the following fields:</p><ul><li><code>level</code> : the level of the ciphertext, from L to 0</li><li><code>dimension</code> : the dimension of the ciphertext, defaults to 2</li></ul><p>Internally, this attribute is used by secret-to-<scheme>
for determining the level and dimension of the ciphertext.</p><p>It should be populated by &ndash;secret-with-mgmt-<scheme> before
going through the secret-to-<scheme> pass.</p><p>Example:</p><pre tabindex=0><code>#mgmt = #mgmt.mgmt&lt;level = 1&gt; // dimension defaults to 2
#mgmt1 = #mgmt.mgmt&lt;level = 1, dimension = 3&gt;
%0 = secret.generic(%arg0, %arg1 : !secret.secret&lt;i16&gt;) attrs = {mgmt.mgmt = #mgmt} {
   ...
} -&gt; !secret.secret&lt;i16&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>level</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>dimension</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>scale</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=openfheparamsattr>OpenfheParamsAttr</h3><p><em>Container attribute for some OpenFHE-specific parameters</em></p><p>Syntax:</p><pre tabindex=0><code>#mgmt.openfhe_params&lt;
  int,   # evalAddCount
  int   # keySwitchCount
&gt;
</code></pre><p>This attribute is used to store some OpenFHE-specific parameters.</p><p>The attribute is a struct with the following fields:</p><ul><li><code>evalAddCount</code> : param for OpenFHE SetEvalAddCount</li><li><code>keySwitchCount</code> : param for OpenFHE SetKeySwitchCount</li></ul><p>When this attribute presents, the lowering of openfhe pass
will use these parameters to set the corresponding OpenFHE
parameters.</p><p>It should be populated by &ndash;secret-with-mgmt-bgv before
going through the secret-to-bgv bgv-to-openfhe pass.</p><p>Example:</p><pre tabindex=0><code>#openfhe_params = #mgmt.openfhe_params&lt;evalAddCount = 1, keySwitchCount = 1&gt;
</code></pre><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>evalAddCount</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>keySwitchCount</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h2 id=mgmt-ops>Mgmt ops</h2><h3 id=mgmtadjust_scale-heirmgmtadjustscaleop><code>mgmt.adjust_scale</code> (heir::mgmt::AdjustScaleOp)</h3><p><em>Adjust the scale of the input ciphertext (for BGV and CKKS)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mgmt.adjust_scale` operands attr-dict `:` type($output)
</code></pre><p>This is scheme-agonistic operation that adjust the scale of the input
ciphertext. This is an opaque operation, and the concrete value of the
scale is determined by other methods.</p><p>To distinguish different opaque adjust_scale operations, the <code>id</code> attribute
is used.</p><p>At the time of <code>secret-insert-mgmt-&lt;scheme></code>, the concrete scale
is not known as the scheme parameter is not generated.
Further passes like <code>populate-scale-&lt;scheme></code> is responsible for materializing
the concrete scale when the scheme parameter is known.</p><p>When further lowered, it could be lowered to <code>bgv.mul_plain</code>
or <code>ckks.mul_plain</code> depending on the scheme.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=mgmtbootstrap-heirmgmtbootstrapop><code>mgmt.bootstrap</code> (heir::mgmt::BootstrapOp)</h3><p><em>Bootstrap the input ciphertext to refresh its noise budget</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mgmt.bootstrap` operands attr-dict `:` type($output)
</code></pre><p>This is a scheme-agnostic operation that implies bootstrapping
of the input ciphertext to refresh its noise budget.</p><p>Bootstrapping is a technique used in homomorphic encryption to
reduce the noise in a ciphertext, allowing further operations
to be performed on it without decryption.</p><p>When further lowered, it could be lowered to bgv.bootstrap
or ckks.bootstrap depending on the scheme.</p><p>For the current backend, only ckks.bootstrap is supported.
Further backend may include bgv.bootstrap.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=mgmtinit-heirmgmtinitop><code>mgmt.init</code> (heir::mgmt::InitOp)</h3><p><em>Init the plaintext with mgmt attributes</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mgmt.init` operands attr-dict `:` type($output)
</code></pre><p>This is a scheme-agnostic operation that initializes the plaintext
with <code>mgmt</code> attributes.</p><p>Plaintext has multiple sources, e.g. function argument, arith.constant,
tensor.empty, etc. However, they may have multiple uses in HE circuit
and the level/scale information for them may be different, so we could
not annotate them with <code>mgmt</code> attributes directly, as they could not have
more than one annotation.</p><p>Also, <code>mgmt</code> attributes annotated on them may get lost as other optimization
like CSE or constant folding may canonicalize them away.</p><p>To address the problem, for each <em>use</em> of the plaintext, we insert an <code>mgmt.init</code>
operation to initialize the plaintext with <code>mgmt</code> attributes.</p><p>Technical reasons for registering memory effects:</p><p>Register a (bogus) memory effect to prevent CSE from merging this op.
Two mgmt.init ops could be seen as equivalent only if they have the same
MgmtAttr with <em>level/dimension/scale</em> annotated, otherwise we could not
judge whether they are equivalent or not. In practice, we create the op first
and only in later analyses we know whether they are equivalent or not.</p><p>ConditionallySpeculatable is for isSpeculatable check in hoisting canonicalization.</p><p>Traits: <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=mgmtlevel_reduce-heirmgmtlevelreduceop><code>mgmt.level_reduce</code> (heir::mgmt::LevelReduceOp)</h3><p><em>Reduce the level of input ciphertext by dropping the last k RNS limbs</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mgmt.level_reduce` operands attr-dict `:` type($output)
</code></pre><p>This scheme-agonistic operation reduces the ciphertext level
by k, as specified by the <code>levelToDrop</code> attribute.</p><p>If <code>levelToDrop</code> is not specified, it defaults to 1.</p><p>Input ciphertext is assumed to be in RNS form when further lowered.</p><p>Later passes may lower this op to <code>bgv.level_reduce</code>
or <code>ckks.level_reduce</code> depending on the scheme.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>levelToDrop</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=mgmtmodreduce-heirmgmtmodreduceop><code>mgmt.modreduce</code> (heir::mgmt::ModReduceOp)</h3><p><em>Modulus switch the input ciphertext down by one limb (RNS assumed)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mgmt.modreduce` operands attr-dict `:` type($output)
</code></pre><p>This is scheme-agonistic operation that implies modulus switching/rescaling
by one limb.</p><p>Input ciphertext is assumed to be in RNS form when further lowered.</p><p>When further lowered, it could be lowered to bgv.modulus_switch
or ckks.rescale depending on the scheme.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=mgmtrelinearize-heirmgmtrelinearizeop><code>mgmt.relinearize</code> (heir::mgmt::RelinearizeOp)</h3><p><em>Relinearize the input ciphertext to be <em>linear</em></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mgmt.relinearize` operands attr-dict `:` type($output)
</code></pre><p>This is scheme-agonistic operation that implies relinearization
of the input ciphertext to be <em>linear</em> (i.e. returns to dimension 2).</p><p>This is used solely by multiplication. For rotation, currently HEIR
assumes relinearization is done internally and does not have a separate
scheme-specific operation for it.</p><p>This accepts a ciphertext with dimension > 2 and returns a ciphertext
with dimension 2. Note that the semantic includes the relinearization
of higher dimension input like input with dimension 4 or higher,
which when materialized should require multiple relinearization keys.</p><p>When further lowered, it could be lowered to bgv.relinearize
or ckks.relinearize depending on the scheme.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-75945813f3978b67fb0398cc4f17cb8b>11 - ModArith</h1><h1 id=mod_arith-dialect>&lsquo;mod_arith&rsquo; Dialect</h1><p>The <code>mod_arith</code> dialect contains operations used for modulo arithmetic.</p><h2 id=modarith-types>ModArith types</h2><h3 id=modarithtype>ModArithType</h3><p><em>Integer type with modular arithmetic</em></p><p>Syntax:</p><pre tabindex=0><code>!mod_arith.int&lt;
  ::mlir::IntegerAttr   # modulus
&gt;
</code></pre><p><code>mod_arith.int&lt;p></code> represents an element of the ring of integers modulo $p$.
The <code>modulus</code> attribute is the ring modulus, and <code>mod_arith</code> operations lower to
<code>arith</code> operations that produce results in the range <code>[0, modulus)</code>, often called
the <em>canonical representative</em>.</p><p><code>modulus</code> is specified with an integer type suffix, for example,
<code>mod_arith.int&lt;65537 : i32></code>. This corresponds to the storage type for the
modulus, and is <code>i64</code> by default.</p><p>It is required that the underlying integer type should be larger than
twice the modulus (have one extra bit of storage space) to avoid signedness
issues. For example, when <code>modulus == 2 ** 32 - 1</code>, the underlying type
for the modulus should be at least <code>i33</code>, though <code>i64</code> is a natural choice.</p><p>Passes may allow intermediate values that do not always produce a
canonical representative in <code>[0, modulus)</code>. For example, if the machine storage
type is <code>i64</code>, but the <code>modulus</code> fits within an <code>i32</code>, a lowering could
allow intermediate arithmetic values to grow to as large as an <code>i64</code> before
reducing them. However, all passes must ensure that values used outside
the local scope (e.g., function return values or arguments to calls to linked
functions) are appropriately reduced to the canonical representative.
<code>modulus</code> is the modulus the arithmetic working with.</p><p>Examples:</p><pre tabindex=0><code>!Zp1 = !mod_arith.int&lt;7&gt; // implicitly being i64
!Zp2 = !mod_arith.int&lt;65537 : i32&gt;
!Zp3 = !mod_arith.int&lt;536903681 : i64&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>modulus</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td></td></tr></tbody></table><h2 id=modarith-ops>ModArith ops</h2><h3 id=mod_arithadd-heirmod_arithaddop><code>mod_arith.add</code> (heir::mod_arith::AddOp)</h3><p><em>Modular addition operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.add` operands attr-dict `:` type($output)
</code></pre><p>Computes modular addition.</p><p>Unless otherwise specified, the operation assumes both inputs are canonical
representatives and guarantees the output being canonical representative.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>mod_arith_or_rns-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table><h3 id=mod_arithbarrett_reduce-heirmod_arithbarrettreduceop><code>mod_arith.barrett_reduce</code> (heir::mod_arith::BarrettReduceOp)</h3><p><em>Compute the first step of the Barrett reduction.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.barrett_reduce` operands attr-dict `:` qualified(type($input))
</code></pre><p>Let $q$ denote a statically known modulus and $b = 4^{w}$, where $w$ is the
smallest bit-width that contains the range $[0, q)$. The Barrett reduce
operation computes <code>barret_reduce x = x - floor(x * floor(b / q) / b) * q</code>.</p><p>Given $0 &lt;= x &lt; q^2$, then this will compute $(x \mod q)$ or $(x \mod q) + q$.</p><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modulus</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless-integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer</td></tr></tbody></table><h3 id=mod_arithconstant-heirmod_arithconstantop><code>mod_arith.constant</code> (heir::mod_arith::ConstantOp)</h3><p><em>Define a constant value via an attribute.</em></p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> mod_arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>123</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>mod_arith<span style=color:#000;font-weight:700>.</span>int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>65537</span><span style=color:#000;font-weight:700>:</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::TypedAttr</td><td>TypedAttr instance</td></tr></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>mod_arith-like</td></tr></tbody></table><h3 id=mod_arithencapsulate-heirmod_arithencapsulateop><code>mod_arith.encapsulate</code> (heir::mod_arith::EncapsulateOp)</h3><p><em>Encapsulate an integer into a mod_arith type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.encapsulate` operands attr-dict `:` type($input) `-&gt;` type($output)
</code></pre><p><code>mod_arith.encapsulate</code> converts the integer to be of mod_arith or RNS type.</p><p>Examples:</p><pre tabindex=0><code>mod_arith.encapsulate %c0 : i32 -&gt; mod_arith.int&lt;65537 : i32&gt;
mod_arith.encapsulate %c1 : i64 -&gt; mod_arith.int&lt;65537 : i64&gt;
mod_arith.encapsulate %c2 : tensor&lt;4x2xi32&gt; -&gt; tensor&lt;4xrns.rns&lt;mod_arith.int&lt;5 : i32&gt;, mod_arith.int&lt;17 : i32&gt;&gt;&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless-integer</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table><h3 id=mod_arithextract-heirmod_arithextractop><code>mod_arith.extract</code> (heir::mod_arith::ExtractOp)</h3><p><em>Extract the integer stored inside mod_arith type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.extract` operands attr-dict `:` type($input) `-&gt;` type($output)
</code></pre><p><code>mod_arith.extract</code> extracts the integer inside the mod_arith or RNS type.</p><p>It is required that the bitwidth of the output (tensor of) integer type is
the same as that of the storage type of the input mod_arith (or RNS) type.</p><p>Examples:</p><pre tabindex=0><code>%m0 = mod_arith.encapsulate %c0 : i32 -&gt; mod_arith.int&lt;65537 : i32&gt;
%m1 = mod_arith.encapsulate %c1 : i64 -&gt; mod_arith.int&lt;65537 : i64&gt;
%m2 = mod_arith.encapsulate %c2 : tensor&lt;4x2xi32&gt; -&gt; tensor&lt;4xrns.rns&lt;mod_arith.int&lt;5 : i32&gt;, mod_arith.int&lt;17 : i32&gt;&gt;&gt;
%c3 = mod_arith.extract %m0 : mod_arith.int&lt;65537 : i32&gt; -&gt; i32
%c4 = mod_arith.extract %m1 : mod_arith.int&lt;65537 : i64&gt; -&gt; i64
%c5 = mod_arith.extract %m2 : tensor&lt;4xrns.rns&lt;mod_arith.int&lt;5 : i32&gt;, mod_arith.int&lt;17 : i32&gt;&gt;&gt; -&gt; tensor&lt;4x2xi32&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer</td></tr></tbody></table><h3 id=mod_arithmac-heirmod_arithmacop><code>mod_arith.mac</code> (heir::mod_arith::MacOp)</h3><p><em>Modular multiplication-and-accumulation operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.mac` operands attr-dict `:` type($output)
</code></pre><p><code>mod_arith.mac x, y, z</code> computes $(x * y) + z$</p><p>Unless otherwise specified, the operation assumes all inputs are canonical
representatives and guarantees the output being canonical representative.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>mod_arith-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>mod_arith-like</td></tr><tr><td style=text-align:center><code>acc</code></td><td>mod_arith-like</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>mod_arith-like</td></tr></tbody></table><h3 id=mod_arithmod_switch-heirmod_arithmodswitchop><code>mod_arith.mod_switch</code> (heir::mod_arith::ModSwitchOp)</h3><p><em>Change the modulus of a mod_arith</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.mod_switch` $input attr-dict `:` type($input) `to` type($output)
</code></pre><p>The &ldquo;mod_switch&rdquo; operation performs either modulus switching (changing the
modulus of a mod_arith type to a new value by reducing modulo the new
modulus) or CRT decomposition/interpolation.</p><p>A CRT decomposition can handle switching from a mod_arith type to the RNS
modulus when the modulus of the mod_arith type is equal to the product of
the RNS modulus. If the modulus is less than the RNS modulus product, it
treats the input as an element of the larger product space via an injection.</p><p>Examples:</p><pre tabindex=0><code>mod_arith.mod_switch %c0 : mod_arith.int&lt;65537 : i32&gt; to mod_arith.int&lt;65539 : i32&gt;
mod_arith.mod_switch %c0 : mod_arith.int&lt;65537 : i32&gt; to mod_arith.int&lt;257 : i32&gt;
mod_arith.mod_switch %c0 : mod_arith.int&lt;85 : i32&gt; to rns.rns&lt;mod_arith.int&lt;5 : i32&gt;, mod_arith.int&lt;17 : i32&gt;&gt;
mod_arith.mod_switch %c0 : mod_arith.int&lt;45 : i32&gt; to rns.rns&lt;mod_arith.int&lt;5 : i32&gt;, mod_arith.int&lt;17 : i32&gt;&gt;
mod_arith.mod_switch %c0 : rns.rns&lt;mod_arith.int&lt;5 : i32&gt;, mod_arith.int&lt;17 : i32&gt;&gt; to mod_arith.int&lt;85 : i32&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table><h3 id=mod_arithmul-heirmod_arithmulop><code>mod_arith.mul</code> (heir::mod_arith::MulOp)</h3><p><em>Modular multiplication operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.mul` operands attr-dict `:` type($output)
</code></pre><p>Computes modular multiplication.</p><p>Unless otherwise specified, the operation assumes both inputs are canonical
representatives and guarantees the output being canonical representative.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>mod_arith_or_rns-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table><h3 id=mod_arithreduce-heirmod_arithreduceop><code>mod_arith.reduce</code> (heir::mod_arith::ReduceOp)</h3><p><em>Reduce the mod arith type to its canonical representative</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.reduce` operands attr-dict `:` type($output)
</code></pre><p><code>mod_arith.reduce x</code> produces $y$, the canonical representative in $[0, q)$
such that $x \equiv y \mod q$.</p><p>Examples:</p><pre tabindex=0><code>%c0 = arith.constant 65538 : i32
%m0 = mod_arith.encapsulate %c0 : i32 -&gt; mod_arith.int&lt;65537 : i32&gt;
// mod_arith.extract %m0 produces 65538
%m1 = mod_arith.reduce %m0 : mod_arith.int&lt;65537: i32&gt;
// mod_arith.extract %m1 produces 1
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>mod_arith-like</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>mod_arith-like</td></tr></tbody></table><h3 id=mod_arithsubifge-heirmod_arithsubifgeop><code>mod_arith.subifge</code> (heir::mod_arith::SubIfGEOp)</h3><p><em>Compute (x >= y) ? x - y : x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.subifge` operands attr-dict `:` qualified(type($output))
</code></pre><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer</td></tr></tbody></table><h3 id=mod_arithsub-heirmod_arithsubop><code>mod_arith.sub</code> (heir::mod_arith::SubOp)</h3><p><em>Modular subtraction operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `mod_arith.sub` operands attr-dict `:` type($output)
</code></pre><p>Computes modular subtraction.</p><p>Unless otherwise specified, the operation assumes both inputs are canonical
representatives and guarantees the output being canonical representative.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>mod_arith_or_rns-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>mod_arith_or_rns-like</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e397c035ea096bd861aadf40d3fccd0a>12 - Openfhe</h1><h1 id=openfhe-dialect>&lsquo;openfhe&rsquo; Dialect</h1><p>The <code>openfhe</code> dialect is an exit dialect for generating c++ code against the OpenFHE library API.</p><p>See <a href=https://github.com/openfheorg/openfhe-development>https://github.com/openfheorg/openfhe-development</a></p><h2 id=openfhe-types>Openfhe types</h2><h3 id=ccparamstype>CCParamsType</h3><p><em>The CCParams required to create CryptoContext.</em></p><p>Syntax: <code>!openfhe.cc_params</code></p><h3 id=cryptocontexttype>CryptoContextType</h3><p><em>The CryptoContext required to perform homomorphic operations in OpenFHE.</em></p><p>Syntax: <code>!openfhe.crypto_context</code></p><h3 id=digitdecompositiontype>DigitDecompositionType</h3><p><em>A precomputed digit decomposition for for EvalFastRotation</em></p><p>Syntax: <code>!openfhe.digit_decomp</code></p><h3 id=evalkeytype>EvalKeyType</h3><p><em>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.</em></p><p>Syntax: <code>!openfhe.eval_key</code></p><h3 id=privatekeytype>PrivateKeyType</h3><p><em>The private key required to decrypt a ciphertext in OpenFHE.</em></p><p>Syntax: <code>!openfhe.private_key</code></p><h3 id=publickeytype>PublicKeyType</h3><p><em>The public key required to encrypt plaintext in OpenFHE.</em></p><p>Syntax: <code>!openfhe.public_key</code></p><h2 id=openfhe-ops>Openfhe ops</h2><h3 id=openfheadd_inplace-heiropenfheaddinplaceop><code>openfhe.add_inplace</code> (heir::openfhe::AddInPlaceOp)</h3><p><em>Performs in-place homomorphic addition, modifying lhs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.add_inplace` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfheadd-heiropenfheaddop><code>openfhe.add</code> (heir::openfhe::AddOp)</h3><p><em>OpenFHE add operation of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfheadd_plain-heiropenfheaddplainop><code>openfhe.add_plain</code> (heir::openfhe::AddPlainOp)</h3><p><em>OpenFHE add operation of a ciphertext and a plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.add_plain` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AllCiphertextTypesMatch</code>, <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type or A plaintext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type or A plaintext type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfheautomorph-heiropenfheautomorphop><code>openfhe.automorph</code> (heir::openfhe::AutomorphOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.automorph` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>evalKey</code></td><td>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhebootstrap-heiropenfhebootstrapop><code>openfhe.bootstrap</code> (heir::openfhe::BootstrapOp)</h3><p><em>OpenFHE bootstrap operation of a ciphertext. (For CKKS)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.bootstrap` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhedecrypt-heiropenfhedecryptop><code>openfhe.decrypt</code> (heir::openfhe::DecryptOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.decrypt` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>privateKey</code></td><td>The private key required to decrypt a ciphertext in OpenFHE.</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td>A plaintext type</td></tr></tbody></table><h3 id=openfheencrypt-heiropenfheencryptop><code>openfhe.encrypt</code> (heir::openfhe::EncryptOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.encrypt` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>plaintext</code></td><td>A plaintext type</td></tr><tr><td style=text-align:center><code>encryptionKey</code></td><td>The public key required to encrypt plaintext in OpenFHE. or The private key required to decrypt a ciphertext in OpenFHE.</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhefast_rotation-heiropenfhefastrotationop><code>openfhe.fast_rotation</code> (heir::openfhe::FastRotationOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.fast_rotation` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>cyclotomicOrder</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>input</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>precomputedDigitDecomp</code></td><td>A precomputed digit decomposition for for EvalFastRotation</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhefast_rotation_precompute-heiropenfhefastrotationprecomputeop><code>openfhe.fast_rotation_precompute</code> (heir::openfhe::FastRotationPrecomputeOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.fast_rotation_precompute` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>input</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A precomputed digit decomposition for for EvalFastRotation</td></tr></tbody></table><h3 id=openfhegen_bootstrapkey-heiropenfhegenbootstrapkeyop><code>openfhe.gen_bootstrapkey</code> (heir::openfhe::GenBootstrapKeyOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.gen_bootstrapkey` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>privateKey</code></td><td>The private key required to decrypt a ciphertext in OpenFHE.</td></tr></tbody></table><h3 id=openfhegen_context-heiropenfhegencontextop><code>openfhe.gen_context</code> (heir::openfhe::GenContextOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.gen_context` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>supportFHE</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td>The CCParams required to create CryptoContext.</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>context</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr></tbody></table><h3 id=openfhegen_mulkey-heiropenfhegenmulkeyop><code>openfhe.gen_mulkey</code> (heir::openfhe::GenMulKeyOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.gen_mulkey` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>privateKey</code></td><td>The private key required to decrypt a ciphertext in OpenFHE.</td></tr></tbody></table><h3 id=openfhegen_params-heiropenfhegenparamsop><code>openfhe.gen_params</code> (heir::openfhe::GenParamsOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.gen_params` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Generates the parameters for the OpenFHE scheme.</p><p><code>mulDepth</code> is the depth of the multiplication circuit,
including the bootstrapping depth.</p><p><code>plainMod</code> is the modulus of the plaintext space. If we
are using CKKS, this is 0.</p><p><code>insecure</code> is a flag that determines whether the parameters
are generated securely or not. In Openfhe, this means setting
HEStd_NotSet for security level.</p><p>For other flags, see the OpenFHE documentation in
<a href=https://github.com/openfheorg/openfhe-development/blob/main/src/pke/examples/README.md#description-of-the-cryptocontext-parameters-and-their-restrictions>https://github.com/openfheorg/openfhe-development/blob/main/src/pke/examples/README.md#description-of-the-cryptocontext-parameters-and-their-restrictions</a></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mulDepth</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>plainMod</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>ringDim</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>batchSize</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>firstModSize</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>scalingModSize</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>evalAddCount</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>keySwitchCount</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>digitSize</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>numLargeDigits</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>maxRelinSkDeg</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>insecure</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>encryptionTechniqueExtended</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>keySwitchingTechniqueBV</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>scalingTechniqueFixedManual</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>params</code></td><td>The CCParams required to create CryptoContext.</td></tr></tbody></table><h3 id=openfhegen_rotkey-heiropenfhegenrotkeyop><code>openfhe.gen_rotkey</code> (heir::openfhe::GenRotKeyOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.gen_rotkey` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>indices</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>privateKey</code></td><td>The private key required to decrypt a ciphertext in OpenFHE.</td></tr></tbody></table><h3 id=openfhekey_switch-heiropenfhekeyswitchop><code>openfhe.key_switch</code> (heir::openfhe::KeySwitchOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.key_switch` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>evalKey</code></td><td>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhelevel_reduce-heiropenfhelevelreduceop><code>openfhe.level_reduce</code> (heir::openfhe::LevelReduceOp)</h3><p><em>OpenFHE level_reduce operation of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.level_reduce` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>levelToDrop</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhemake_ckks_packed_plaintext-heiropenfhemakeckkspackedplaintextop><code>openfhe.make_ckks_packed_plaintext</code> (heir::openfhe::MakeCKKSPackedPlaintextOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.make_ckks_packed_plaintext` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>value</code></td><td>ranked tensor of floating-point or integer values</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td>A plaintext type</td></tr></tbody></table><h3 id=openfhemake_packed_plaintext-heiropenfhemakepackedplaintextop><code>openfhe.make_packed_plaintext</code> (heir::openfhe::MakePackedPlaintextOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.make_packed_plaintext` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>value</code></td><td>ranked tensor of integer values</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td>A plaintext type</td></tr></tbody></table><h3 id=openfhemod_reduce-heiropenfhemodreduceop><code>openfhe.mod_reduce</code> (heir::openfhe::ModReduceOp)</h3><p><em>OpenFHE mod_reduce operation of a ciphertext. (used only for BGV/CKKS)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mod_reduce` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhemul_const-heiropenfhemulconstop><code>openfhe.mul_const</code> (heir::openfhe::MulConstOp)</h3><p><em>OpenFHE mul operation of a ciphertext and a constant.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mul_const` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>constant</code></td><td>64-bit signless integer</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhemul_no_relin-heiropenfhemulnorelinop><code>openfhe.mul_no_relin</code> (heir::openfhe::MulNoRelinOp)</h3><p><em>OpenFHE mul operation of two ciphertexts without relinearization.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mul_no_relin` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhemul-heiropenfhemulop><code>openfhe.mul</code> (heir::openfhe::MulOp)</h3><p><em>OpenFHE mul operation of two ciphertexts with relinearization.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhemul_plain-heiropenfhemulplainop><code>openfhe.mul_plain</code> (heir::openfhe::MulPlainOp)</h3><p><em>OpenFHE mul operation of a ciphertext and a plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.mul_plain` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>plaintext</code></td><td>A plaintext type</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhenegate-heiropenfhenegateop><code>openfhe.negate</code> (heir::openfhe::NegateOp)</h3><p><em>OpenFHE negate operation of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.negate` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfherelin-heiropenfherelinop><code>openfhe.relin</code> (heir::openfhe::RelinOp)</h3><p><em>OpenFHE relinearize operation of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.relin` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfherot-heiropenfherotop><code>openfhe.rot</code> (heir::openfhe::RotOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.rot` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhesetup_bootstrap-heiropenfhesetupbootstrapop><code>openfhe.setup_bootstrap</code> (heir::openfhe::SetupBootstrapOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.setup_bootstrap` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>levelBudgetEncode</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr><tr><td><code>levelBudgetDecode</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr></tbody></table><h3 id=openfhesquare-heiropenfhesquareop><code>openfhe.square</code> (heir::openfhe::SquareOp)</h3><p><em>OpenFHE square operation of a ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.square` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhesub_inplace-heiropenfhesubinplaceop><code>openfhe.sub_inplace</code> (heir::openfhe::SubInPlaceOp)</h3><p><em>Performs in-place homomorphic subtraction, modifying lhs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.sub_inplace` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhesub-heiropenfhesubop><code>openfhe.sub</code> (heir::openfhe::SubOp)</h3><p><em>OpenFHE sub operation of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.sub` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code>, <code>SameOperandsAndResultRings</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table><h3 id=openfhesub_plain-heiropenfhesubplainop><code>openfhe.sub_plain</code> (heir::openfhe::SubPlainOp)</h3><p><em>OpenFHE sub operation of a ciphertext and a plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `openfhe.sub_plain` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AllCiphertextTypesMatch</code>, <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cryptoContext</code></td><td>The CryptoContext required to perform homomorphic operations in OpenFHE.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>A ciphertext type or A plaintext type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A ciphertext type or A plaintext type</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A ciphertext type</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-b18fea903e4651113f5317788f1491e1>13 - Polynomial</h1><h1 id=polynomial-dialect>&lsquo;polynomial&rsquo; Dialect</h1><p>The Polynomial dialect defines single-variable polynomial types and
operations.</p><p>The simplest use of <code>polynomial</code> is to represent mathematical operations in
a polynomial ring <code>R[x]</code>, where <code>R</code> is another MLIR type like <code>i32</code>.</p><p>More generally, this dialect supports representing polynomial operations in a
quotient ring <code>R[X]/(f(x))</code> for some statically fixed polynomial <code>f(x)</code>.
Two polyomials <code>p(x), q(x)</code> are considered equal in this ring if they have the
same remainder when dividing by <code>f(x)</code>. When a modulus is given, ring operations
are performed with reductions modulo <code>f(x)</code> and relative to the coefficient ring
<code>R</code>.</p><p>Examples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A constant polynomial in a ring with i32 coefficients and no polynomial modulus
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%a</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>3x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A constant polynomial in a ring with i32 coefficients, modulo (x^1024 + 1)
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#modulus</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#modulus</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%a</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>3x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A constant polynomial in a ring with i32 coefficients, with a polynomial
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// modulus of (x^1024 + 1) and a coefficient modulus of 17.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#modulus</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>coeff_ty =</span> <span style=color:#000;font-weight:700>!</span>mod_arith<span style=color:#000;font-weight:700>.</span>int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>17</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#000;font-weight:700>!</span>coeff_ty<span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#modulus</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%a</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>3x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h2 id=polynomial-attributes>Polynomial attributes</h2><h3 id=chebyshevpolynomialattr>ChebyshevPolynomialAttr</h3><p><em>An attribute containing a single-variable polynomial with float coefficients in the Chebyshev basis</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.chebyshev_polynomial&lt;
  ArrayAttr   # coefficients
&gt;
</code></pre><p>This attribute represents a single-variable polynomial with double
precision floating point coefficients, represented in the basis of
Chebyshev polynomials of the first kind.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.chebyshev_polynomial</span><span style=color:#000;font-weight:700>&lt;[</span><span style=color:#0000cf;font-weight:700>1.0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2.0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3.0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4.0</span><span style=color:#000;font-weight:700>]&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>coefficients</td><td style=text-align:center><code>ArrayAttr</code></td><td></td></tr></tbody></table><h3 id=floatpolynomialattr>FloatPolynomialAttr</h3><p><em>An attribute containing a single-variable polynomial with double precision floating point coefficients</em></p><p>A polynomial attribute represents a single-variable polynomial with double
precision floating point coefficients.</p><p>The polynomial must be expressed as a list of monomial terms, with addition
or subtraction between them. The choice of variable name is arbitrary, but
must be consistent across all the monomials used to define a single
attribute. The order of monomial terms is arbitrary, each monomial degree
must occur at most once.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.float_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>0.5</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>1.5</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>polynomial</td><td style=text-align:center><code>FloatPolynomial</code></td><td></td></tr></tbody></table><h3 id=intpolynomialattr>IntPolynomialAttr</h3><p><em>An attribute containing a single-variable polynomial with integer coefficients</em></p><p>A polynomial attribute represents a single-variable polynomial with integer
coefficients, which is used to define the modulus of a <code>RingAttr</code>, as well
as to define constants and perform constant folding for <code>polynomial</code> ops.</p><p>The polynomial must be expressed as a list of monomial terms, with addition
or subtraction between them. The choice of variable name is arbitrary, but
must be consistent across all the monomials used to define a single
attribute. The order of monomial terms is arbitrary, each monomial degree
must occur at most once.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>polynomial</td><td style=text-align:center><code>::mlir::heir::polynomial::IntPolynomial</code></td><td></td></tr></tbody></table><h3 id=primitiverootattr>PrimitiveRootAttr</h3><p><em>An attribute containing an integer and its degree as a root of unity</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.primitive_root&lt;
  ::mlir::IntegerAttr,   # value
  ::mlir::IntegerAttr   # degree
&gt;
</code></pre><p>A primitive root attribute stores an integer root <code>value</code> and an integer
<code>degree</code>, corresponding to a primitive root of unity of the given degree in
an unspecified ring.</p><p>This is used as an attribute on <code>polynomial.ntt</code> and <code>polynomial.intt</code> ops
to specify the root of unity used in lowering the transform.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.primitive_root</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>value=</span><span style=color:#0000cf;font-weight:700>123</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> degree <span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>7</span> <span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td></td></tr><tr><td style=text-align:center>degree</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td></td></tr></tbody></table><h3 id=ringattr>RingAttr</h3><p><em>An attribute specifying a polynomial ring</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.ring&lt;
  Type,   # coefficientType
  ::mlir::heir::polynomial::IntPolynomialAttr   # polynomialModulus
&gt;
</code></pre><p>A ring describes the domain in which polynomial arithmetic occurs. The ring
attribute in <code>polynomial</code> represents the more specific case of polynomials
with a single indeterminate; whose coefficients can be represented by
another MLIR type (<code>coefficientType</code>).</p><p>All semantics pertaining to arithmetic in the ring must be owned by the
coefficient type. For example, if the polynomials are with integer
coefficients taken modulo a prime $p$, then <code>coefficientType</code> must be a
type that represents integers modulo $p$, such as <code>mod_arith&lt;p></code>.</p><p>Additionally, a polynomial ring may specify a <code>polynomialModulus</code>, which
converts polynomial arithmetic to the analogue of modular integer
arithmetic, where each polynomial is represented as its remainder when
dividing by the modulus. For single-variable polynomials, a polynomial
modulus is always specified via a single polynomial.</p><p>An expressive example is polynomials with i32 coefficients, whose
coefficients are taken modulo <code>2**32 - 5</code>, with a polynomial modulus of
<code>x**1024 - 1</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly_mod</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>-1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly_mod</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>...</span> <span style=color:#000;font-weight:700>:</span> polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>In this case, the value of a polynomial is always &ldquo;converted&rdquo; to a
canonical form by applying repeated reductions by setting <code>x**1024 = 1</code>
and simplifying.</p><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>coefficientType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>polynomialModulus</td><td style=text-align:center><code>::mlir::heir::polynomial::IntPolynomialAttr</code></td><td></td></tr></tbody></table><h3 id=typedchebyshevpolynomialattr>TypedChebyshevPolynomialAttr</h3><p><em>A typed chebyshev_polynomial</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.typed_chebyshev_polynomial&lt;
  ::mlir::Type,   # type
  ::mlir::heir::polynomial::ChebyshevPolynomialAttr   # value
&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>poly_ty =</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring=</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> float<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1.4</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4.5</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span><span style=display:flex><span><span style=color:#000>#poly_verbose</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.typed_chebyshev_polynomial</span><span style=color:#000;font-weight:700>&lt;[</span><span style=color:#0000cf;font-weight:700>1.4</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4.5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>6.0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>7.0</span><span style=color:#000;font-weight:700>]&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span></code></pre></div><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::heir::polynomial::ChebyshevPolynomialAttr</code></td><td></td></tr></tbody></table><h3 id=typedfloatpolynomialattr>TypedFloatPolynomialAttr</h3><p><em>A typed float_polynomial</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.typed_float_polynomial&lt;
  ::mlir::Type,   # type
  ::mlir::heir::polynomial::FloatPolynomialAttr   # value
&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>poly_ty =</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring=</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> float<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1.4</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4.5</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span><span style=display:flex><span><span style=color:#000>#poly_verbose</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.typed_float_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1.4</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4.5</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span></code></pre></div><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::heir::polynomial::FloatPolynomialAttr</code></td><td></td></tr></tbody></table><h3 id=typedintpolynomialattr>TypedIntPolynomialAttr</h3><p><em>A typed int_polynomial</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.typed_int_polynomial&lt;
  ::mlir::Type,   # type
  ::mlir::heir::polynomial::IntPolynomialAttr   # value
&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>poly_ty =</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring=</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1 x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span><span style=display:flex><span><span style=color:#000>#poly_verbose</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.typed_int_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1 x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span></code></pre></div><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::heir::polynomial::IntPolynomialAttr</code></td><td></td></tr></tbody></table><h2 id=polynomial-types>Polynomial types</h2><h3 id=polynomialtype>PolynomialType</h3><p><em>An element of a polynomial ring.</em></p><p>Syntax:</p><pre tabindex=0><code>!polynomial.polynomial&lt;
  ::mlir::heir::polynomial::RingAttr   # ring
&gt;
</code></pre><p>A type for polynomials in a polynomial quotient ring.</p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td>an attribute specifying a polynomial ring</td></tr></tbody></table><h2 id=polynomial-ops>Polynomial ops</h2><h3 id=polynomialadd-heirpolynomialaddop><code>polynomial.add</code> (heir::polynomial::AddOp)</h3><p><em>Addition operation between polynomials.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.add` operands attr-dict `:` type($result)
</code></pre><p>Performs polynomial addition on the operands. The operands may be single
polynomials or containers of identically-typed polynomials, i.e., polynomials
from the same underlying ring with the same coefficient types.</p><p>This op is defined to occur in the ring defined by the ring attribute of
the two operands, meaning the arithmetic is taken modulo the
polynomialModulus of the ring as well as modulo any semantics defined by
the coefficient type.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// add two polynomials modulo x^1024 - 1
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> int<span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>5</span> <span style=color:#a40000>-</span> <span style=color:#000;font-weight:700>x</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>add <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialconstant-heirpolynomialconstantop><code>polynomial.constant</code> (heir::polynomial::ConstantOp)</h3><p><em>Define a constant polynomial via an attribute.</em></p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>int_poly_ty =</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring=</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>int_poly_ty
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>float_poly_ty =</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring=</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> float<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>0.5</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>1.3e06</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>float_poly_ty
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>a typed float_polynomial or a typed int_polynomial or a typed chebyshev_polynomial</td></tr></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialeval-heirpolynomialevalop><code>polynomial.eval</code> (heir::polynomial::EvalOp)</h3><p><em>Evaluate a static polynomial attribute at a given SSA value.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.eval` $polynomial `,` $value attr-dict `:` type($value)
</code></pre><p>Evaluates the result of a polynomial specified as a static attribute at
a given SSA value. The result represents the evaluation of the
polynomial at the input value and produces a corresponding scalar
value.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>poly_ty =</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring=</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.typed_int_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span><span style=display:flex><span><span style=color:#000>%x</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%result</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>eval <span style=color:#000>#poly</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%x</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span></code></pre></div><p>The coefficient type of the polynomial does not necessarily need to be
the same as the scalar input type. For example, one may evaluate a
square matrix in a polynomial, because the scalar-matrix operation is
well-defined. It is the responsibility of the lowering to determine
if the input is compatible with the polynomial coefficient type.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>polynomial</code></td><td>::mlir::Attribute</td><td>a typed float_polynomial or a typed int_polynomial or a typed chebyshev_polynomial</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=polynomialfrom_tensor-heirpolynomialfromtensorop><code>polynomial.from_tensor</code> (heir::polynomial::FromTensorOp)</h3><p><em>Creates a polynomial from integer coefficients stored in a tensor.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.from_tensor` $input attr-dict `:` type($input) `-&gt;` type($output)
</code></pre><p><code>polynomial.from_tensor</code> creates a polynomial value from a tensor of coefficients.
The input tensor must list the coefficients in degree-increasing order.</p><p>The input one-dimensional tensor may have size at most the degree of the
ring&rsquo;s polynomialModulus generator polynomial, with smaller dimension implying that
all higher-degree terms have coefficient zero.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%two</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%five</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%coeffs</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>from_elements <span style=color:#000>%two</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%two</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%five</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>3x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%poly</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>from_tensor <span style=color:#000>%coeffs</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>3x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>ranked tensor of any type values</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialintt-heirpolynomialinttop><code>polynomial.intt</code> (heir::polynomial::INTTOp)</h3><p><em>Computes the reverse integer Number Theoretic Transform (NTT).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.intt` $input attr-dict `:` qualified(type($input)) `-&gt;` type($output)
</code></pre><p><code>polynomial.intt</code> computes the reverse integer Number Theoretic Transform
(INTT) on the input tensor. This is the inverse operation of the
<code>polynomial.ntt</code> operation.</p><p>The input tensor is interpreted as a point-value representation of the
output polynomial at powers of a primitive <code>n</code>-th root of unity (see
<code>polynomial.ntt</code>). The ring of the polynomial is taken from the required
encoding attribute of the tensor.</p><p>The choice of primitive root may be optionally specified.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>root</code></td><td>::mlir::heir::polynomial::PrimitiveRootAttr</td><td>an attribute containing an integer and its degree as a root of unity</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>ranked tensor of Integer type with modular arithmetic values</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialkey_switch_inner-heirpolynomialkeyswitchinnerop><code>polynomial.key_switch_inner</code> (heir::polynomial::KeySwitchInnerOp)</h3><p><em>Key switch on an RNS polynomial component</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.key_switch_inner` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Generates a linear ciphertext that, when added to a ciphertext encrypted
under the input key, switches it to a ciphertext encrypted under the output
key.</p><p>This operation is intended to be an internal implementation detail of
higher-level ciphertext operations such as <code>ckks.relinearize</code>, isolated
here for reuse among multiple op lowerings.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>An element of a polynomial ring.</td></tr><tr><td style=text-align:center><code>keySwitchingKey</code></td><td>ranked tensor of An element of a polynomial ring. values</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>constantOutput</code></td><td>An element of a polynomial ring.</td></tr><tr><td style=text-align:center><code>linearOutput</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialleading_term-heirpolynomialleadingtermop><code>polynomial.leading_term</code> (heir::polynomial::LeadingTermOp)</h3><p><em>Compute the leading term of the polynomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.leading_term` operands attr-dict `:` type($input) `-&gt;` `(` type($degree) `,` type($coefficient) `)`
</code></pre><p>The degree of a polynomial is the largest $k$ for which the coefficient
<code>a_k</code> of <code>x^k</code> is nonzero. The leading term is the term <code>a_k * x^k</code>, which
this op represents as a pair of results. The first is the degree <code>k</code> as an
index, and the second is the coefficient, whose type matches the
coefficient type of the polynomial&rsquo;s ring attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>leading_term <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>degree</code></td><td>index</td></tr><tr><td style=text-align:center><code>coefficient</code></td><td>any type</td></tr></tbody></table><h3 id=polynomialmod_switch-heirpolynomialmodswitchop><code>polynomial.mod_switch</code> (heir::polynomial::ModSwitchOp)</h3><p><em>Change the coefficient type of a polynomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.mod_switch` $input attr-dict `:` type($input) `to` type($output)
</code></pre><p><code>polynomial.mod_switch</code> changes the coefficient type of a polynomial.</p><p>The two polynomials must have the same polynomialModulus.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring32</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring64</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i64</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%poly</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>mod_switch <span style=color:#000>%coeffs</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring64</span><span style=color:#000;font-weight:700>&gt;</span> to <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialmonic_monomial_mul-heirpolynomialmonicmonomialmulop><code>polynomial.monic_monomial_mul</code> (heir::polynomial::MonicMonomialMulOp)</h3><p><em>Multiply a polynomial by a monic monomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.monic_monomial_mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Multiply a polynomial by a monic monomial, meaning a polynomial of the form
<code>1 * x^k</code> for an index operand <code>k</code>.</p><p>In some special rings of polynomials, such as a ring of polynomials
modulo <code>x^n - 1</code>, <code>monomial_mul</code> can be interpreted as a cyclic shift of
the coefficients of the polynomial. For some rings, this results in
optimized lowerings that involve rotations and rescaling of the
coefficients of the input.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>monomialDegree</code></td><td>index</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialmonomial-heirpolynomialmonomialop><code>polynomial.monomial</code> (heir::polynomial::MonomialOp)</h3><p><em>Create a polynomial that consists of a single monomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.monomial` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Construct a polynomial that consists of a single monomial term, from its
degree and coefficient as dynamic inputs.</p><p>The coefficient type of the output polynomial&rsquo;s ring attribute must match
the <code>coefficient</code> input type.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%deg</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>1023</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span><span style=color:#000>%five</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>monomial <span style=color:#000>%five</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%deg</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>coefficient</code></td><td>any type</td></tr><tr><td style=text-align:center><code>degree</code></td><td>index</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialmul-heirpolynomialmulop><code>polynomial.mul</code> (heir::polynomial::MulOp)</h3><p><em>Multiplication operation between polynomials.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.mul` operands attr-dict `:` type($result)
</code></pre><p>Performs polynomial multiplication on the operands. The operands may be single
polynomials or containers of identically-typed polynomials, i.e., polynomials
from the same underlying ring with the same coefficient types.</p><p>This op is defined to occur in the ring defined by the ring attribute of
the two operands, meaning the arithmetic is taken modulo the
polynomialModulus of the ring as well as modulo any semantics defined by
the coefficient type.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// multiply two polynomials modulo x^1024 - 1
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> int<span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>5</span> <span style=color:#a40000>-</span> <span style=color:#000;font-weight:700>x</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>mul <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialmul_scalar-heirpolynomialmulscalarop><code>polynomial.mul_scalar</code> (heir::polynomial::MulScalarOp)</h3><p><em>Multiplication by a scalar of the field.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.mul_scalar` operands attr-dict `:` type($polynomial) `,` type($scalar)
</code></pre><p>Multiplies the polynomial operand&rsquo;s coefficients by a given scalar value.
The <code>scalar</code> input must have the same type as the polynomial ring&rsquo;s
coefficientType.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// multiply two polynomials modulo x^1024 - 1
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>3</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>mul_scalar <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>polynomial</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>scalar</code></td><td>any type</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialntt-heirpolynomialnttop><code>polynomial.ntt</code> (heir::polynomial::NTTOp)</h3><p><em>Computes point-value tensor representation of a polynomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.ntt` $input attr-dict `:` qualified(type($input)) `-&gt;` type($output)
</code></pre><p><code>polynomial.ntt</code> computes the forward integer Number Theoretic Transform
(NTT) on the input polynomial. It returns a tensor containing a point-value
representation of the input polynomial. The output tensor has shape equal
to the degree of the ring&rsquo;s <code>polynomialModulus</code>. The polynomial&rsquo;s RingAttr
is embedded as the encoding attribute of the output tensor.</p><p>Given an input polynomial <code>F(x)</code> over a ring whose <code>polynomialModulus</code> has
degree <code>n</code>, and a primitive <code>n</code>-th root of unity <code>omega_n</code>, the output is
the list of $n$ evaluations</p><p><code>f[k] = F(omega[n]^k) ; k = {0, ..., n-1}</code></p><p>The choice of primitive root may be optionally specified.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>root</code></td><td>::mlir::heir::polynomial::PrimitiveRootAttr</td><td>an attribute containing an integer and its degree as a root of unity</td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of Integer type with modular arithmetic values</td></tr></tbody></table><h3 id=polynomialsub-heirpolynomialsubop><code>polynomial.sub</code> (heir::polynomial::SubOp)</h3><p><em>Subtraction operation between polynomials.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.sub` operands attr-dict `:` type($result)
</code></pre><p>Performs polynomial subtraction on the operands. The operands may be single
polynomials or containers of identically-typed polynomials, i.e., polynomials
from the same underlying ring with the same coefficient types.</p><p>This op is defined to occur in the ring defined by the ring attribute of
the two operands, meaning the arithmetic is taken modulo the
polynomialModulus of the ring as well as modulo any semantics defined by
the coefficient type.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// subtract two polynomials modulo x^1024 - 1
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> int<span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>5</span> <span style=color:#a40000>-</span> <span style=color:#000;font-weight:700>x</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>sub <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialto_tensor-heirpolynomialtotensorop><code>polynomial.to_tensor</code> (heir::polynomial::ToTensorOp)</h3><p><em>Creates a tensor containing the coefficients of a polynomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.to_tensor` $input attr-dict `:` type($input) `-&gt;` type($output)
</code></pre><p><code>polynomial.to_tensor</code> creates a dense tensor value containing the
coefficients of the input polynomial. The output tensor contains the
coefficients in degree-increasing order.</p><p>Operations that act on the coefficients of a polynomial, such as extracting
a specific coefficient or extracting a range of coefficients, should be
implemented by composing <code>to_tensor</code> with the relevant <code>tensor</code> dialect
ops.</p><p>The output tensor has shape equal to the degree of the polynomial ring
attribute&rsquo;s polynomialModulus, including zeroes.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%two</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%five</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>5</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%coeffs</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>from_elements <span style=color:#000>%two</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%two</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%five</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>3x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%poly</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>from_tensor <span style=color:#000>%coeffs</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>3x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%tensor</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span>to_tensor <span style=color:#000>%poly</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1024x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of any type values</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c9ea40a8d17399f57cdd3c18b53cedef>14 - Random</h1><h1 id=random-dialect>&lsquo;random&rsquo; Dialect</h1><p>The <code>random</code> dialect contains operations used to generate random numbers.</p><h2 id=random-types>Random types</h2><h3 id=distributiontype>DistributionType</h3><p><em>A random distribution type</em></p><p>Syntax:</p><pre tabindex=0><code>!random.distribution&lt;
  ::mlir::heir::random::Distribution   # distribution_type
&gt;
</code></pre><p>A generic type, representing a specific random distribution type of either
uniform or gaussian as an attribute ($distribution_type).</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>distribution_type</td><td style=text-align:center><code>::mlir::heir::random::Distribution</code></td><td></td></tr></tbody></table><h3 id=prngtype>PRNGType</h3><p><em>A pseudorandom number generator type</em></p><p>Syntax: <code>!random.prng</code></p><p>A type that provides pseudorandom number generator.</p><h2 id=random-ops>Random ops</h2><h3 id=randomdiscrete_gaussian_distribution-heirrandomdiscretegaussiandistributionop><code>random.discrete_gaussian_distribution</code> (heir::random::DiscreteGaussianDistributionOp)</h3><p><em>Initializes the Discrete Gaussian Distribution</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `random.discrete_gaussian_distribution` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Initializes the Discrete Gaussian Distribution. The distribution is
initialized with a mean and a standard deviation and pseudorandom generator
that provides the source of the randomness.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mean</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr><tr><td><code>stddev</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value whose value is non-negative</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A pseudorandom number generator type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A random distribution type</td></tr></tbody></table><h3 id=randomdiscrete_uniform_distribution-heirrandomdiscreteuniformdistributionop><code>random.discrete_uniform_distribution</code> (heir::random::DiscreteUniformDistributionOp)</h3><p><em>Initializes the Discrete Uniform Distribution</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `random.discrete_uniform_distribution` $input `{` `range` `=` `[` $min `,` $max `]` `}` attr-dict `:` `(` qualified(type($input)) `)` `-&gt;` type($output)
</code></pre><p>Initializes the Discrete Uniform Distribution. The distribution is
initialized with a minimum and a maximum value and pseudo random generator
that provides the source of the randomness. The distribution is inclusive of
the minimum and exclusive of the maximum.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>min</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr><tr><td><code>max</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A pseudorandom number generator type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A random distribution type</td></tr></tbody></table><h3 id=randominit_prng-heirrandominitop><code>random.init_prng</code> (heir::random::InitOp)</h3><p><em>Initializes the pseudorandom number generator with a seed.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `random.init_prng` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Initializes the PRNG with a seed. The seed is dynamically provided due to
protocols that agree on shared randomness. The PRNG is used to initialized
the random distributions such as the discrete gaussian distribution and the
discrete uniform distribution. This initialization also takes as input a
number of bits that are generated for each number value sampled (num_bits).
For instance, a num_bits of 32 will mean that distributions will generate a
32-bit integer value. We expect that the seed initialization is done statically
and globally once per thread for all distributions; however, if multiple threads are
generating randomness, then seed initialization should be done per thread;
otherwise there is no guarantee of consistent behavior. Thread safety is so
far not considered.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>num_bits</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>seed</code></td><td>index</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A pseudorandom number generator type</td></tr></tbody></table><h3 id=randomsample-heirrandomsampleop><code>random.sample</code> (heir::random::SampleOp)</h3><p><em>Samples from a distribution</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `random.sample` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Samples from the distribution to obtain a random value
or tensor of values.</p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A random distribution type</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h2 id=random-additional-definitions>Random additional definitions</h2><h3 id=distribution>Distribution</h3><p><em>An enum attribute representing a random distribution</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>uniform</td><td style=text-align:center><code>0</code></td><td>uniform</td></tr><tr><td style=text-align:center>gaussian</td><td style=text-align:center><code>1</code></td><td>gaussian</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-aeae60b865ac85372556b396a5a052ce>15 - RNS</h1><h1 id=rns-dialect>&lsquo;rns&rsquo; Dialect</h1><p>The <code>rns</code> dialect represents types and ops related to residue number
system (RNS) representations of ring-like types, such as integers or
polynomials decomposed from high-bit width to lower-bit-width prime
moduli. Sometimes RNS is referred to as CRT, for &ldquo;Chinese Remainder
Theorem.&rdquo;</p><p>This dialect is intended to be as generic as possible in terms of its
interaction with standard MLIR. However, because of upstream MLIR
constraints, we do not have the ability to override, say, <code>arith.addi</code>
to operate on an <code>rns</code> type. So such situations require dedicated ops,
canonicalization patterns, etc.</p><h2 id=rns-types>RNS types</h2><h3 id=rnstype>RNSType</h3><p><em>A residue number system representation</em></p><p>Syntax:</p><pre tabindex=0><code>!rns.rns&lt;
  ::llvm::ArrayRef&lt;mlir::Type&gt;   # basisTypes
&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>basisTypes</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::Type></code></td><td></td></tr></tbody></table><h2 id=rns-ops>RNS ops</h2><h3 id=rnsextract_slice-heirrnsextractsliceop><code>rns.extract_slice</code> (heir::rns::ExtractSliceOp)</h3><p><em>Extracts a slice of RNS limbs</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rns.extract_slice` $input attr-dict `:` type($input) `-&gt;` type($output)
</code></pre><p>Given an RNS-typed value with $k$ basis types (limbs), extract the slice of
RNS components starting at <code>start</code> and having size <code>size</code>.</p><p>The result type is an RNS type containing the subset of basis types
corresponding to the extracted slice. This is useful for operations like
truncating or partitioning a modulus chain.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>start</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>rns-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>rns-like</td></tr></tbody></table><h2 id=rns-additional-definitions>RNS additional definitions</h2><h1 id=typeinterface-definitions>TypeInterface definitions</h1><h2 id=rnsbasistypeinterface-rnsbasistypeinterface>RNSBasisTypeInterface (<code>RNSBasisTypeInterface</code>)</h2><p>This interface is required for a type to be used as a parameter
to an <code>rns</code> type.</p><h3 id=methods>Methods:</h3><h4 id=iscompatiblewith><code>isCompatibleWith</code></h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#204a87;font-weight:700>bool</span> <span style=color:#000>isCompatibleWith</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>mlir</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Type</span> <span style=color:#000>otherRnsBasisType</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>Returns true if this type is compatible with another type in the
same RNS basis. In particular, the set of types used for a single
RNS basis are never equal as types, but instead have some common
attribute that must be checked here. For example, an RNS type where
the basis types are polynomials would return true if the two types
are both polynomial types, even if they have different coefficient
moduli.</p><p>Another example is using mod arith types as the basis types, where
by the nature of chinese reminder theorem, it is required that
the modulus of them must be mutually coprime.</p><p><code>isCompatibleWith</code> must be commutative, in the sense
that <code>type1.isCompatibleWith(type2)</code> if and only if
<code>type2.isCompatibleWith(type1)</code>.</p><p>NOTE: This method <em>must</em> be implemented by the user.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f7ffac8ba93b73b8a62e185ec8643d63>16 - Secret</h1><h1 id=secret-dialect>&lsquo;secret&rsquo; Dialect</h1><p>Secret is a dialect for computations that operate on encrypted data.</p><p>Secret is intended to serve as a scheme-agnostic front-end for the HEIR
ecosystem of dialects. It is supposed to be fully interoperable with the
rest of MLIR via secret.generic, while lower-level HEIR dialects would have
custom types for arithmetic on secret integers of various bit widths.</p><h2 id=secret-attributes>Secret attributes</h2><h3 id=kernelattr>KernelAttr</h3><p><em>An annotation describing an implementation kernel for a given op.</em></p><p>Syntax:</p><pre tabindex=0><code>#secret.kernel&lt;
  ::mlir::heir::KernelName,   # name
  bool   # force
&gt;
</code></pre><p>This attribute is used for two purposes:</p><ol><li>To allow the input IR to annotate fixed kernels on ops that the rest of the
compiler must respect.</li><li>To allow the layout optimization pipeline to materialize its kernel selection
decisions to the IR.</li></ol><p>The <code>name</code> field corresponds to an internally-defined kernel name, and if
<code>force</code> is set to <code>true</code>, then the kernel may not be overridden by HEIR&rsquo;s
internal passes.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::heir::KernelName</code></td><td></td></tr><tr><td style=text-align:center>force</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h2 id=secret-types>Secret types</h2><h3 id=secrettype>SecretType</h3><p><em>A secret value</em></p><p>Syntax:</p><pre tabindex=0><code>!secret.secret&lt;
  Type   # valueType
&gt;
</code></pre><p>A generic wrapper around another MLIR type, representing an encrypted value
but not specifying the manner of encryption. This is useful in HEIR because
the compiler may choose various details of the FHE scheme based on the
properties of the input program, the backend target hardware, and cost
models of the various passes.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>valueType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h2 id=secret-ops>Secret ops</h2><h3 id=secretcast-heirsecretcastop><code>secret.cast</code> (heir::secret::CastOp)</h3><p><em>A placeholder cast from one secret type to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.cast` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
</code></pre><p>A <code>cast</code> operation represents a type cast from one secret type to another,
that is used to enable the intermixing of various equivalent secret types
before a lower-level FHE scheme has been chosen.</p><p>For example, <code>secret.cast</code> can be used to convert a <code>secret&lt;i8></code> to a
<code>secret&lt;tensor&lt;8xi1>></code> as a compatibility layer between boolean and
non-boolean parts of a program. The pass that later lowers the IR to
specific FHE schemes would need to replace these casts with appropriate
scheme-specific operations, and it is left to those later passes to
determine which casts are considered valid.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%result</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>cast <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span> to <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i1</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%result2</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>cast <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span> to <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>2x</span><span style=color:#204a87;font-weight:700>i4</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A secret value</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A secret value</td></tr></tbody></table><h3 id=secretconceal-heirsecretconcealop><code>secret.conceal</code> (heir::secret::ConcealOp)</h3><p><em>Convert a non-secret value into a secret</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.conceal` $cleartext attr-dict `:` qualified(type($cleartext)) `-&gt;` qualified(type($output))
</code></pre><p>Convert a value to a secret containing the same value.</p><p>This op represents a scheme-agnostic encryption operation, as well as a
&ldquo;trivial encryption&rdquo; operation which is needed for some FHE schemes. This
op is also useful for type materialization in the dialect conversion
framework.</p><p>Examples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%Y</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>conceal <span style=color:#000>%value</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cleartext</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A secret value</td></tr></tbody></table><h3 id=secretgeneric-heirsecretgenericop><code>secret.generic</code> (heir::secret::GenericOp)</h3><p><em>Lift a plaintext computation to operate on secrets.</em></p><p><code>secret.generic</code> lifts a plaintext computation to operate on one or more
secrets. The lifted computation is represented as a region containing a
single block terminated by <code>secret.yield</code>. The arguments of the <code>secret.generic</code>
may include one or more <code>!secret.secret</code> types. The arguments of the block
in the op&rsquo;s body correspond to the underlying plaintext types of the secrets.</p><p><code>secret.generic</code> is not isolated from above, so you may directly reference
values in the enclosing scope. This is required to support using
<code>secret.generic</code> inside of ops with <code>AffineScope</code>, while having the body
of the generic use the induction variables defined by the affine scope.</p><p>Basic examples:</p><p>Add two secret integers together</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%Z</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%X</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%Y</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%x</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%x</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span>
</span></span></code></pre></div><p>Add a secret value with a plaintext value. I.e., not all arguments to the
op need be secret.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%Z</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%X</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%Y</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%x</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%x</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span>
</span></span></code></pre></div><p>The same as above, but the plaintext op is not passed through the basic
block.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%y</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%Z</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%X</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%x</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%x</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%y</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%z</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;)</span>
</span></span></code></pre></div><p>Traits: <code>SingleBlockImplicitTerminator&lt;YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>OpAsmOpInterface</code>, <code>OperandAndResultAttrInterface</code>, <code>RegionBranchOpInterface</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=secretreveal-heirsecretrevealop><code>secret.reveal</code> (heir::secret::RevealOp)</h3><p><em>Convert a secret value into a non-secret</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.reveal` $input attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($cleartext))
</code></pre><p>Convert a secret into a non-secret containing the same value.</p><p>This op represents a scheme-agnostic decryption operation. This op is also
useful for target materialization in the dialect conversion framework.</p><p>Examples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%Y</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>reveal <span style=color:#000>%secret_value</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A secret value</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cleartext</code></td><td>any type</td></tr></tbody></table><h3 id=secretseparator-heirsecretseparatorop><code>secret.separator</code> (heir::secret::SeparatorOp)</h3><p><em>Convert a non-secret value into a secret</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.separator` attr-dict ($inputs^ `:` type($inputs))?
</code></pre><p>This operation is used as a separation boundary between logical subunits of
the module. This is used in conjunction with
<code>--secret-distribute-generic=distribute-through=secret.separator</code> to break a
generic around these separators and allow for optimization passes to
analyze and optimize the sub-units locally.</p><p>In order to allow bufferization of modules with this operation, we must
register a (bogus) memory effect that also prevents this operation from
being trivially dead during operation folding.</p><p>This operation also accepts operands, which act as boundaries between the
logical units. This enforces separation of memref and affine optimizations
between the subunits, preventing optimizations from removing the operand and
combining the two separated regions. The operand can be thought of as an
return value of the logical subunit.</p><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=secretyield-heirsecretyieldop><code>secret.yield</code> (heir::secret::YieldOp)</h3><p><em>Secret yield operation</em></p><p><code>secret.yield</code> is a special terminator operation for blocks inside regions
in <code>secret</code> generic ops. It returns the cleartext value of the
corresponding private computation to the immediately enclosing <code>secret</code>
generic op.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;GenericOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>variadic of any type</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ca9ddb02db7c0683037407c6f9eb1f2a>17 - TensorExt</h1><h1 id=tensor_ext-dialect>&rsquo;tensor_ext&rsquo; Dialect</h1><p>The <code>tensor_ext</code> dialect contains operations on plaintext tensors that
correspond to the computation model of certain FHE schemes, but are
unlikely to be upstreamed to MLIR due to their specificity to FHE.</p><h2 id=tensorext-attributes>TensorExt attributes</h2><h3 id=alignmentattr>AlignmentAttr</h3><p><em>An attribute describing padding and alignment of a tensor.</em></p><p>Syntax:</p><pre tabindex=0><code>#tensor_ext.alignment&lt;
  ::mlir::DenseI64ArrayAttr,   # in
  ::mlir::DenseI64ArrayAttr,   # out
  ::mlir::DenseI64ArrayAttr,   # insertedDims
  ::mlir::DenseI64ArrayAttr,   # padding
  TypedAttr   # paddingValue
&gt;
</code></pre><p>This attribute is used to describe how a data-semantic value is padded
and replicated to align its size before applying a ciphertext layout
(see <code>tensor_ext.layout</code>).</p><p>It describes transformations to be applied to an input tensor or scalar.</p><p>The <code>in</code> attribute describes the shape of the original value. An empty list
for <code>in</code> indicates a scalar value that must be materialized as a tensor.
The following transformations are applied to the input tensor.</p><ol><li>New unit dimensions are inserted to match the number of dimensions
of the output tensor. The <code>insertedDims</code> attribute is an array
specifying which axes in the output tensor are new unit dimensions. By
default no new dimensions are inserted.</li><li>Padding is applied. The <code>padding</code> attribute is an array with the same
size as the output tensor shape, which each entry denoting the number of
values to pad at the end of that axis. The <code>paddingValue</code> attribute
describes the value used for padding, and must be set if <code>padding</code> is set.</li><li>The padded result is replicated to fill the output tensor shape.</li></ol><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#repl</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.alignment</span><span style=color:#000;font-weight:700>&lt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>in =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>padding =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>paddingValue =</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>:</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>out =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>16</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>This indicates that the original input tensor is a <code>tensor&lt;7xi32></code>, and it
is being padded and replicated into a <code>tensor&lt;16xi32></code>. If the input tensor
has values <code>[1, 2, 3, 4, 5, 6, 7]</code> then the packed tensor contains the data
<code>[1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0]</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#repl</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.alignment</span><span style=color:#000;font-weight:700>&lt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>in =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>padding =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>paddingValue =</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>:</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>out =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>This indicates that the original input tensor is a <code>tensor&lt;3x10xi32></code>, and
it is being padded and replicated into a <code>tensor&lt;32x32xi32></code>. One row of
zeros and six columns of zeros are added to the input tensor, and then it
is repeated once along the column dimension and four times along the row
dimension to fill the 32x32 output tensor.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#repl</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.alignment</span><span style=color:#000;font-weight:700>&lt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>in =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>insertedDims =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>padding =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>paddingValue =</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>:</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>out =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>This indicates that the original input tensor is a <code>tensor&lt;10xi32></code>, and it
is being padded and replicated into a <code>tensor&lt;32x32xi32></code>. First a unit
dimension is inserted as the first axis, then zeros are padded along the
second axis to make a <code>tensor&lt;1x16xi32></code>. Finally, it is replicated twice
along the columns and 32 times along the rows to fill the 32x32 output
tensor.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#repl</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.alignment</span><span style=color:#000;font-weight:700>&lt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>in =</span> <span style=color:#000;font-weight:700>[],</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>insertedDims =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>out =</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>],</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>This indicates that the original input is a scalar such as <code>i32</code>, and it is
elevated to a <code>tensor&lt;1xi32></code> before being replicated to fill the
ciphertext shape.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>in</td><td style=text-align:center><code>::mlir::DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>out</td><td style=text-align:center><code>::mlir::DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>insertedDims</td><td style=text-align:center><code>::mlir::DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>padding</td><td style=text-align:center><code>::mlir::DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>paddingValue</td><td style=text-align:center><code>TypedAttr</code></td><td></td></tr></tbody></table><h3 id=layoutattr>LayoutAttr</h3><p><em>The description of the layout of a data-semantic tensor.</em></p><p>Syntax:</p><pre tabindex=0><code>#tensor_ext.layout&lt;
  ::mlir::AffineMap,   # map
  ::mlir::heir::tensor_ext::AlignmentAttr   # alignment
&gt;
</code></pre><p>This attribute describes how a data-semantic tensor is laid out
among a tensor of ciphertexts. The layout is described by an affine map
mapping the data-semantic tensor indices to the ciphertext tensor indices,
where the trailing affine map&rsquo;s result expressions mark the slot index
(or indices) of the ciphertext.</p><p>The layout may include optional padding and alignment of the data-semantic
tensor before the layout is applied. This would be required if, for
example, a <code>tensor&lt;4xi32></code> is to be laid out in a <code>tensor&lt;16xi32></code>
ciphertext tensor. The data-semantic tensor must be extended somehow to
fill the 16 slots. If an alignment attribute is not provided, then
lowerings may raise errors if there is no unambiguous way to align the
tensor.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>map</td><td style=text-align:center><code>::mlir::AffineMap</code></td><td></td></tr><tr><td style=text-align:center>alignment</td><td style=text-align:center><code>::mlir::heir::tensor_ext::AlignmentAttr</code></td><td></td></tr></tbody></table><h3 id=newlayoutattr>NewLayoutAttr</h3><p><em>The description of the layout of a data-semantic tensor.</em></p><p>Syntax:</p><pre tabindex=0><code>#tensor_ext.new_layout&lt;
  mlir::StringAttr   # layout
&gt;
</code></pre><p>This attribute describes how a data-semantic tensor is laid out among a
tensor of ciphertexts. The layout is described by an integer relation $(d,
s)$, where $d$ is a multiset of data-semantic tensor indices and $s$ is a
multiset of slot indices (or coefficient indices). The slot indices are
defined by two indices: the ciphertext index and the slot index in that
order. The elements of the relation are defined by a set of quasi-affine
constraints.</p><p>I.e., a point $((2, 3), (7, 0))$ in the relation says that the data entry
at index $(2, 3)$ is placed in slot 0 of ciphertext 7. This could be
defined as part of the relation by a constraint like <code>row + col + 2 - ct + slot = 0</code>.</p><p>The attribute stores a string representation of the integer relation,
which follows the ISL syntax for <code>isl_basic_map</code>. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#vec_layout</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.new_layout</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;{ [i0] -&gt; [ct, slot] : (i0 - slot) mod 1024 = 7 and i0 &gt;= 0 and 0 &gt;= i0 and slot &gt;= 0 and 1023 &gt;= slot and ct = 0 }&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>#mat_layout</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.new_layout</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;{ [row, col] -&gt; [ct, slot] : (slot - row) mod 512 = 0 and (ct + slot - col) mod 512 = 0 and row &gt;= 0 and col &gt;= 0 and ct &gt;= 0 and slot &gt;= 0 and 1023 &gt;= slot and 511 &gt;= ct and 511 &gt;= row and 511 &gt;= col }&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Example with local (existential) variables.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#layout</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.new_layout</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;{[d0] -&gt; [ct, slot] : exists d3, d4 : -ct + d3 = 0 and d0 - d4 * 1024 = 0 and -d0 + 31 &gt;= 0 and d0 &gt;= 0 and ct &gt;= 0 and slot &gt;= 0 and -slot + 1023 &gt;= 0 and -d0 + d3 * 1024 + 1023 &gt;= 0 and d0 - d3 * 1024 &gt;= 0 and -d0 + d4 * 1024 + 1023 &gt;= 0 and d0 - d4 * 1024 &gt;= 0 }&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>layout</td><td style=text-align:center><code>mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=originaltypeattr>OriginalTypeAttr</h3><p><em>The original type of a secret tensor whose layout has been converted to ciphertext semantics.</em></p><p>Syntax:</p><pre tabindex=0><code>#tensor_ext.original_type&lt;
  ::mlir::Type,   # originalType
  ::mlir::Attribute   # layout
&gt;
</code></pre><p>This attribute is used to retain the original type of a secret tensor after
its conversion to ciphertext semantics, i.e. after applying any padding or
alignment to fill ciphertext data types. For example, if a
<code>!secret.secret&lt;tensor&lt;32xi8>></code> is laid out in a ciphertext with
1024 slots, the new type would be <code>!secret.secret&lt;tensor&lt;1024xi8>></code>
with attribute <code>tensor_ext.original_type&lt;!secret.secret&lt;tensor&lt;32xi8>></code>.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>originalType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>layout</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h2 id=tensorext-ops>TensorExt ops</h2><h3 id=tensor_extassign_layout-heirtensor_extassignlayoutop><code>tensor_ext.assign_layout</code> (heir::tensor_ext::AssignLayoutOp)</h3><p><em>Assign a layout to a plaintext tensor or scalar.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tensor_ext.assign_layout` operands attr-dict `:` type($output)
</code></pre><p>This op allows the ingestion of a plaintext value into the layout system.
For example, ops like <code>linalg.reduce</code>, require a tensor input to represent
initial values. These will generally be created by an <code>arith.constant</code> or
<code>tensor.empty</code> op, which does not have secret results. Lowerings will
convert this to a packed plaintext, so that the subsequent ops can be
lowered as ciphertext-plaintext ops.</p><p>This op is inserted by layout selection passes.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layout</code></td><td>::mlir::Attribute</td><td>The description of the layout of a data-semantic tensor. or The description of the layout of a data-semantic tensor.</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=tensor_extconvert_layout-heirtensor_extconvertlayoutop><code>tensor_ext.convert_layout</code> (heir::tensor_ext::ConvertLayoutOp)</h3><p><em>Convert from one layout to another.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tensor_ext.convert_layout` operands attr-dict `:` type($output)
</code></pre><p>This op represents the conversion of a value from one packed layout to
another. This is implemented via a &ldquo;shift network&rdquo; of ciphertext rotations,
plaintext masks (ciphertext-plaintext multiplications), and additions.</p><p>This op is inserted by layout selection passes.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>from_layout</code></td><td>::mlir::Attribute</td><td>The description of the layout of a data-semantic tensor. or The description of the layout of a data-semantic tensor.</td></tr><tr><td><code>to_layout</code></td><td>::mlir::Attribute</td><td>The description of the layout of a data-semantic tensor. or The description of the layout of a data-semantic tensor.</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=tensor_extpermute-heirtensor_extpermuteop><code>tensor_ext.permute</code> (heir::tensor_ext::PermuteOp)</h3><p><em>Permute a tensor by a static permutation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tensor_ext.permute` operands attr-dict `:` type($input)
</code></pre><p>This op represents a permutation of a tensor.</p><p>This is lowered from a <code>convert_layout</code> op, and is implemented in terms of
<code>rotate</code> operations.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>permutation</code></td><td>::mlir::Attribute</td><td>64-bit integer elements attribute or The description of the layout of a data-semantic tensor.</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>ranked tensor of any type values</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of any type values</td></tr></tbody></table><h3 id=tensor_extrotate_and_reduce-heirtensor_extrotateandreduceop><code>tensor_ext.rotate_and_reduce</code> (heir::tensor_ext::RotateAndReduceOp)</h3><p><em>Performs a reduction of a periodically rotated tensor.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tensor_ext.rotate_and_reduce` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This op reduces products of a plaintext with a periodically rotated
tensor.</p><p>In almost full generality, the reduction performed is</p><p>[
\sum_{i \in [0, n]} p(P, T<em>i) \cdot rotate(v, T</em>i)
]</p><p>where $f$ is a function, $p(P, T<em>i)$ is a function of a plaintext $P$ and
$rotate(v, T</em>i)$ is a rotation of the ciphertext $v$ with period $T$. The
operation takes as input the ciphertext vector $v$, the period $T$, the
number of reductions $n$, and a tensor of plaintext values <code>[p(P, 0), p(P, T), ..., p(P, T*(n-1))]</code>.</p><p>This can be used to implement a matrix vector product that uses a
Halevi-Shoup diagonalization of the plaintext matrix. In this case, the
reduction is</p><p>[
\sum_{i \in [0, n]} P(i) \cdot rotate(v, i)
]</p><p>where $P(i)$ is the $i$th diagonal of the plaintext matrix and the period
$T$ is $1$.</p><p>An accumulation of the ciphertext slots is also handled via this operation
by omitting the plaintext $p(P, T*i)$ argument and using a period of 1 with
<code>n = |v|</code> so that the reduction is simply a sum of all rotation of the
ciphertext.</p><p>If <code>reduceOp</code> is set to an MLIR operation name (e.g., <code>arith.mulf</code>), then
the reduction operation is modified to use that operation instead of a sum.
The chosen op must be one of <code>arith.muli</code>, <code>arith.mulf</code>, <code>arith.addi</code>,
or <code>arith.addf</code>.</p><p>Efficient lowerings of this operation can use the Baby-Step / Giant-Step
approach from <a href=https://eprint.iacr.org/2018/244.pdf>Faster Homomorphic Linear Transformations in
HElib</a> to reduce the number of
ciphertext rotations.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>period</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>steps</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>reduceOp</code></td><td>::mlir::StringAttr</td><td>An Attribute containing a string</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tensor</code></td><td>ranked tensor of any type values</td></tr><tr><td style=text-align:center><code>plaintexts</code></td><td>ranked tensor of any type values</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of any type values</td></tr></tbody></table><h3 id=tensor_extrotate-heirtensor_extrotateop><code>tensor_ext.rotate</code> (heir::tensor_ext::RotateOp)</h3><p><em>Rotate a tensor some number of indices left.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tensor_ext.rotate` operands attr-dict `:` qualified(type($tensor)) `,` type($shift)
</code></pre><p>This op represents a left-rotation of a tensor by given number of indices.
Negative shift values are interpreted as right-rotations.</p><p>This corresponds to the <code>rotate</code> operation in arithmetic FHE schemes like
BGV. This op currently only supports 1D rotations of the last axis of a
tensor. A <code>tensor&lt;4x64xi32></code> is interpreted as 4 ciphertexts each with 64
slots, and a rotation on a value of this type rotates each ciphertext by
the given amount.</p><p>// In the future, the op will be adjusted to support rotations of general
// multi-dimensional tensors with a vector of rotation indices for each
// dimension. The lowering will implement the correct operations to rotate
// the tensor along the indices given its packing.</p><p>Examples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>...</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%c7</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>7</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span>_ext<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c7</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tensor</code></td><td>ranked tensor of any type values</td></tr><tr><td style=text-align:center><code>shift</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of any type values</td></tr></tbody></table><h3 id=tensor_extunpack-heirtensor_extunpackop><code>tensor_ext.unpack</code> (heir::tensor_ext::UnpackOp)</h3><p><em>Unpack data from a ciphertext-semantic tensor.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tensor_ext.unpack` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This op extracts the underlying cleartext data from a ciphertext-semantic
tensor.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layout</code></td><td>::mlir::Attribute</td><td>The description of the layout of a data-semantic tensor. or The description of the layout of a data-semantic tensor.</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-678c1db0f9b2ed4c9d43b790f890bea0>18 - TfheRust</h1><h1 id=tfhe_rust-dialect>&rsquo;tfhe_rust&rsquo; Dialect</h1><p>The <code>thfe_rust</code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the shortint parameters and encoding scheme.</p><p>See <a href=https://github.com/zama-ai/tfhe-rs>https://github.com/zama-ai/tfhe-rs</a></p><h2 id=tfherust-types>TfheRust types</h2><h3 id=encryptedbooltype>EncryptedBoolType</h3><p><em>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.
Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp.</em></p><p>Syntax: <code>!tfhe_rust.bool</code></p><h3 id=encryptedint2type>EncryptedInt2Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt2 type</em></p><p>Syntax: <code>!tfhe_rust.ei2</code></p><h3 id=encryptedint4type>EncryptedInt4Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt4 type</em></p><p>Syntax: <code>!tfhe_rust.ei4</code></p><h3 id=encryptedint8type>EncryptedInt8Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type</em></p><p>Syntax: <code>!tfhe_rust.ei8</code></p><h3 id=encryptedint16type>EncryptedInt16Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type</em></p><p>Syntax: <code>!tfhe_rust.ei16</code></p><h3 id=encryptedint32type>EncryptedInt32Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type</em></p><p>Syntax: <code>!tfhe_rust.ei32</code></p><h3 id=encryptedint64type>EncryptedInt64Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type</em></p><p>Syntax: <code>!tfhe_rust.ei64</code></p><h3 id=encryptedint128type>EncryptedInt128Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type</em></p><p>Syntax: <code>!tfhe_rust.ei128</code></p><h3 id=encryptedint256type>EncryptedInt256Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</em></p><p>Syntax: <code>!tfhe_rust.ei256</code></p><h3 id=encrypteduint2type>EncryptedUInt2Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type</em></p><p>Syntax: <code>!tfhe_rust.eui2</code></p><h3 id=encrypteduint3type>EncryptedUInt3Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type</em></p><p>Syntax: <code>!tfhe_rust.eui3</code></p><h3 id=encrypteduint4type>EncryptedUInt4Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type</em></p><p>Syntax: <code>!tfhe_rust.eui4</code></p><h3 id=encrypteduint8type>EncryptedUInt8Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type</em></p><p>Syntax: <code>!tfhe_rust.eui8</code></p><h3 id=encrypteduint10type>EncryptedUInt10Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type</em></p><p>Syntax: <code>!tfhe_rust.eui10</code></p><h3 id=encrypteduint12type>EncryptedUInt12Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type</em></p><p>Syntax: <code>!tfhe_rust.eui12</code></p><h3 id=encrypteduint14type>EncryptedUInt14Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type</em></p><p>Syntax: <code>!tfhe_rust.eui14</code></p><h3 id=encrypteduint16type>EncryptedUInt16Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type</em></p><p>Syntax: <code>!tfhe_rust.eui16</code></p><h3 id=encrypteduint32type>EncryptedUInt32Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type</em></p><p>Syntax: <code>!tfhe_rust.eui32</code></p><h3 id=encrypteduint64type>EncryptedUInt64Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type</em></p><p>Syntax: <code>!tfhe_rust.eui64</code></p><h3 id=encrypteduint128type>EncryptedUInt128Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type</em></p><p>Syntax: <code>!tfhe_rust.eui128</code></p><h3 id=encrypteduint256type>EncryptedUInt256Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type</em></p><p>Syntax: <code>!tfhe_rust.eui256</code></p><h3 id=lookuptabletype>LookupTableType</h3><p><em>A univariate lookup table used for programmable bootstrapping.</em></p><p>Syntax: <code>!tfhe_rust.lookup_table</code></p><h3 id=serverkeytype>ServerKeyType</h3><p><em>The short int server key required to perform homomorphic operations.</em></p><p>Syntax: <code>!tfhe_rust.server_key</code></p><h2 id=tfherust-ops>TfheRust ops</h2><h3 id=tfhe_rustadd-heirtfhe_rustaddop><code>tfhe_rust.add</code> (heir::tfhe_rust::AddOp)</h3><p><em>Arithmetic add of two tfhe ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h3 id=tfhe_rustapply_lookup_table-heirtfhe_rustapplylookuptableop><code>tfhe_rust.apply_lookup_table</code> (heir::tfhe_rust::ApplyLookupTableOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.apply_lookup_table` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>input</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr><tr><td style=text-align:center><code>lookupTable</code></td><td>A univariate lookup table used for programmable bootstrapping.</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h3 id=tfhe_rustbitand-heirtfhe_rustbitandop><code>tfhe_rust.bitand</code> (heir::tfhe_rust::BitAndOp)</h3><p><em>Logical AND of two tfhe ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.bitand` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>tfhe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h3 id=tfhe_rustbitor-heirtfhe_rustbitorop><code>tfhe_rust.bitor</code> (heir::tfhe_rust::BitOrOp)</h3><p><em>Logical OR of two tfhe ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.bitor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>tfhe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h3 id=tfhe_rustbitxor-heirtfhe_rustbitxorop><code>tfhe_rust.bitxor</code> (heir::tfhe_rust::BitXorOp)</h3><p><em>Logical XOR of two tfhe ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.bitxor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>tfhe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h3 id=tfhe_rustcast-heirtfhe_rustcastop><code>tfhe_rust.cast</code> (heir::tfhe_rust::CastOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.cast` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h3 id=tfhe_rustcmp-heirtfhe_rustcmpop><code>tfhe_rust.cmp</code> (heir::tfhe_rust::CmpOp)</h3><p>_High level operation to check the relation of two ciphertexts.</p><ul><li>equal (mnemonic: &ldquo;eq&rdquo;; integer value: 0)</li><li>not equal (mnemonic: &ldquo;ne&rdquo;; integer value: 1)</li><li>signed less than (mnemonic: &ldquo;slt&rdquo;; integer value: 2)</li><li>signed less than or equal (mnemonic: &ldquo;sle&rdquo;; integer value: 3)</li><li>signed greater than (mnemonic: &ldquo;sgt&rdquo;; integer value: 4)</li><li>signed greater than or equal (mnemonic: &ldquo;sge&rdquo;; integer value: 5)</li><li>unsigned less than (mnemonic: &ldquo;ult&rdquo;; integer value: 6)</li><li>unsigned less than or equal (mnemonic: &ldquo;ule&rdquo;; integer value: 7)</li><li>unsigned greater than (mnemonic: &ldquo;ugt&rdquo;; integer value: 8)</li><li>unsigned greater than or equal (mnemonic: &ldquo;uge&rdquo;; integer value: 9)</li></ul><p>Note: <a href=https://mlir.llvm.org/docs/Dialects/ArithOps/#arithcmpi-arithcmpiop>https://mlir.llvm.org/docs/Dialects/ArithOps/#arithcmpi-arithcmpiop</a>_</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.cmp` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::arith::CmpIPredicateAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp.</td><td></td></tr></tbody></table><h3 id=tfhe_rustcreate_trivial-heirtfhe_rustcreatetrivialop><code>tfhe_rust.create_trivial</code> (heir::tfhe_rust::CreateTrivialOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.create_trivial` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>value</code></td><td>integer</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h3 id=tfhe_rusteq-heirtfhe_rusteqop><code>tfhe_rust.eq</code> (heir::tfhe_rust::EqOp)</h3><p><em>High level operation to check equality of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.eq` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>tfhe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h3 id=tfhe_rustgenerate_lookup_table-heirtfhe_rustgeneratelookuptableop><code>tfhe_rust.generate_lookup_table</code> (heir::tfhe_rust::GenerateLookupTableOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.generate_lookup_table` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>truthTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lookupTable</code></td><td>A univariate lookup table used for programmable bootstrapping.</td></tr></tbody></table><h3 id=tfhe_rustmax-heirtfhe_rustmaxop><code>tfhe_rust.max</code> (heir::tfhe_rust::MaxOp)</h3><p><em>High level operation to return maximum of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.max` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>tfhe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h3 id=tfhe_rustmin-heirtfhe_rustminop><code>tfhe_rust.min</code> (heir::tfhe_rust::MinOp)</h3><p><em>High level operation to return minimum of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.min` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>tfhe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h3 id=tfhe_rustmul-heirtfhe_rustmulop><code>tfhe_rust.mul</code> (heir::tfhe_rust::MulOp)</h3><p><em>Arithmetic mul of two tfhe ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h3 id=tfhe_rustneq-heirtfhe_rustneqop><code>tfhe_rust.neq</code> (heir::tfhe_rust::NeqOp)</h3><p><em>High level operation to check inequality of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.neq` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>tfhe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h3 id=tfhe_rustscalar_left_shift-heirtfhe_rustscalarleftshiftop><code>tfhe_rust.scalar_left_shift</code> (heir::tfhe_rust::ScalarLeftShiftOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.scalar_left_shift` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>shiftAmount</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h3 id=tfhe_rustscalar_right_shift-heirtfhe_rustscalarrightshiftop><code>tfhe_rust.scalar_right_shift</code> (heir::tfhe_rust::ScalarRightShiftOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.scalar_right_shift` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>shiftAmount</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h3 id=tfhe_rustcmux-heirtfhe_rustselectop><code>tfhe_rust.cmux</code> (heir::tfhe_rust::SelectOp)</h3><p><em>Multiplexer operations, the <code>select</code> ciphertext will return the <code>trueCtxt</code>
if in contains a 1. In the other case, it will will return the <code>falseCtxt</code>.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.cmux` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>select</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp.</td><td></td></tr><tr><td style=text-align:center><code>trueCtxt</code></td><td>tfhe-ciphertext-like</td></tr><tr><td style=text-align:center><code>falseCtxt</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tfhe-ciphertext-like</td></tr></tbody></table><h3 id=tfhe_rustsub-heirtfhe_rustsubop><code>tfhe_rust.sub</code> (heir::tfhe_rust::SubOp)</h3><p><em>Arithmetic sub of two tfhe ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.sub` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The short int server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>tfhe-ciphertext-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>Integer type with arbitrary precision up to a fixed limit or An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.</td></tr><tr><td style=text-align:center>Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</td><td></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-d46d9ee8aeb1f8889ca7cfc9a061a7cc>19 - TfheRustBool</h1><h1 id=tfhe_rust_bool-dialect>&rsquo;tfhe_rust_bool&rsquo; Dialect</h1><p>The <code>tfhe_rust_bool</code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the boolean parameter set.</p><p>See <a href=https://github.com/zama-ai/tfhe-rs>https://github.com/zama-ai/tfhe-rs</a></p><h2 id=tfherustbool-attributes>TfheRustBool attributes</h2><h3 id=tfherustboolgatesattr>TfheRustBoolGatesAttr</h3><p><em>An Attribute containing an array of strings to store bool gates</em></p><p>Syntax:</p><pre tabindex=0><code>#tfhe_rust_bool.tfhe_rust_bool_gates&lt;
  ::llvm::ArrayRef&lt;::mlir::heir::tfhe_rust_bool::TfheRustBoolGateEnumAttr&gt;   # gates
&gt;
</code></pre><p>This attributes stores a list of integer identifiers for Boolean gates.</p><p>Uses following mapping:
AND_GATE = 0;
NAND_GATE = 1;
OR_GATE = 2;
NOR_GATE = 3;
XOR_GATE = 4;
XNOR_GATE = 5;
NOT_GATE = 6;</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>gates</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::heir::tfhe_rust_bool::TfheRustBoolGateEnumAttr></code></td><td></td></tr></tbody></table><h2 id=tfherustbool-types>TfheRustBool types</h2><h3 id=encryptedbooltype>EncryptedBoolType</h3><p><em>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</em></p><p>Syntax: <code>!tfhe_rust_bool.eb</code></p><h3 id=packedserverkeytype>PackedServerKeyType</h3><p><em>The Belfort packed API boolean server key.</em></p><p>Syntax: <code>!tfhe_rust_bool.server_key_enum</code></p><h3 id=serverkeytype>ServerKeyType</h3><p><em>The boolean server key required to perform homomorphic operations.</em></p><p>Syntax: <code>!tfhe_rust_bool.server_key</code></p><h2 id=tfherustbool-ops>TfheRustBool ops</h2><h3 id=tfhe_rust_boolcreate_trivial-heirtfhe_rust_boolcreatetrivialop><code>tfhe_rust_bool.create_trivial</code> (heir::tfhe_rust_bool::CreateTrivialOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.create_trivial` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>tfhe rust bool server key</td></tr><tr><td style=text-align:center><code>value</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr></tbody></table><h3 id=tfhe_rust_booland-heirtfhe_rust_boolandop><code>tfhe_rust_bool.and</code> (heir::tfhe_rust_bool::AndOp)</h3><p><em>Logical AND of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.and` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolmux-heirtfhe_rust_boolmuxop><code>tfhe_rust_bool.mux</code> (heir::tfhe_rust_bool::MuxOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.mux` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.</td></tr><tr><td style=text-align:center><code>cnd</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</td></tr></tbody></table><h3 id=tfhe_rust_boolnand-heirtfhe_rust_boolnandop><code>tfhe_rust_bool.nand</code> (heir::tfhe_rust_bool::NandOp)</h3><p><em>Logical NAND of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.nand` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolnor-heirtfhe_rust_boolnorop><code>tfhe_rust_bool.nor</code> (heir::tfhe_rust_bool::NorOp)</h3><p><em>Logical NOR of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.nor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolnot-heirtfhe_rust_boolnotop><code>tfhe_rust_bool.not</code> (heir::tfhe_rust_bool::NotOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.not` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.</td></tr><tr><td style=text-align:center><code>input</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolor-heirtfhe_rust_boolorop><code>tfhe_rust_bool.or</code> (heir::tfhe_rust_bool::OrOp)</h3><p><em>Logical OR of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.or` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolgates_packed-heirtfhe_rust_boolpackedop><code>tfhe_rust_bool.gates_packed</code> (heir::tfhe_rust_bool::PackedOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.gates_packed` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Operation to where different Boolean gates are executed pairwise between elements of two ciphertext arrays.</p><p>For example,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> tfhe_rust_bool<span style=color:#000;font-weight:700>.</span>packed_gates <span style=color:#000>%a</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%b</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>gates =</span> <span style=color:#000>#tfhe_rust_bool.tfhe_rust_bool_gates</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;}</span> <span style=color:#000;font-weight:700>:</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>(!</span>tfhe_rust_bool<span style=color:#000;font-weight:700>.</span>server_key<span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>     <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>2x</span><span style=color:#000;font-weight:700>!</span>tfhe_rust_bool<span style=color:#000;font-weight:700>.</span>eb<span style=color:#000;font-weight:700>&gt;,</span>
</span></span><span style=display:flex><span>     <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>2x</span><span style=color:#000;font-weight:700>!</span>tfhe_rust_bool<span style=color:#000;font-weight:700>.</span>eb<span style=color:#000;font-weight:700>&gt;)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>2x</span><span style=color:#000;font-weight:700>!</span>tfhe_rust_bool<span style=color:#000;font-weight:700>.</span>eb<span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>applies an &ldquo;and&rdquo; gate to the first elements of %a and %b and an xor gate to the
second elements.</p><p>Mapping is defined in the BooleanGates.td file.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>gates</code></td><td>::mlir::heir::tfhe_rust_bool::TfheRustBoolGatesAttr</td><td>An Attribute containing an array of strings to store bool gates</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolxnor-heirtfhe_rust_boolxnorop><code>tfhe_rust_bool.xnor</code> (heir::tfhe_rust_bool::XnorOp)</h3><p><em>Logical XNOR of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.xnor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h3 id=tfhe_rust_boolxor-heirtfhe_rust_boolxorop><code>tfhe_rust_bool.xor</code> (heir::tfhe_rust_bool::XorOp)</h3><p><em>Logical XOR of two TFHE-rs Bool ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust_bool.xor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>eb-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>eb-like</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>eb-like</td></tr></tbody></table><h2 id=tfherustbool-additional-definitions>TfheRustBool additional definitions</h2><h3 id=tfherustboolgateenum>TfheRustBoolGateEnum</h3><p><em>An enum attribute representing a TFHE-rs boolean gate using u8 int</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>AND</td><td style=text-align:center><code>0</code></td><td>AND</td></tr><tr><td style=text-align:center>NAND</td><td style=text-align:center><code>1</code></td><td>NAND</td></tr><tr><td style=text-align:center>OR</td><td style=text-align:center><code>2</code></td><td>OR</td></tr><tr><td style=text-align:center>NOR</td><td style=text-align:center><code>3</code></td><td>NOR</td></tr><tr><td style=text-align:center>XOR</td><td style=text-align:center><code>4</code></td><td>XOR</td></tr><tr><td style=text-align:center>XNOR</td><td style=text-align:center><code>5</code></td><td>XNOR</td></tr><tr><td style=text-align:center>NOT</td><td style=text-align:center><code>6</code></td><td>NOT</td></tr></tbody></table></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/google/heir aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2025 The HEIR Authors All Rights Reserved</span>
<span class=ms-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.027d75d71824837bee74c12a7806c5fe51249c1ca7accc27553a251a75cdb3a4.js integrity="sha256-An111xgkg3vudMEqeAbF/lEknBynrMwnVTolGnXNs6Q=" crossorigin=anonymous></script>
<script defer src=/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>