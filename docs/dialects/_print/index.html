<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.113.0"><link rel=canonical type=text/html href=https://heir.dev/docs/dialects/><link rel=alternate type=application/rss+xml href=https://heir.dev/docs/dialects/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Dialects | HEIR</title><meta name=description content><meta property="og:title" content="Dialects"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://heir.dev/docs/dialects/"><meta itemprop=name content="Dialects"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="Dialects"><meta name=twitter:description content><link rel=preload href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css as=style><link href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=td-section><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="32" height="32" fill="#fff" fill-opacity=".01"/><path d="M18.6889 10.124l7.7916 5.0511 2.6263-1.6684-2.6146-1.6779-7.8033-4.96754 2.8526 1.84162L18.6889 10.124z" fill="#efcf6f"/><path d="M29.1185 6.86125 18.6979.13981 16.06 1.79876 26.4922 8.52025l2.6263-1.659z" fill="#efcf6f"/><path d="M8.2405 6.74134 5.60033 5.07291 3.05751 6.79935 5.67334 8.49344 8.2405 6.74134z" fill="#ee958a"/><path d="M10.8697 8.49344 8.2405 10.124v3.3995l5.2049-3.3348-2.5757-1.69526z" fill="#ee958a"/><path d="M5.67334 8.49344 3.05751 6.79935 3.03318 23.4932l2.64016 1.6897V8.49344z" fill="#a32e24"/><path d="M29.1185 6.86126 26.4922 8.52025V11.8288l2.6263-1.6401V6.86126z" fill="#d38041"/><path d="M21.5415 8.70288 18.6889 6.86126V10.124l2.8526-1.42112z" fill="#d38041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M8.2405 6.74134V10.124v3.3995l5.2049-3.3348V3.58723l2.6145-1.7885L16.1123 11.8484V18.467l-2.6158 1.6181L13.4574 13.5235 10.849 15.1694 8.2405 16.8152v6.678L5.67334 25.1829V8.49344L8.2405 6.74134z" fill="#dd583b"/><path d="M13.4965 20.0851 13.4574 13.5235 10.849 15.1694 10.8077 18.467l2.6888 1.6181z" fill="#a32e24"/><path fill-rule="evenodd" clip-rule="evenodd" d="M13.4454 3.58723V10.1887L10.8697 8.49344 10.9293 1.79873l2.5161 1.7885z" fill="#a32e24"/><path d="M16.0599 1.79873 13.4454.13981 10.9293 1.79873l2.5161 1.7885 2.6145-1.7885z" fill="#ee958a"/><path d="M16.06 1.79876 16.0793 5.52165 16.1123 11.8484V18.467l2.5766-1.6518V13.4696 10.124 6.86126l7.8033 4.96754V8.52025L16.06 1.79876z" fill="#e5ad11"/><path d="M18.6889 16.8152 16.1123 18.467l10.3682 6.7159V21.8372l-7.7916-5.022z" fill="#e5ad11"/><path d="M26.4805 15.1751 18.6889 10.124v3.3456l2.7505 1.7641 5.0411 3.2333V15.1751z" fill="#e5ad11"/><path d="M29.1068 13.5067l-2.6263 1.6684V18.467l2.6263-1.6518V13.5067z" fill="#d48041"/><path d="M29.1185 20.0851l-2.638 1.7521v3.3457l2.6263-1.6897L29.1185 20.0851z" fill="#d48041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M26.4805 21.8372l-7.7916-5.022 2.7505-1.5815 5.0411 3.2333 2.638 1.6181-2.638 1.7521z" fill="#efcf6f"/><path d="M18.6889 13.4696v3.3456l2.7505-1.5815-2.7505-1.7641z" fill="#d48041"/><path d="M20.1621 26.5165l-4.2015-2.7017-4.2015-2.7016L11.7108 23.8491l6.3384 4.0776 2.1129 1.3512V26.5165z" fill="#395aad"/><path d="M7.49852 23.8491v2.6674l8.41958 5.4439V29.2779L7.49852 23.8491z" fill="#276e3a"/><path d="M9.57951 22.4781l-2.08099 1.371 8.41958 5.4288 2.1311-1.3512-6.3384-4.0776-2.13129-1.371z" fill="#add284"/><path d="M24.3747 26.5165V23.8491L22.174 22.8377l-2.0054.9665 2.1815 1.3793 2.0246 1.333z" fill="#395aad"/><path d="M18.0492 19.7061l2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#395aad"/><path fill-rule="evenodd" clip-rule="evenodd" d="M20.1621 18.4432l-2.0415-.596-2.1581.596-2.1017 1.3349-2.1017 1.3351 2.1012 1.3511 6.3018 4.0522 2.188-1.333-2.1815-1.3793 2.0054-.9665 2.2007 1.0114 2.0995-1.329-2.0811-1.4069L22.3501 21.1371l-.1752-1.4237L22.174 19.7061l-2.0119-1.2629zm-2.1129 1.2629 2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#9ec4e0"/><path d="M26.4742 22.5201l-2.0995 1.329v2.6674l2.1289-1.3305L26.4742 22.5201z" fill="#4285f4"/><path d="M20.1621 26.5165v2.7614l2.188-1.3512V25.1835l-2.188 1.333z" fill="#4285f4"/><path d="M15.9181 29.2779v2.6825l2.1311-1.3708V27.9267l-2.1311 1.3512z" fill="#4e9c68"/></svg></span><span class=navbar-brand__name>HEIR</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/><span>Home</span></a></li><li class=nav-item><a class="nav-link active" href=/docs/><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://github.com/google/heir/ target=_blank rel=noopener><span>GitHub</span></a></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/dialects/>Return to the regular view of this page</a>.</p></div><h1 class=title>Dialects</h1><ul><li>1: <a href=#pg-7a2d769a54237b8d0845fe32a6451c2b>BGV</a></li><li>2: <a href=#pg-5f74537b9610a2b3f8ddf498be3d47b0>CGGI</a></li><li>3: <a href=#pg-818a3660f61ebf5859b5c98635beacc8>CKKS</a></li><li>4: <a href=#pg-80cc312dd83f43a069330083f04eb4f2>Comb</a></li><li>5: <a href=#pg-df73b993320a0b803398dca1b5f7c3cd>Jaxite</a></li><li>6: <a href=#pg-63d08712eb5ec0da1ca62003de70e7f1>JaxiteWord</a></li><li>7: <a href=#pg-6857a323f6f4a36b66d9290a3b2c84fc>Lattigo</a></li><li>8: <a href=#pg-c5dda3cb8e694541eacbee638af7317d>LWE</a></li><li>9: <a href=#pg-024e5f7d26a5dfbbc21bb90c29119ca6>MathExt</a></li><li>10: <a href=#pg-b15a871dcca009396e70be943220c783>Mgmt</a></li><li>11: <a href=#pg-75945813f3978b67fb0398cc4f17cb8b>ModArith</a></li><li>12: <a href=#pg-e397c035ea096bd861aadf40d3fccd0a>Openfhe</a></li><li>13: <a href=#pg-ef2cb05e00e8510bb8a622ae4be9966f>Orion</a></li><li>14: <a href=#pg-b18fea903e4651113f5317788f1491e1>Polynomial</a></li><li>15: <a href=#pg-c9ea40a8d17399f57cdd3c18b53cedef>Random</a></li><li>16: <a href=#pg-aeae60b865ac85372556b396a5a052ce>RNS</a></li><li>17: <a href=#pg-f7ffac8ba93b73b8a62e185ec8643d63>Secret</a></li><li>18: <a href=#pg-ca9ddb02db7c0683037407c6f9eb1f2a>TensorExt</a></li><li>19: <a href=#pg-678c1db0f9b2ed4c9d43b790f890bea0>TfheRust</a></li><li>20: <a href=#pg-d46d9ee8aeb1f8889ca7cfc9a061a7cc>TfheRustBool</a></li></ul><div class=content><p>This section contains the reference documentation for all of the dialects
defined in HEIR.</p></div></div><div class=td-content><h1 id=pg-7a2d769a54237b8d0845fe32a6451c2b>1 - BGV</h1><h1 id=bgv-dialect>&lsquo;bgv&rsquo; Dialect</h1><p>The BGV dialect defines the types and operations of the BGV and B/FV cryptosystem.</p><p>Due to similarity with the BFV scheme, BGV dialect also represents the B/FV scheme.</p><p>The semantics of bgv dialect operations are determined by the <code>scheme.bgv</code> or <code>scheme.bfv</code>
annotation at the module level.</p><p>In B/FV mode, bgv.modulus_switch is an no-op.</p><h2 id=bgv-attributes>BGV attributes</h2><h3 id=schemeparamattr>SchemeParamAttr</h3><p><em>BGV Scheme Parameters</em></p><p>Syntax:</p><pre tabindex=0><code>#bgv.scheme_param&lt;
  int,   # logN
  DenseI64ArrayAttr,   # Q
  DenseI64ArrayAttr,   # P
  int64_t,   # plaintextModulus
  BGVEncryptionType,   # encryptionType
  BGVEncryptionTechnique   # encryptionTechnique
&gt;
</code></pre><p>This attribute is used for recording the scheme parameters for CKKS.</p><p>The attribute is a struct with the following fields:</p><ul><li><code>int</code> logN: The log of the degree of the polynomial modulus.</li><li><code>DenseI64ArrayAttr</code> Q: The array of primes in the ciphertext modulus.</li><li><code>DenseI64ArrayAttr</code> P: The array of primes in the special modulus, used for key switching.</li><li><code>int64_t</code> plaintextModulus: The plaintext modulus.</li></ul><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>logN</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>Q</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>P</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintextModulus</td><td style=text-align:center><code>int64_t</code></td><td></td></tr><tr><td style=text-align:center>encryptionType</td><td style=text-align:center><code>BGVEncryptionType</code></td><td></td></tr><tr><td style=text-align:center>encryptionTechnique</td><td style=text-align:center><code>BGVEncryptionTechnique</code></td><td></td></tr></tbody></table><h2 id=bgv-additional-definitions>BGV additional definitions</h2><h3 id=bgvencryptiontechnique>BGVEncryptionTechnique</h3><p><em>An enum attribute representing an encryption technique</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>standard</td><td style=text-align:center><code>0</code></td><td>standard</td></tr><tr><td style=text-align:center>extended</td><td style=text-align:center><code>1</code></td><td>extended</td></tr></tbody></table><h3 id=bgvencryptiontype>BGVEncryptionType</h3><p><em>An enum attribute representing an encryption method</em></p><h4 id=cases-1>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>pk</td><td style=text-align:center><code>0</code></td><td>pk</td></tr><tr><td style=text-align:center>sk</td><td style=text-align:center><code>1</code></td><td>sk</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-5f74537b9610a2b3f8ddf498be3d47b0>2 - CGGI</h1><h1 id=cggi-dialect>&lsquo;cggi&rsquo; Dialect</h1><p><em>A dialect for types and operations in the CGGI cryptosystem</em></p><h2 id=cggi-attributes>CGGI attributes</h2><h3 id=cggiboolgatesattr>CGGIBoolGatesAttr</h3><p><em>An attribute containing an array of strings to store bool gates</em></p><p>Syntax:</p><pre tabindex=0><code>#cggi.cggi_bool_gates&lt;
  ::llvm::ArrayRef&lt;::mlir::heir::cggi::CGGIBoolGateEnumAttr&gt;   # gates
&gt;
</code></pre><pre><code>This attributes stores a list of integer identifiers for Boolean gates.
</code></pre><p>Uses following mapping:
AND_GATE = 0;
NAND_GATE = 1;
OR_GATE = 2;
NOR_GATE = 3;
XOR_GATE = 4;
XNOR_GATE = 5;
NOT_GATE = 6;</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>gates</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::heir::cggi::CGGIBoolGateEnumAttr></code></td><td></td></tr></tbody></table><h2 id=cggi-additional-definitions>CGGI additional definitions</h2><h3 id=cggiboolgateenum>CGGIBoolGateEnum</h3><p><em>An enum attribute representing a CGGI boolean gate using u8 int</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>AND</td><td style=text-align:center><code>0</code></td><td>AND</td></tr><tr><td style=text-align:center>NAND</td><td style=text-align:center><code>1</code></td><td>NAND</td></tr><tr><td style=text-align:center>OR</td><td style=text-align:center><code>2</code></td><td>OR</td></tr><tr><td style=text-align:center>NOR</td><td style=text-align:center><code>3</code></td><td>NOR</td></tr><tr><td style=text-align:center>XOR</td><td style=text-align:center><code>4</code></td><td>XOR</td></tr><tr><td style=text-align:center>XNOR</td><td style=text-align:center><code>5</code></td><td>XNOR</td></tr><tr><td style=text-align:center>NOT</td><td style=text-align:center><code>6</code></td><td>NOT</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-818a3660f61ebf5859b5c98635beacc8>3 - CKKS</h1><h1 id=ckks-dialect>&lsquo;ckks&rsquo; Dialect</h1><p>The CKKS dialect defines the types and operations of the CKKS cryptosystem.</p><h2 id=ckks-attributes>CKKS attributes</h2><h3 id=schemeparamattr>SchemeParamAttr</h3><p><em>CKKS Scheme Parameters</em></p><p>Syntax:</p><pre tabindex=0><code>#ckks.scheme_param&lt;
  int,   # logN
  DenseI64ArrayAttr,   # Q
  DenseI64ArrayAttr,   # P
  int,   # logDefaultScale
  CKKSEncryptionType,   # encryptionType
  CKKSEncryptionTechnique   # encryptionTechnique
&gt;
</code></pre><p>This attribute is used for recording the scheme parameters for CKKS.</p><p>The attribute is a struct with the following fields:</p><ul><li><code>int</code> logN: The log of the degree of the polynomial modulus.</li><li><code>DenseI64ArrayAttr</code> Q: The array of primes in the ciphertext modulus.</li><li><code>DenseI64ArrayAttr</code> P: The array of primes in the special modulus, used for key switching.</li><li><code>int</code> logDefaultScale: The log of the default scale.</li></ul><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>logN</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>Q</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>P</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logDefaultScale</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>encryptionType</td><td style=text-align:center><code>CKKSEncryptionType</code></td><td></td></tr><tr><td style=text-align:center>encryptionTechnique</td><td style=text-align:center><code>CKKSEncryptionTechnique</code></td><td></td></tr></tbody></table><h2 id=ckks-additional-definitions>CKKS additional definitions</h2><h3 id=ckksencryptiontechnique>CKKSEncryptionTechnique</h3><p><em>An enum attribute representing an encryption technique</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>standard</td><td style=text-align:center><code>0</code></td><td>standard</td></tr><tr><td style=text-align:center>extended</td><td style=text-align:center><code>1</code></td><td>extended</td></tr></tbody></table><h3 id=ckksencryptiontype>CKKSEncryptionType</h3><p><em>An enum attribute representing an encryption method</em></p><h4 id=cases-1>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>pk</td><td style=text-align:center><code>0</code></td><td>pk</td></tr><tr><td style=text-align:center>sk</td><td style=text-align:center><code>1</code></td><td>sk</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-80cc312dd83f43a069330083f04eb4f2>4 - Comb</h1><h1 id=comb-dialect>&lsquo;comb&rsquo; Dialect</h1><p><em>Types and operations for comb dialect</em></p><p>This dialect defines the <code>comb</code> dialect, which is intended to be a generic
representation of combinational logic outside of a particular use-case.</p><h2 id=operations>Operations</h2><h3 id=combadd-heircombaddop><code>comb.add</code> (heir::comb::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comband-heircombandop><code>comb.and</code> (heir::comb::AndOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combconcat-heircombconcatop><code>comb.concat</code> (heir::comb::ConcatOp)</h3><p><em>Concatenate a variadic list of operands together.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
</code></pre><p>See the comb rationale document for details on operand ordering.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combextract-heircombextractop><code>comb.extract</code> (heir::comb::ExtractOp)</h3><p><em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combicmp-heircombicmpop><code>comb.icmp</code> (heir::comb::ICmpOp)</h3><p><em>Compare two integer values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre tabindex=0><code>    %r = comb.icmp eq %a, %b : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::heir::comb::ICmpPredicateAttr</td><td>hw.icmp comparison predicate</td></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combinv-heircombinvop><code>comb.inv</code> (heir::comb::InvOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comblut-heircomblutop><code>comb.lut</code> (heir::comb::LUTOp)</h3><p><em>Return an integer based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.lut` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation is similar to <code>truth_table</code>, but it allows for an integer output instead of a boolean.
Requers an vector of integers as the lookup table, where each integer represents the output for a specific combination of inputs.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr><tr><td><code>lookupTable</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 8-bit signless integer</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8-bit signless integer</td></tr></tbody></table><h3 id=combmul-heircombmulop><code>comb.mul</code> (heir::comb::MulOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmux-heircombmuxop><code>comb.mux</code> (heir::comb::MuxOp)</h3><p><em>Return one or the other operand depending on a selector bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))
</code></pre><pre tabindex=0><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=combnand-heircombnandop><code>comb.nand</code> (heir::comb::NandOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combnor-heircombnorop><code>comb.nor</code> (heir::comb::NorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combor-heircomborop><code>comb.or</code> (heir::comb::OrOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combparity-heircombparityop><code>comb.parity</code> (heir::comb::ParityOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combreplicate-heircombreplicateop><code>comb.replicate</code> (heir::comb::ReplicateOp)</h3><p><em>Concatenate the operand a constant number of times</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combtruth_table-heircombtruthtableop><code>comb.truth_table</code> (heir::comb::TruthTableOp)</h3><p><em>Return a true/false based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.truth_table` $inputs `-&gt;` $lookupTable attr-dict
</code></pre><pre tabindex=0><code>  %a = ... : i1
  %b = ... : i1
  %0 = comb.truth_table %a, %b -&gt; 6 : ui4
</code></pre><p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -> LSB from left
to right and the offset into <code>lookupTable</code> is computed from them. The
integer containing the truth table value&rsquo;s LSB is the output for the input
&ldquo;all false&rdquo;, and the MSB is the output for the input &ldquo;all true&rdquo;.</p><p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &lsquo;x&rsquo; &ndash; it should be the well-known result.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookupTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combxnor-heircombxnorop><code>comb.xnor</code> (heir::comb::XNorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combxor-heircombxorop><code>comb.xor</code> (heir::comb::XorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h2 id=enums>Enums</h2><h3 id=icmppredicate>ICmpPredicate</h3><p><em>Hw.icmp comparison predicate</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>eq</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>ne</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>slt</td><td style=text-align:center><code>2</code></td><td>slt</td></tr><tr><td style=text-align:center>sle</td><td style=text-align:center><code>3</code></td><td>sle</td></tr><tr><td style=text-align:center>sgt</td><td style=text-align:center><code>4</code></td><td>sgt</td></tr><tr><td style=text-align:center>sge</td><td style=text-align:center><code>5</code></td><td>sge</td></tr><tr><td style=text-align:center>ult</td><td style=text-align:center><code>6</code></td><td>ult</td></tr><tr><td style=text-align:center>ule</td><td style=text-align:center><code>7</code></td><td>ule</td></tr><tr><td style=text-align:center>ugt</td><td style=text-align:center><code>8</code></td><td>ugt</td></tr><tr><td style=text-align:center>uge</td><td style=text-align:center><code>9</code></td><td>uge</td></tr><tr><td style=text-align:center>ceq</td><td style=text-align:center><code>10</code></td><td>ceq</td></tr><tr><td style=text-align:center>cne</td><td style=text-align:center><code>11</code></td><td>cne</td></tr><tr><td style=text-align:center>weq</td><td style=text-align:center><code>12</code></td><td>weq</td></tr><tr><td style=text-align:center>wne</td><td style=text-align:center><code>13</code></td><td>wne</td></tr></tbody></table><h2 id=comb-additional-definitions>Comb additional definitions</h2><h3 id=icmppredicate-1>ICmpPredicate</h3><p><em>Hw.icmp comparison predicate</em></p><h4 id=cases-1>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>eq</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>ne</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>slt</td><td style=text-align:center><code>2</code></td><td>slt</td></tr><tr><td style=text-align:center>sle</td><td style=text-align:center><code>3</code></td><td>sle</td></tr><tr><td style=text-align:center>sgt</td><td style=text-align:center><code>4</code></td><td>sgt</td></tr><tr><td style=text-align:center>sge</td><td style=text-align:center><code>5</code></td><td>sge</td></tr><tr><td style=text-align:center>ult</td><td style=text-align:center><code>6</code></td><td>ult</td></tr><tr><td style=text-align:center>ule</td><td style=text-align:center><code>7</code></td><td>ule</td></tr><tr><td style=text-align:center>ugt</td><td style=text-align:center><code>8</code></td><td>ugt</td></tr><tr><td style=text-align:center>uge</td><td style=text-align:center><code>9</code></td><td>uge</td></tr><tr><td style=text-align:center>ceq</td><td style=text-align:center><code>10</code></td><td>ceq</td></tr><tr><td style=text-align:center>cne</td><td style=text-align:center><code>11</code></td><td>cne</td></tr><tr><td style=text-align:center>weq</td><td style=text-align:center><code>12</code></td><td>weq</td></tr><tr><td style=text-align:center>wne</td><td style=text-align:center><code>13</code></td><td>wne</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-df73b993320a0b803398dca1b5f7c3cd>5 - Jaxite</h1><h1 id=jaxite-dialect>&lsquo;jaxite&rsquo; Dialect</h1><p>The <code>jaxite</code> dialect is an exit dialect for generating py code against the jaxite library API,
using the jaxite parameters and encoding scheme.</p><p>See <a href=https://github.com/google/jaxite>https://github.com/google/jaxite</a></p><h2 id=jaxite-types>Jaxite types</h2><h3 id=paramstype>ParamsType</h3><p><em>The jaxite security params required to perform homomorphic operations.</em></p><p>Syntax: <code>!jaxite.params</code></p><h3 id=pmaplut3tupletype>PmapLut3TupleType</h3><p><em>A tuple of pmap_lut3 args.</em></p><p>Syntax: <code>!jaxite.pmap_lut3_tuple</code></p><h3 id=serverkeysettype>ServerKeySetType</h3><p><em>The jaxite server key set required to perform homomorphic operations.</em></p><p>Syntax: <code>!jaxite.server_key_set</code></p></div><div class=td-content style=page-break-before:always><h1 id=pg-63d08712eb5ec0da1ca62003de70e7f1>6 - JaxiteWord</h1><h1 id=jaxiteword-dialect>&lsquo;jaxiteword&rsquo; Dialect</h1><p>The <code>jaxiteword</code> dialect is an exit dialect for generating py code against the jaxiteword library API,
using the jaxiteword parameters and encoding scheme.</p><p>See <a href=https://github.com/google/jaxite/jaxite_word>https://github.com/google/jaxite/jaxite_word</a></p><h2 id=jaxiteword-types>JaxiteWord types</h2><h3 id=ccparamstype>CCParamsType</h3><p><em>The CCParams required to create CryptoContext.</em></p><p>Syntax: <code>!jaxiteword.cc_params</code></p><h3 id=ciphertexttype>CiphertextType</h3><p>Syntax:</p><pre tabindex=0><code>!jaxiteword.ciphertext&lt;
  int,   # polys
  int,   # towers
  int   # degrees
&gt;
</code></pre><p>A ciphertext - a three dimensional array.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>polys</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>towers</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>degrees</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=cryptocontexttype>CryptoContextType</h3><p><em>The CryptoContext required to perform homomorphic operations in JaxiteWord.</em></p><p>Syntax: <code>!jaxiteword.crypto_context</code></p><h3 id=evalkeytype>EvalKeyType</h3><p><em>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in JaxiteWord.</em></p><p>Syntax: <code>!jaxiteword.eval_key</code></p><h3 id=moduluslisttype>ModulusListType</h3><p>Syntax:</p><pre tabindex=0><code>!jaxiteword.modulus_list&lt;
  ::llvm::ArrayRef&lt;::mlir::IntegerAttr&gt;   # modulus_list
&gt;
</code></pre><p>A list of modulus values.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>modulus_list</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::IntegerAttr></code></td><td></td></tr></tbody></table><h3 id=privatekeytype>PrivateKeyType</h3><p><em>The private key required to decrypt a ciphertext in JaxiteWord.</em></p><p>Syntax: <code>!jaxiteword.private_key</code></p><h3 id=publickeytype>PublicKeyType</h3><p><em>The public key required to encrypt plaintext in JaxiteWord.</em></p><p>Syntax: <code>!jaxiteword.public_key</code></p></div><div class=td-content style=page-break-before:always><h1 id=pg-6857a323f6f4a36b66d9290a3b2c84fc>7 - Lattigo</h1><h1 id=lattigo-dialect>&rsquo;lattigo&rsquo; Dialect</h1><p>The <code>lattigo</code> dialect is an exit dialect for generating GO code against the Lattigo library API.</p><p>See <a href=https://github.com/tuneinsight/lattigo>https://github.com/tuneinsight/lattigo</a></p><h2 id=lattigo-attributes>Lattigo attributes</h2><h3 id=bgvparametersliteralattr>BGVParametersLiteralAttr</h3><p><em>Literal parameters for Lattigo BGV</em></p><p>Syntax:</p><pre tabindex=0><code>#lattigo.bgv.parameters_literal&lt;
  int,   # logN
  DenseI64ArrayAttr,   # Q
  DenseI64ArrayAttr,   # P
  DenseI32ArrayAttr,   # logQ
  DenseI32ArrayAttr,   # logP
  int64_t   # plaintextModulus
&gt;
</code></pre><p>This attribute represents the literal parameters for Lattigo BGV.</p><p>This is in accordance with <a href=https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/bgv#ParametersLiteral>https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/bgv#ParametersLiteral</a>
where some field are not present in the current implementation.</p><p>Users must set the polynomial degree (LogN) and the coefficient modulus,
by either setting the Q and P fields to the desired moduli chain,
or by setting the LogQ and LogP fields to the desired moduli sizes.</p><p>Note that for Lattigo, Q/P requires []uint64, where this attribute
only provides int64. We assume user should not select moduli so large
to consider the signedness issue.</p><p>Users must also specify the coefficient modulus in plaintext-space (T).
This modulus must be an NTT-friendly prime in the plaintext space:
it must be equal to 1 modulo 2n where n is the plaintext ring degree
(i.e., the plaintext space has n slots).</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>logN</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>Q</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>P</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logQ</td><td style=text-align:center><code>DenseI32ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logP</td><td style=text-align:center><code>DenseI32ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintextModulus</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=ckksparametersliteralattr>CKKSParametersLiteralAttr</h3><p><em>Literal parameters for Lattigo CKKS</em></p><p>Syntax:</p><pre tabindex=0><code>#lattigo.ckks.parameters_literal&lt;
  int,   # logN
  DenseI64ArrayAttr,   # Q
  DenseI64ArrayAttr,   # P
  DenseI32ArrayAttr,   # logQ
  DenseI32ArrayAttr,   # logP
  int   # logDefaultScale
&gt;
</code></pre><p>This attribute represents the literal parameters for Lattigo CKKS.</p><p>This is in accordance with <a href=https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/ckks#ParametersLiteral>https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/ckks#ParametersLiteral</a>
where some field are not present in the current implementation.</p><p>Users must set the polynomial degree (LogN) and the coefficient modulus,
by either setting the Q and P fields to the desired moduli chain,
or by setting the LogQ and LogP fields to the desired moduli sizes.</p><p>Note that for Lattigo, Q/P requires []uint64, where this attribute
only provides int64. We assume user should not select moduli so large
to consider the signedness issue.</p><p>Users must also specify a default initial scale for the plaintexts1.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>logN</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>Q</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>P</td><td style=text-align:center><code>DenseI64ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logQ</td><td style=text-align:center><code>DenseI32ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logP</td><td style=text-align:center><code>DenseI32ArrayAttr</code></td><td></td></tr><tr><td style=text-align:center>logDefaultScale</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h2 id=lattigo-types>Lattigo types</h2><h3 id=bgvencodertype>BGVEncoderType</h3><p>Syntax: <code>!lattigo.bgv.encoder</code></p><p>This type represents the encoder for the BGV encryption scheme.</p><h3 id=bgvevaluatortype>BGVEvaluatorType</h3><p>Syntax: <code>!lattigo.bgv.evaluator</code></p><p>This type represents the evaluator for the BGV encryption scheme.</p><h3 id=bgvparametertype>BGVParameterType</h3><p>Syntax: <code>!lattigo.bgv.parameter</code></p><p>This type represents the parameters for the BGV encryption scheme.</p><h3 id=ckksencodertype>CKKSEncoderType</h3><p>Syntax: <code>!lattigo.ckks.encoder</code></p><p>This type represents the encoder for the CKKS encryption scheme.</p><h3 id=ckksevaluatortype>CKKSEvaluatorType</h3><p>Syntax: <code>!lattigo.ckks.evaluator</code></p><p>This type represents the evaluator for the CKKS encryption scheme.</p><h3 id=ckksparametertype>CKKSParameterType</h3><p>Syntax: <code>!lattigo.ckks.parameter</code></p><p>This type represents the parameters for the CKKS encryption scheme.</p><h3 id=rlweciphertexttype>RLWECiphertextType</h3><p>Syntax: <code>!lattigo.rlwe.ciphertext</code></p><p>This type represents the ciphertext for the RLWE encryption scheme.</p><h3 id=rlwedecryptortype>RLWEDecryptorType</h3><p>Syntax: <code>!lattigo.rlwe.decryptor</code></p><p>This type represents the decryptor for the RLWE encryption scheme.</p><h3 id=rlweencryptortype>RLWEEncryptorType</h3><p>Syntax:</p><pre tabindex=0><code>!lattigo.rlwe.encryptor&lt;
  bool   # publicKey
&gt;
</code></pre><p>This type represents the encryptor for the RLWE encryption scheme.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>publicKey</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=rlweevaluationkeysettype>RLWEEvaluationKeySetType</h3><p>Syntax: <code>!lattigo.rlwe.evaluation_key_set</code></p><p>This type represents the evaluation key set for the RLWE encryption scheme.</p><h3 id=rlwegaloiskeytype>RLWEGaloisKeyType</h3><p>Syntax:</p><pre tabindex=0><code>!lattigo.rlwe.galois_key&lt;
  ::mlir::IntegerAttr   # galoisElement
&gt;
</code></pre><p>This type represents the Galois key for the RLWE encryption scheme.</p><p>galoisElement: Enabling the automorphism X -> X^{galoisElement}.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>galoisElement</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td>An Attribute containing a integer value</td></tr></tbody></table><h3 id=rlwekeygeneratortype>RLWEKeyGeneratorType</h3><p>Syntax: <code>!lattigo.rlwe.key_generator</code></p><p>This type represents the key generator for the RLWE encryption scheme.</p><h3 id=rlweplaintexttype>RLWEPlaintextType</h3><p>Syntax: <code>!lattigo.rlwe.plaintext</code></p><p>This type represents the plaintext for the RLWE encryption scheme.</p><h3 id=rlwepublickeytype>RLWEPublicKeyType</h3><p>Syntax: <code>!lattigo.rlwe.public_key</code></p><p>This type represents the public key for the RLWE encryption scheme.</p><h3 id=rlwerelinearizationkeytype>RLWERelinearizationKeyType</h3><p>Syntax: <code>!lattigo.rlwe.relinearization_key</code></p><p>This type represents the relinearization key for the RLWE encryption scheme.</p><h3 id=rlwesecretkeytype>RLWESecretKeyType</h3><p>Syntax: <code>!lattigo.rlwe.secret_key</code></p><p>This type represents the secret key for the RLWE encryption scheme.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c5dda3cb8e694541eacbee638af7317d>8 - LWE</h1><h1 id=lwe-dialect>&rsquo;lwe&rsquo; Dialect</h1><p>The <code>lwe</code> dialect is a dialect for concepts related to cryptosystems
in the Learning With Errors (LWE) family.</p><p>See <a href=https://en.wikipedia.org/wiki/Learning_with_errors>Wikipedia</a>
for an overview of LWE and the related
<a href=https://en.wikipedia.org/wiki/Ring_learning_with_errors>RLWE</a>
problem.</p><p>While one might expect this dialect to contain types along the lines
of LWE and RLWE ciphertexts, and operations like encryption, decryption,
adding and multiplying ciphertexts, these concepts are not centralized
here because they are too scheme-specific.</p><p>Instead, this dialect provides attributes that can be attached to tensors
of integer or <code>poly.poly</code> types, which indicate that they are semantically
LWE and RLWE ciphertexts, respectively.</p><h2 id=lwe-attributes>LWE attributes</h2><h3 id=applicationdataattr>ApplicationDataAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.application_data&lt;
  mlir::Type,   # message_type
  Attribute   # overflow
&gt;
</code></pre><p>An attribute describing the semantics of the underlying application data.</p><p>The <code>messageType</code> parameter is used to describe the type and bits of the
original application data, e.g. i1, i32, f32. This type is later mapped
into the plaintext space of an FHE scheme by embedding, scaling, or other
techniques.</p><p>This attribute also contains information about the overflow semantics of the
data in the application. By default, we assume that the application program
was written so that the overflow is not expected and the overflow attribute
can can be <code>no_overflow</code>. For LWE-based CGGI ciphertexts, the overflow
attribute will usually be <code>preserve_overflow</code>, since messages will overflow
into padding bits.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>message_type</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>overflow</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=ciphertextspaceattr>CiphertextSpaceAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.ciphertext_space&lt;
  ::mlir::heir::polynomial::RingAttr,   # ring
  ::mlir::heir::lwe::LweEncryptionType,   # encryption_type
  unsigned   # size
&gt;
</code></pre><p>An attribute describing the ciphertext space and the transformation from
plaintext space to ciphertext space of an FHE scheme.</p><p>The ciphertext space information includes the ring attribute, describing the
space that the ciphertext elements belong to. The ring attribute contains a
coefficient type attribute that describes the semantics of the coefficient.
For example, a ring modulo $1 + x^1024$ with coefficients modulo $q =
298374$ will be described as</p><pre tabindex=0><code>!cmod = !mod_arith.int&lt;298374 : i64&gt;
#ring = #polynomial.ring&lt;coefficientType = !cmod, polynomialModulus = &lt;1 + x**1024&gt;&gt;
#ciphertext_space = #lwe.ciphertext_space&lt;ring = #ring, encryption_type = lsb&gt;
</code></pre><p>Ciphertexts using an RNS representation for $q$ will use an RNS type in
their ring&rsquo;s coefficient type attribute.</p><pre tabindex=0><code>!limb1 = !mod_arith.int&lt;2251799814045697 : i64&gt;
!limb2 = !mod_arith.int&lt;65537 : i64&gt;
#rns_mod = !rns.rns&lt;!limb1, !limb2&gt;
#ring = #polynomial.ring&lt;coefficientType = #rns_mod, polynomialModulus = &lt;1 + x**1024&gt;&gt;
#ciphertext_space = #lwe.ciphertext_space&lt;ring = #ring, encryption_type = lsb&gt;
</code></pre><p>Scalar LWE ciphertexts (like those used in CGGI) use an ideal polynomial of
degree 1, $x$. CGGI ciphertexts will typically use a power of two modulus
and may use a native integer type for its coefficient modulus.</p><pre tabindex=0><code>#ring = #polynomial.ring&lt;coefficientType = i32, polynomialModulus = &lt;1 + x**1024&gt;&gt;
#ciphertext_space = #lwe.ciphertext_space&lt;ring = #ring, encryption_type = lsb&gt;
</code></pre><p>The ciphertext encoding info is used to describe the way the plaintext data
is encoded into the ciphertext (in the MSB, LSB, or mixed).</p><p>The <code>size</code> parameter is used to describe the number of polynomials
comprising the ciphertext. This is typically 2 for RLWE ciphertexts that
are made up of an $(a, b)$ pair and greater than 2 for LWE instances. For
example, after an RLWE multiplication of two size 2 ciphertexts,
the ciphertext&rsquo;s size will be 3.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr><tr><td style=text-align:center>encryption_type</td><td style=text-align:center><code>::mlir::heir::lwe::LweEncryptionType</code></td><td></td></tr><tr><td style=text-align:center>size</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=coefficientencodingattr>CoefficientEncodingAttr</h3><p><em>An encoding of cleartexts directly as coefficients.</em></p><p>Syntax:</p><pre tabindex=0><code>#lwe.coefficient_encoding&lt;
  int64_t   # scaling_factor
&gt;
</code></pre><p>A coefficient encoding of a list of integers asserts that the coefficients
of the polynomials contain the integers, with the same semantics as
<code>constant_coefficient_encoding</code> for per-coefficient encodings.</p><p>A <code>scaling_factor</code> is optionally applied on the scalar when converting from
a rounded floating point to an integer.</p><p>Example:</p><pre tabindex=0><code>#coeff_encoding = #lwe.coefficient_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=constantcoefficientencodingattr>ConstantCoefficientEncodingAttr</h3><p><em>An encoding of a scalar in the constant coefficient</em></p><p>Syntax:</p><pre tabindex=0><code>#lwe.constant_coefficient_encoding&lt;
  int64_t   # scaling_factor
&gt;
</code></pre><p>An encoding of a single scalar into the constant coefficient of the plaintext.</p><p>All other coefficients of the plaintext are set to be zero. This encoding is
used to encode scalar LWE ciphertexts where the plaintext space is viewed
as a polynomial ring modulo <code>x</code>.</p><p>The scalar is first multiplied by the <code>scaling_factor</code> and then rounded to
the nearest integer before encoding into the plaintext coefficient.</p><p>Example:</p><pre tabindex=0><code>#coeff_encoding = #lwe.constant_coefficient_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=fullcrtpackingencodingattr>FullCRTPackingEncodingAttr</h3><p><em>An encoding of cleartexts via CRT slots.</em></p><p>Syntax:</p><pre tabindex=0><code>#lwe.full_crt_packing_encoding&lt;
  int64_t   # scaling_factor
&gt;
</code></pre><p>This encoding maps a list of integers via the Chinese Remainder Theorem (CRT) into the plaintext space.</p><p>Given a ring with irreducible ideal polynomial <code>f(x)</code> and coefficient
modulus <code>q</code>, <code>f(x)</code> can be decomposed modulo <code>q</code> into a direct product of
lower-degree polynomials. This allows full SIMD-style homomorphic operations
across the slots formed from each factor.</p><p>This attribute can only be used in the context of on full CRT packing, where
the polynomial <code>f(x)</code> splits completely (into linear factors) and the number
of slots equals the degree of <code>f(x)</code>. This happens when <code>q</code> is prime and <code>q = 1 mod n</code>.</p><p>A <code>scaling_factor</code> is optionally applied on the scalar when converting from
a rounded floating point to an integer.</p><p>Example:</p><pre tabindex=0><code>#coeff_encoding = #lwe.full_crt_packing_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=inversecanonicalencodingattr>InverseCanonicalEncodingAttr</h3><p><em>An encoding of cleartexts via the inverse canonical embedding.</em></p><p>Syntax:</p><pre tabindex=0><code>#lwe.inverse_canonical_encoding&lt;
  int64_t   # scaling_factor
&gt;
</code></pre><p>Let $n$ be the degree of the polynomials in the plaintext space. An
&ldquo;inverse_canonical_encoding&rdquo; of a list of real or complex values
$v_1, \dots, v_{n/2}$ is (almost) the inverse of the following decoding
map.</p><p>Define a map $\tau_N$ that maps a polynomial $p \in \mathbb{Z}[x] / (x^N + 1)
\to \mathbb{C}^{N/2}$ by evaluating it at the following $N/2$ points,
where $\omega = e^{2 \pi i / 2N}$ is the primitive $2N$th root of unity:</p><p>[
\omega, \omega^3, \omega^5, \dots, \omega^{N-1}
]</p><p>Then the complete decoding operation is $\textup{Decode}(p) =
(1/\Delta)\tau_N(p)$, where $\Delta$ is a scaling parameter and $\tau_N$ is
the truncated canonical embedding above. The encoding operation is the
inverse of the decoding operation, with some caveats explained below.</p><p>The map $\tau_N$ is derived from the so-called <em>canonical embedding</em>
$\tau$, though in the standard canonical embedding, we evaluate at all odd
powers of the root of unity, $\omega, \omega^3, \dots, \omega^{2N-1}$. For
polynomials in the slightly larger space $\mathbb{R}[x] / (x^N + 1)$, the
image of the canonical embedding is the subspace $H \subset \mathbb{C}^N$
defined by tuples $(z_1, \dots, z_N)$ such that $\overline{z_i} =
\overline{z_{N-i+1}}$. Note that this property holds because polynomial
evaluation commutes with complex conjugates, and the second half of the
roots of unity evaluate are complex conjugates of the first half. The
converse, that any such tuple with complex conjugate symmetry has an
inverse under $\tau$ with all real coefficients, makes $\tau$ is a
bijection onto $H$. $\tau$ and its inverse are explicitly computable as
discrete Fourier Transforms.</p><p>Because of the symmetry in canonical embedding for real polynomials, inputs
to this encoding can be represented as a list of $N/2$ complex points, with
the extra symmetric structure left implicit. $\tau_N$ and its inverse can
also be explicitly computed without need to expand the vectors to length
$N$.</p><p>The rounding step is required to invert the decoding because, while
cleartexts must be (implicitly) in the subspace $H$, they need not be the
output of $\tau_N$ for an <em>integer</em> polynomial. The rounding step ensures
we can use integer polynomial plaintexts for the FHE operations. There are
multiple rounding mechanisms, and this attribute does not specify which is
used, because in theory two ciphertexts that have used different roundings
are still compatible, though they may have different noise growth patterns.</p><p>The scaling parameter $\Delta$ is specified by the <code>scaling_factor</code>, which
are applied coefficient-wise using the same semantics as the
<code>constant_coefficient_encoding</code>.</p><p>A typical flow for the CKKS scheme using this encoding would be to apply an
inverse FFT operation to invert the canonical embedding to be a polynomial
with real coefficients, then encrypt scale the resulting polynomial&rsquo;s
coefficients according to the scaling parameters, then round to get integer
coefficients.</p><p>Example:</p><pre tabindex=0><code>#canonical_encoding = #lwe.inverse_canonical_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=keyattr>KeyAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.key&lt;
  int   # slot_index
&gt;
</code></pre><p>An attribute describing the key with which the message is currently
encrypted.</p><p>The key attribute describes the key with which the message is currently
encrypted and decryption can be performed. For example, if the decryption of
a ciphertext $c = (c_0(x), c_1(x))$ is performed by computing the inner
product $(c_0(x), c_1(x)) \cdot (1, s(x))$ then the key is $(1, s(x))$.</p><p>The <code>slot_index</code> describes the key after using a Galois automorphism to
rotate the plaintext slots by <code>slot_index</code>. This will correspond to an
action $\phi_k: x \rightarrow x^k$ for some <code>k</code> that depends on the
structure of the Galois group for the chosen scheme parameters. The
corresponding key will have a new basis $(1, s(x^(k)))$.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>slot_index</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=moduluschainattr>ModulusChainAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.modulus_chain&lt;
  ::llvm::ArrayRef&lt;mlir::IntegerAttr&gt;,   # elements
  int   # current
&gt;
</code></pre><p>An attribute describing the elements of the modulus chain of an RLWE scheme.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::IntegerAttr></code></td><td></td></tr><tr><td style=text-align:center>current</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=nooverflowattr>NoOverflowAttr</h3><p><em>An attribute informing that application data never overflows.</em></p><p>Syntax: <code>#lwe.no_overflow</code></p><p>This attribute informs lowerings that a program is written so that the message data
will never overflow beyond the message type.</p><p>// FIXME: Have a separate WraparoundOverflow, which lowers the same as NoOverflow?</p><h3 id=plaintextspaceattr>PlaintextSpaceAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.plaintext_space&lt;
  ::mlir::heir::polynomial::RingAttr,   # ring
  Attribute   # encoding
&gt;
</code></pre><p>An attribute describing the plaintext space and the transformation from
application data to plaintext space of an FHE scheme.</p><p>The plaintext space information is the ring structure, which contains the
plaintext modulus $t$, which may be a power of two in the case of CGGI
ciphertexts, or a prime power for RLWE. LWE ciphertexts use the
ideal polynomial of degree 1 $x$. The plaintext modulus used in LWE-based
CGGI plaintexts describes the full message space $\mathbb{Z}_p$ including
the padding bits. The application data info attribute describes the space
$\mathbb{Z}_p&rsquo;$ where $p&rsquo; &lt; p$ that the underlying message belongs to.</p><p>For RLWE schemes, this will include the type of encoding of application data
integers to a plaintext space <code>Z_p[X]/X^N + 1</code>. This may be a constant
coefficient encoding, CRT-based packing for SIMD semantics, or other slot
packing. When using full CRT packing, the ring must split into linear
factors. The CKKS scheme will also include attributes describing the complex
encoding, including the scaling factor, which will change after
multiplication and rescaling.</p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>Attribute</code></td><td>An encoding of a scalar in the constant coefficient or An encoding of cleartexts directly as coefficients. or An encoding of cleartexts via the inverse canonical embedding. or An encoding of cleartexts via CRT slots.</td></tr></tbody></table><h3 id=preserveoverflowattr>PreserveOverflowAttr</h3><p><em>An attribute informing that application data overflows in the message type.</em></p><p>Syntax: <code>#lwe.preserve_overflow</code></p><p>This attribute informs lowerings that a program is written so that the message data
may overflow beyond the message type.</p><h2 id=lwe-types>LWE types</h2><h3 id=lweciphertexttype>LWECiphertextType</h3><p><em>A ciphertext type</em></p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_ciphertext&lt;
  ApplicationDataAttr,   # application_data
  PlaintextSpaceAttr,   # plaintext_space
  CiphertextSpaceAttr,   # ciphertext_space
  KeyAttr,   # key
  ModulusChainAttr   # modulus_chain
&gt;
</code></pre><p>An LWE ciphertext will always contain the application data, plaintext space,
ciphertext space, and key information.</p><p>A modulus chain is optionally specified for parameter choices in RLWE
schemes that use more than one of modulus. When no modulus chain is
specified, the ciphertext modulus is always the ciphertext ring&rsquo;s
coefficient modulus.</p><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>application_data</td><td style=text-align:center><code>ApplicationDataAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintext_space</td><td style=text-align:center><code>PlaintextSpaceAttr</code></td><td></td></tr><tr><td style=text-align:center>ciphertext_space</td><td style=text-align:center><code>CiphertextSpaceAttr</code></td><td></td></tr><tr><td style=text-align:center>key</td><td style=text-align:center><code>KeyAttr</code></td><td></td></tr><tr><td style=text-align:center>modulus_chain</td><td style=text-align:center><code>ModulusChainAttr</code></td><td></td></tr></tbody></table><h3 id=lweplaintexttype>LWEPlaintextType</h3><p><em>A plaintext type</em></p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_plaintext&lt;
  ApplicationDataAttr,   # application_data
  PlaintextSpaceAttr   # plaintext_space
&gt;
</code></pre><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>application_data</td><td style=text-align:center><code>ApplicationDataAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintext_space</td><td style=text-align:center><code>PlaintextSpaceAttr</code></td><td></td></tr></tbody></table><h3 id=lwepublickeytype>LWEPublicKeyType</h3><p><em>A public key for LWE</em></p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_public_key&lt;
  KeyAttr,   # key
  ::mlir::heir::polynomial::RingAttr   # ring
&gt;
</code></pre><h4 id=parameters-11>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>key</td><td style=text-align:center><code>KeyAttr</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr></tbody></table><h3 id=lwesecretkeytype>LWESecretKeyType</h3><p><em>A secret key for LWE</em></p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_secret_key&lt;
  KeyAttr,   # key
  ::mlir::heir::polynomial::RingAttr   # ring
&gt;
</code></pre><h4 id=parameters-12>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>key</td><td style=text-align:center><code>KeyAttr</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr></tbody></table><h2 id=lwe-additional-definitions>LWE additional definitions</h2><h3 id=lweencryptiontype>LweEncryptionType</h3><p><em>An enum attribute representing an encryption method</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>msb</td><td style=text-align:center><code>0</code></td><td>msb</td></tr><tr><td style=text-align:center>lsb</td><td style=text-align:center><code>1</code></td><td>lsb</td></tr><tr><td style=text-align:center>mix</td><td style=text-align:center><code>2</code></td><td>mix</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-024e5f7d26a5dfbbc21bb90c29119ca6>9 - MathExt</h1><h1 id=math_ext-dialect>&lsquo;math_ext&rsquo; Dialect</h1><p>Math-related operations we require for HEIR
which do not (yet) exist in upstream <code>math</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b15a871dcca009396e70be943220c783>10 - Mgmt</h1><h1 id=mgmt-dialect>&lsquo;mgmt&rsquo; Dialect</h1><p>The <code>mgmt</code> dialect contains scheme-agnostic ciphertext management ops
(like relinearize and mod reduce), to enable initial high-level compiler
passes to perform a first pass at parameter selection, while lower-level
passes may refine them with scheme-specific information.</p><h2 id=mgmt-attributes>Mgmt attributes</h2><h3 id=mgmtattr>MgmtAttr</h3><p><em>Container attribute for all mgmt parameter</em></p><p>Syntax:</p><pre tabindex=0><code>#mgmt.mgmt&lt;
  int,   # level
  int,   # dimension
  int64_t   # scale
&gt;
</code></pre><p>This attribute is used to store all mgmt parameters.</p><p>The attribute is a struct with the following fields:</p><ul><li><code>level</code> : the level of the ciphertext, from L to 0</li><li><code>dimension</code> : the dimension of the ciphertext, defaults to 2</li></ul><p>Internally, this attribute is used by secret-to-<scheme>
for determining the level and dimension of the ciphertext.</p><p>It should be populated by &ndash;secret-with-mgmt-<scheme> before
going through the secret-to-<scheme> pass.</p><p>Example:</p><pre tabindex=0><code>#mgmt = #mgmt.mgmt&lt;level = 1&gt; // dimension defaults to 2
#mgmt1 = #mgmt.mgmt&lt;level = 1, dimension = 3&gt;
%0 = secret.generic(%arg0, %arg1 : !secret.secret&lt;i16&gt;) attrs = {mgmt.mgmt = #mgmt} {
   ...
} -&gt; !secret.secret&lt;i16&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>level</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>dimension</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>scale</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=openfheparamsattr>OpenfheParamsAttr</h3><p><em>Container attribute for some OpenFHE-specific parameters</em></p><p>Syntax:</p><pre tabindex=0><code>#mgmt.openfhe_params&lt;
  int,   # evalAddCount
  int   # keySwitchCount
&gt;
</code></pre><p>This attribute is used to store some OpenFHE-specific parameters.</p><p>The attribute is a struct with the following fields:</p><ul><li><code>evalAddCount</code> : param for OpenFHE SetEvalAddCount</li><li><code>keySwitchCount</code> : param for OpenFHE SetKeySwitchCount</li></ul><p>When this attribute presents, the lowering of openfhe pass
will use these parameters to set the corresponding OpenFHE
parameters.</p><p>It should be populated by &ndash;secret-with-mgmt-bgv before
going through the secret-to-bgv bgv-to-openfhe pass.</p><p>Example:</p><pre tabindex=0><code>#openfhe_params = #mgmt.openfhe_params&lt;evalAddCount = 1, keySwitchCount = 1&gt;
</code></pre><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>evalAddCount</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>keySwitchCount</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-75945813f3978b67fb0398cc4f17cb8b>11 - ModArith</h1><h1 id=mod_arith-dialect>&lsquo;mod_arith&rsquo; Dialect</h1><p>The <code>mod_arith</code> dialect contains operations used for modulo arithmetic.</p><h2 id=modarith-types>ModArith types</h2><h3 id=modarithtype>ModArithType</h3><p><em>Integer type with modular arithmetic</em></p><p>Syntax:</p><pre tabindex=0><code>!mod_arith.int&lt;
  ::mlir::IntegerAttr   # modulus
&gt;
</code></pre><p><code>mod_arith.int&lt;p></code> represents an element of the ring of integers modulo $p$.
The <code>modulus</code> attribute is the ring modulus, and <code>mod_arith</code> operations lower to
<code>arith</code> operations that produce results in the range <code>[0, modulus)</code>, often called
the <em>canonical representative</em>.</p><p><code>modulus</code> is specified with an integer type suffix, for example,
<code>mod_arith.int&lt;65537 : i32></code>. This corresponds to the storage type for the
modulus, and is <code>i64</code> by default.</p><p>It is required that the underlying integer type should be larger than
twice the modulus (have one extra bit of storage space) to avoid signedness
issues. For example, when <code>modulus == 2 ** 32 - 1</code>, the underlying type
for the modulus should be at least <code>i33</code>, though <code>i64</code> is a natural choice.</p><p>Passes may allow intermediate values that do not always produce a
canonical representative in <code>[0, modulus)</code>. For example, if the machine storage
type is <code>i64</code>, but the <code>modulus</code> fits within an <code>i32</code>, a lowering could
allow intermediate arithmetic values to grow to as large as an <code>i64</code> before
reducing them. However, all passes must ensure that values used outside
the local scope (e.g., function return values or arguments to calls to linked
functions) are appropriately reduced to the canonical representative.
<code>modulus</code> is the modulus the arithmetic working with.</p><p>Examples:</p><pre tabindex=0><code>!Zp1 = !mod_arith.int&lt;7&gt; // implicitly being i64
!Zp2 = !mod_arith.int&lt;65537 : i32&gt;
!Zp3 = !mod_arith.int&lt;536903681 : i64&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>modulus</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e397c035ea096bd861aadf40d3fccd0a>12 - Openfhe</h1><h1 id=openfhe-dialect>&lsquo;openfhe&rsquo; Dialect</h1><p>The <code>openfhe</code> dialect is an exit dialect for generating c++ code against the OpenFHE library API.</p><p>See <a href=https://github.com/openfheorg/openfhe-development>https://github.com/openfheorg/openfhe-development</a></p><h2 id=openfhe-types>Openfhe types</h2><h3 id=ccparamstype>CCParamsType</h3><p><em>The CCParams required to create CryptoContext.</em></p><p>Syntax: <code>!openfhe.cc_params</code></p><h3 id=cryptocontexttype>CryptoContextType</h3><p><em>The CryptoContext required to perform homomorphic operations in OpenFHE.</em></p><p>Syntax: <code>!openfhe.crypto_context</code></p><h3 id=digitdecompositiontype>DigitDecompositionType</h3><p><em>A precomputed digit decomposition for for EvalFastRotation</em></p><p>Syntax: <code>!openfhe.digit_decomp</code></p><h3 id=evalkeytype>EvalKeyType</h3><p><em>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.</em></p><p>Syntax: <code>!openfhe.eval_key</code></p><h3 id=privatekeytype>PrivateKeyType</h3><p><em>The private key required to decrypt a ciphertext in OpenFHE.</em></p><p>Syntax: <code>!openfhe.private_key</code></p><h3 id=publickeytype>PublicKeyType</h3><p><em>The public key required to encrypt plaintext in OpenFHE.</em></p><p>Syntax: <code>!openfhe.public_key</code></p></div><div class=td-content style=page-break-before:always><h1 id=pg-ef2cb05e00e8510bb8a622ae4be9966f>13 - Orion</h1><h1 id=orion-dialect>&lsquo;orion&rsquo; Dialect</h1><p>The <code>orion</code> dialect is an entry dialect for the <a href=https://arxiv.org/abs/2311.03470>Orion compiler</a>
into the heir ecosystem. It is primarily intended to enable comparisons between Orion and HEIR.</p><p>Because an existing translator was written that converts from Orion to HEIR&rsquo;s CKKS dialect,
this dialect serves to include the ops not supported by the CKKS dialect, but which are
expressed as black boxes by Orion.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b18fea903e4651113f5317788f1491e1>14 - Polynomial</h1><h1 id=polynomial-dialect>&lsquo;polynomial&rsquo; Dialect</h1><p>The Polynomial dialect defines single-variable polynomial types and
operations.</p><p>The simplest use of <code>polynomial</code> is to represent mathematical operations in
a polynomial ring <code>R[x]</code>, where <code>R</code> is another MLIR type like <code>i32</code>.</p><p>More generally, this dialect supports representing polynomial operations in a
quotient ring <code>R[X]/(f(x))</code> for some statically fixed polynomial <code>f(x)</code>.
Two polyomials <code>p(x), q(x)</code> are considered equal in this ring if they have the
same remainder when dividing by <code>f(x)</code>. When a modulus is given, ring operations
are performed with reductions modulo <code>f(x)</code> and relative to the coefficient ring
<code>R</code>.</p><p>Examples:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A constant polynomial in a ring with i32 coefficients and no polynomial modulus
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%a</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>3x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A constant polynomial in a ring with i32 coefficients, modulo (x^1024 + 1)
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#modulus</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#modulus</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%a</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>3x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A constant polynomial in a ring with i32 coefficients, with a polynomial
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// modulus of (x^1024 + 1) and a coefficient modulus of 17.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#modulus</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>coeff_ty =</span> <span style=color:#000;font-weight:700>!</span>mod_arith<span style=color:#000;font-weight:700>.</span>int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>17</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#000;font-weight:700>!</span>coeff_ty<span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#modulus</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%a</span> <span style=color:#000;font-weight:700>=</span> polynomial<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>2</span> <span style=color:#a40000>-</span> <span style=color:#0000cf;font-weight:700>3x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h2 id=polynomial-attributes>Polynomial attributes</h2><h3 id=chebyshevpolynomialattr>ChebyshevPolynomialAttr</h3><p><em>An attribute containing a single-variable polynomial with float coefficients in the Chebyshev basis</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.chebyshev_polynomial&lt;
  ArrayAttr   # coefficients
&gt;
</code></pre><p>This attribute represents a single-variable polynomial with double
precision floating point coefficients, represented in the basis of
Chebyshev polynomials of the first kind.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.chebyshev_polynomial</span><span style=color:#000;font-weight:700>&lt;[</span><span style=color:#0000cf;font-weight:700>1.0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2.0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3.0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4.0</span><span style=color:#000;font-weight:700>]&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>coefficients</td><td style=text-align:center><code>ArrayAttr</code></td><td></td></tr></tbody></table><h3 id=floatpolynomialattr>FloatPolynomialAttr</h3><p><em>An attribute containing a single-variable polynomial with double precision floating point coefficients</em></p><p>A polynomial attribute represents a single-variable polynomial with double
precision floating point coefficients.</p><p>The polynomial must be expressed as a list of monomial terms, with addition
or subtraction between them. The choice of variable name is arbitrary, but
must be consistent across all the monomials used to define a single
attribute. The order of monomial terms is arbitrary, each monomial degree
must occur at most once.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.float_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>0.5</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>1.5</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>polynomial</td><td style=text-align:center><code>FloatPolynomial</code></td><td></td></tr></tbody></table><h3 id=intpolynomialattr>IntPolynomialAttr</h3><p><em>An attribute containing a single-variable polynomial with integer coefficients</em></p><p>A polynomial attribute represents a single-variable polynomial with integer
coefficients, which is used to define the modulus of a <code>RingAttr</code>, as well
as to define constants and perform constant folding for <code>polynomial</code> ops.</p><p>The polynomial must be expressed as a list of monomial terms, with addition
or subtraction between them. The choice of variable name is arbitrary, but
must be consistent across all the monomials used to define a single
attribute. The order of monomial terms is arbitrary, each monomial degree
must occur at most once.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;x**</span><span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>polynomial</td><td style=text-align:center><code>::mlir::heir::polynomial::IntPolynomial</code></td><td></td></tr></tbody></table><h3 id=primitiverootattr>PrimitiveRootAttr</h3><p><em>An attribute containing an integer and its degree as a root of unity</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.primitive_root&lt;
  ::mlir::IntegerAttr,   # value
  ::mlir::IntegerAttr   # degree
&gt;
</code></pre><p>A primitive root attribute stores an integer root <code>value</code> and an integer
<code>degree</code>, corresponding to a primitive root of unity of the given degree in
an unspecified ring.</p><p>This is used as an attribute on <code>polynomial.ntt</code> and <code>polynomial.intt</code> ops
to specify the root of unity used in lowering the transform.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.primitive_root</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>value=</span><span style=color:#0000cf;font-weight:700>123</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> degree <span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>7</span> <span style=color:#204a87;font-weight:700>index</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td></td></tr><tr><td style=text-align:center>degree</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td></td></tr></tbody></table><h3 id=ringattr>RingAttr</h3><p><em>An attribute specifying a polynomial ring</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.ring&lt;
  Type,   # coefficientType
  ::mlir::heir::polynomial::IntPolynomialAttr   # polynomialModulus
&gt;
</code></pre><p>A ring describes the domain in which polynomial arithmetic occurs. The ring
attribute in <code>polynomial</code> represents the more specific case of polynomials
with a single indeterminate; whose coefficients can be represented by
another MLIR type (<code>coefficientType</code>).</p><p>All semantics pertaining to arithmetic in the ring must be owned by the
coefficient type. For example, if the polynomials are with integer
coefficients taken modulo a prime $p$, then <code>coefficientType</code> must be a
type that represents integers modulo $p$, such as <code>mod_arith&lt;p></code>.</p><p>Additionally, a polynomial ring may specify a <code>polynomialModulus</code>, which
converts polynomial arithmetic to the analogue of modular integer
arithmetic, where each polynomial is represented as its remainder when
dividing by the modulus. For single-variable polynomials, a polynomial
modulus is always specified via a single polynomial.</p><p>An expressive example is polynomials with i32 coefficients, whose
coefficients are taken modulo <code>2**32 - 5</code>, with a polynomial modulus of
<code>x**1024 - 1</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#poly_mod</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.int_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>-1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>1024</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#ring</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.ring</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>polynomialModulus=</span><span style=color:#000>#poly_mod</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>...</span> <span style=color:#000;font-weight:700>:</span> polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#000>#ring</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>In this case, the value of a polynomial is always &ldquo;converted&rdquo; to a
canonical form by applying repeated reductions by setting <code>x**1024 = 1</code>
and simplifying.</p><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>coefficientType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>polynomialModulus</td><td style=text-align:center><code>::mlir::heir::polynomial::IntPolynomialAttr</code></td><td></td></tr></tbody></table><h3 id=typedchebyshevpolynomialattr>TypedChebyshevPolynomialAttr</h3><p><em>A typed chebyshev_polynomial</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.typed_chebyshev_polynomial&lt;
  ::mlir::Type,   # type
  ::mlir::heir::polynomial::ChebyshevPolynomialAttr   # value
&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>poly_ty =</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring=</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> float<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1.4</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4.5</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span><span style=display:flex><span><span style=color:#000>#poly_verbose</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.typed_chebyshev_polynomial</span><span style=color:#000;font-weight:700>&lt;[</span><span style=color:#0000cf;font-weight:700>1.4</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>4.5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>6.0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>7.0</span><span style=color:#000;font-weight:700>]&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span></code></pre></div><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::heir::polynomial::ChebyshevPolynomialAttr</code></td><td></td></tr></tbody></table><h3 id=typedfloatpolynomialattr>TypedFloatPolynomialAttr</h3><p><em>A typed float_polynomial</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.typed_float_polynomial&lt;
  ::mlir::Type,   # type
  ::mlir::heir::polynomial::FloatPolynomialAttr   # value
&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>poly_ty =</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring=</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> float<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1.4</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4.5</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span><span style=display:flex><span><span style=color:#000>#poly_verbose</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.typed_float_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1.4</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4.5</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span></code></pre></div><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::heir::polynomial::FloatPolynomialAttr</code></td><td></td></tr></tbody></table><h3 id=typedintpolynomialattr>TypedIntPolynomialAttr</h3><p><em>A typed int_polynomial</em></p><p>Syntax:</p><pre tabindex=0><code>#polynomial.typed_int_polynomial&lt;
  ::mlir::Type,   # type
  ::mlir::heir::polynomial::IntPolynomialAttr   # value
&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>poly_ty =</span> <span style=color:#000;font-weight:700>!</span>polynomial<span style=color:#000;font-weight:700>.</span>polynomial<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring=</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>coefficientType=</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#poly</span> <span style=color:#000;font-weight:700>=</span> int<span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1 x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span><span style=display:flex><span><span style=color:#000>#poly_verbose</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#polynomial.typed_int_polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1 x</span><span style=color:#000;font-weight:700>**</span><span style=color:#0000cf;font-weight:700>7</span> <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>poly_ty
</span></span></code></pre></div><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::heir::polynomial::IntPolynomialAttr</code></td><td></td></tr></tbody></table><h2 id=polynomial-types>Polynomial types</h2><h3 id=polynomialtype>PolynomialType</h3><p><em>An element of a polynomial ring.</em></p><p>Syntax:</p><pre tabindex=0><code>!polynomial.polynomial&lt;
  ::mlir::heir::polynomial::RingAttr   # ring
&gt;
</code></pre><p>A type for polynomials in a polynomial quotient ring.</p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td>an attribute specifying a polynomial ring</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c9ea40a8d17399f57cdd3c18b53cedef>15 - Random</h1><h1 id=random-dialect>&lsquo;random&rsquo; Dialect</h1><p>The <code>random</code> dialect contains operations used to generate random numbers.</p><h2 id=random-types>Random types</h2><h3 id=distributiontype>DistributionType</h3><p><em>A random distribution type</em></p><p>Syntax:</p><pre tabindex=0><code>!random.distribution&lt;
  ::mlir::heir::random::Distribution   # distribution_type
&gt;
</code></pre><p>A generic type, representing a specific random distribution type of either
uniform or gaussian as an attribute ($distribution_type).</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>distribution_type</td><td style=text-align:center><code>::mlir::heir::random::Distribution</code></td><td></td></tr></tbody></table><h3 id=prngtype>PRNGType</h3><p><em>A pseudorandom number generator type</em></p><p>Syntax: <code>!random.prng</code></p><p>A type that provides pseudorandom number generator.</p><h2 id=random-additional-definitions>Random additional definitions</h2><h3 id=distribution>Distribution</h3><p><em>An enum attribute representing a random distribution</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>uniform</td><td style=text-align:center><code>0</code></td><td>uniform</td></tr><tr><td style=text-align:center>gaussian</td><td style=text-align:center><code>1</code></td><td>gaussian</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-aeae60b865ac85372556b396a5a052ce>16 - RNS</h1><h1 id=rns-dialect>&lsquo;rns&rsquo; Dialect</h1><p>The <code>rns</code> dialect represents types and ops related to residue number
system (RNS) representations of ring-like types, such as integers or
polynomials decomposed from high-bit width to lower-bit-width prime
moduli. Sometimes RNS is referred to as CRT, for &ldquo;Chinese Remainder
Theorem.&rdquo;</p><p>This dialect is intended to be as generic as possible in terms of its
interaction with standard MLIR. However, because of upstream MLIR
constraints, we do not have the ability to override, say, <code>arith.addi</code>
to operate on an <code>rns</code> type. So such situations require dedicated ops,
canonicalization patterns, etc.</p><h2 id=rns-types>RNS types</h2><h3 id=rnstype>RNSType</h3><p><em>A residue number system representation</em></p><p>Syntax:</p><pre tabindex=0><code>!rns.rns&lt;
  ::llvm::ArrayRef&lt;mlir::Type&gt;   # basisTypes
&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>basisTypes</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::Type></code></td><td></td></tr></tbody></table><h2 id=rns-additional-definitions>RNS additional definitions</h2><h1 id=typeinterface-definitions>TypeInterface definitions</h1><h2 id=rnsbasistypeinterface-rnsbasistypeinterface>RNSBasisTypeInterface (<code>RNSBasisTypeInterface</code>)</h2><p>This interface is required for a type to be used as a parameter
to an <code>rns</code> type.</p><h3 id=methods>Methods:</h3><h4 id=iscompatiblewith><code>isCompatibleWith</code></h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#204a87;font-weight:700>bool</span> <span style=color:#000>isCompatibleWith</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>mlir</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Type</span> <span style=color:#000>otherRnsBasisType</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>Returns true if this type is compatible with another type in the
same RNS basis. In particular, the set of types used for a single
RNS basis are never equal as types, but instead have some common
attribute that must be checked here. For example, an RNS type where
the basis types are polynomials would return true if the two types
are both polynomial types, even if they have different coefficient
moduli.</p><p>Another example is using mod arith types as the basis types, where
by the nature of chinese reminder theorem, it is required that
the modulus of them must be mutually coprime.</p><p><code>isCompatibleWith</code> must be commutative, in the sense
that <code>type1.isCompatibleWith(type2)</code> if and only if
<code>type2.isCompatibleWith(type1)</code>.</p><p>NOTE: This method <em>must</em> be implemented by the user.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f7ffac8ba93b73b8a62e185ec8643d63>17 - Secret</h1><h1 id=secret-dialect>&lsquo;secret&rsquo; Dialect</h1><p>Secret is a dialect for computations that operate on encrypted data.</p><p>Secret is intended to serve as a scheme-agnostic front-end for the HEIR
ecosystem of dialects. It is supposed to be fully interoperable with the
rest of MLIR via secret.generic, while lower-level HEIR dialects would have
custom types for arithmetic on secret integers of various bit widths.</p><h2 id=secret-attributes>Secret attributes</h2><h3 id=kernelattr>KernelAttr</h3><p><em>An annotation describing an implementation kernel for a given op.</em></p><p>Syntax:</p><pre tabindex=0><code>#secret.kernel&lt;
  ::mlir::heir::KernelName,   # name
  bool   # force
&gt;
</code></pre><p>This attribute is used for two purposes:</p><ol><li>To allow the input IR to annotate fixed kernels on ops that the rest of the
compiler must respect.</li><li>To allow the layout optimization pipeline to materialize its kernel selection
decisions to the IR.</li></ol><p>The <code>name</code> field corresponds to an internally-defined kernel name, and if
<code>force</code> is set to <code>true</code>, then the kernel may not be overridden by HEIR&rsquo;s
internal passes.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::heir::KernelName</code></td><td></td></tr><tr><td style=text-align:center>force</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h2 id=secret-types>Secret types</h2><h3 id=secrettype>SecretType</h3><p><em>A secret value</em></p><p>Syntax:</p><pre tabindex=0><code>!secret.secret&lt;
  Type   # valueType
&gt;
</code></pre><p>A generic wrapper around another MLIR type, representing an encrypted value
but not specifying the manner of encryption. This is useful in HEIR because
the compiler may choose various details of the FHE scheme based on the
properties of the input program, the backend target hardware, and cost
models of the various passes.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>valueType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ca9ddb02db7c0683037407c6f9eb1f2a>18 - TensorExt</h1><h1 id=tensor_ext-dialect>&rsquo;tensor_ext&rsquo; Dialect</h1><p>The <code>tensor_ext</code> dialect contains operations on plaintext tensors that
correspond to the computation model of certain FHE schemes, but are
unlikely to be upstreamed to MLIR due to their specificity to FHE.</p><h2 id=tensorext-attributes>TensorExt attributes</h2><h3 id=layoutattr>LayoutAttr</h3><p><em>The description of the layout of a data-semantic tensor.</em></p><p>Syntax:</p><pre tabindex=0><code>#tensor_ext.layout&lt;
  mlir::StringAttr   # layout
&gt;
</code></pre><p>This attribute describes how a data-semantic tensor is laid out among a
tensor of ciphertexts. The layout is described by an integer relation $(d,
s)$, where $d$ is a multiset of data-semantic tensor indices and $s$ is a
multiset of slot indices (or coefficient indices). The slot indices are
defined by two indices: the ciphertext index and the slot index in that
order. The elements of the relation are defined by a set of quasi-affine
constraints.</p><p>I.e., a point $((2, 3), (7, 0))$ in the relation says that the data entry
at index $(2, 3)$ is placed in slot 0 of ciphertext 7. This could be
defined as part of the relation by a constraint like <code>row + col + 2 - ct + slot = 0</code>.</p><p>The attribute stores a string representation of the integer relation,
which follows the ISL syntax for <code>isl_basic_map</code>. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#vec_layout</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.layout</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;{ [i0] -&gt; [ct, slot] : (i0 - slot) mod 1024 = 7 and i0 &gt;= 0 and 0 &gt;= i0 and slot &gt;= 0 and 1023 &gt;= slot and ct = 0 }&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>#mat_layout</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.layout</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;{ [row, col] -&gt; [ct, slot] : (slot - row) mod 512 = 0 and (ct + slot - col) mod 512 = 0 and row &gt;= 0 and col &gt;= 0 and ct &gt;= 0 and slot &gt;= 0 and 1023 &gt;= slot and 511 &gt;= ct and 511 &gt;= row and 511 &gt;= col }&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Example with local (existential) variables.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#layout</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.layout</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;{[d0] -&gt; [ct, slot] : exists d3, d4 : -ct + d3 = 0 and d0 - d4 * 1024 = 0 and -d0 + 31 &gt;= 0 and d0 &gt;= 0 and ct &gt;= 0 and slot &gt;= 0 and -slot + 1023 &gt;= 0 and -d0 + d3 * 1024 + 1023 &gt;= 0 and d0 - d3 * 1024 &gt;= 0 and -d0 + d4 * 1024 + 1023 &gt;= 0 and d0 - d4 * 1024 &gt;= 0 }&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>layout</td><td style=text-align:center><code>mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=originaltypeattr>OriginalTypeAttr</h3><p><em>The original type of a secret tensor whose layout has been converted to ciphertext semantics.</em></p><p>Syntax:</p><pre tabindex=0><code>#tensor_ext.original_type&lt;
  ::mlir::Type,   # originalType
  ::mlir::Attribute   # layout
&gt;
</code></pre><p>This attribute is used to retain the original type of a secret tensor after
its conversion to ciphertext semantics, i.e. after applying any padding or
alignment to fill ciphertext data types. For example, if a
<code>!secret.secret&lt;tensor&lt;32xi8>></code> is laid out in a ciphertext with
1024 slots, the new type would be <code>!secret.secret&lt;tensor&lt;1024xi8>></code>
with attribute <code>tensor_ext.original_type&lt;!secret.secret&lt;tensor&lt;32xi8>></code>.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>originalType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>layout</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-678c1db0f9b2ed4c9d43b790f890bea0>19 - TfheRust</h1><h1 id=tfhe_rust-dialect>&rsquo;tfhe_rust&rsquo; Dialect</h1><p>The <code>thfe_rust</code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the shortint parameters and encoding scheme.</p><p>See <a href=https://github.com/zama-ai/tfhe-rs>https://github.com/zama-ai/tfhe-rs</a></p><h2 id=tfherust-types>TfheRust types</h2><h3 id=encryptedbooltype>EncryptedBoolType</h3><p><em>An encrypted bool corresponding to tfhe-rs&rsquo;s FHEBool, not in the Boolean TFHE-rs.
Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp.</em></p><p>Syntax: <code>!tfhe_rust.bool</code></p><h3 id=encryptedint2type>EncryptedInt2Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt2 type</em></p><p>Syntax: <code>!tfhe_rust.ei2</code></p><h3 id=encryptedint4type>EncryptedInt4Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt4 type</em></p><p>Syntax: <code>!tfhe_rust.ei4</code></p><h3 id=encryptedint8type>EncryptedInt8Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type</em></p><p>Syntax: <code>!tfhe_rust.ei8</code></p><h3 id=encryptedint16type>EncryptedInt16Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type</em></p><p>Syntax: <code>!tfhe_rust.ei16</code></p><h3 id=encryptedint32type>EncryptedInt32Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type</em></p><p>Syntax: <code>!tfhe_rust.ei32</code></p><h3 id=encryptedint64type>EncryptedInt64Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type</em></p><p>Syntax: <code>!tfhe_rust.ei64</code></p><h3 id=encryptedint128type>EncryptedInt128Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type</em></p><p>Syntax: <code>!tfhe_rust.ei128</code></p><h3 id=encryptedint256type>EncryptedInt256Type</h3><p><em>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type</em></p><p>Syntax: <code>!tfhe_rust.ei256</code></p><h3 id=encrypteduint2type>EncryptedUInt2Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type</em></p><p>Syntax: <code>!tfhe_rust.eui2</code></p><h3 id=encrypteduint3type>EncryptedUInt3Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type</em></p><p>Syntax: <code>!tfhe_rust.eui3</code></p><h3 id=encrypteduint4type>EncryptedUInt4Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type</em></p><p>Syntax: <code>!tfhe_rust.eui4</code></p><h3 id=encrypteduint8type>EncryptedUInt8Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type</em></p><p>Syntax: <code>!tfhe_rust.eui8</code></p><h3 id=encrypteduint10type>EncryptedUInt10Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type</em></p><p>Syntax: <code>!tfhe_rust.eui10</code></p><h3 id=encrypteduint12type>EncryptedUInt12Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type</em></p><p>Syntax: <code>!tfhe_rust.eui12</code></p><h3 id=encrypteduint14type>EncryptedUInt14Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type</em></p><p>Syntax: <code>!tfhe_rust.eui14</code></p><h3 id=encrypteduint16type>EncryptedUInt16Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type</em></p><p>Syntax: <code>!tfhe_rust.eui16</code></p><h3 id=encrypteduint32type>EncryptedUInt32Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type</em></p><p>Syntax: <code>!tfhe_rust.eui32</code></p><h3 id=encrypteduint64type>EncryptedUInt64Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type</em></p><p>Syntax: <code>!tfhe_rust.eui64</code></p><h3 id=encrypteduint128type>EncryptedUInt128Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type</em></p><p>Syntax: <code>!tfhe_rust.eui128</code></p><h3 id=encrypteduint256type>EncryptedUInt256Type</h3><p><em>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type</em></p><p>Syntax: <code>!tfhe_rust.eui256</code></p><h3 id=lookuptabletype>LookupTableType</h3><p><em>A univariate lookup table used for programmable bootstrapping.</em></p><p>Syntax: <code>!tfhe_rust.lookup_table</code></p><h3 id=serverkeytype>ServerKeyType</h3><p><em>The short int server key required to perform homomorphic operations.</em></p><p>Syntax: <code>!tfhe_rust.server_key</code></p></div><div class=td-content style=page-break-before:always><h1 id=pg-d46d9ee8aeb1f8889ca7cfc9a061a7cc>20 - TfheRustBool</h1><h1 id=tfhe_rust_bool-dialect>&rsquo;tfhe_rust_bool&rsquo; Dialect</h1><p>The <code>tfhe_rust_bool</code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the boolean parameter set.</p><p>See <a href=https://github.com/zama-ai/tfhe-rs>https://github.com/zama-ai/tfhe-rs</a></p><h2 id=tfherustbool-attributes>TfheRustBool attributes</h2><h3 id=tfherustboolgatesattr>TfheRustBoolGatesAttr</h3><p><em>An Attribute containing an array of strings to store bool gates</em></p><p>Syntax:</p><pre tabindex=0><code>#tfhe_rust_bool.tfhe_rust_bool_gates&lt;
  ::llvm::ArrayRef&lt;::mlir::heir::tfhe_rust_bool::TfheRustBoolGateEnumAttr&gt;   # gates
&gt;
</code></pre><p>This attributes stores a list of integer identifiers for Boolean gates.</p><p>Uses following mapping:
AND_GATE = 0;
NAND_GATE = 1;
OR_GATE = 2;
NOR_GATE = 3;
XOR_GATE = 4;
XNOR_GATE = 5;
NOT_GATE = 6;</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>gates</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::heir::tfhe_rust_bool::TfheRustBoolGateEnumAttr></code></td><td></td></tr></tbody></table><h2 id=tfherustbool-types>TfheRustBool types</h2><h3 id=encryptedbooltype>EncryptedBoolType</h3><p><em>An encrypted Boolean corresponding to tfhe-rs&rsquo;s FHEBool type</em></p><p>Syntax: <code>!tfhe_rust_bool.eb</code></p><h3 id=packedserverkeytype>PackedServerKeyType</h3><p><em>The Belfort packed API boolean server key.</em></p><p>Syntax: <code>!tfhe_rust_bool.server_key_enum</code></p><h3 id=serverkeytype>ServerKeyType</h3><p><em>The boolean server key required to perform homomorphic operations.</em></p><p>Syntax: <code>!tfhe_rust_bool.server_key</code></p><h2 id=tfherustbool-additional-definitions>TfheRustBool additional definitions</h2><h3 id=tfherustboolgateenum>TfheRustBoolGateEnum</h3><p><em>An enum attribute representing a TFHE-rs boolean gate using u8 int</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>AND</td><td style=text-align:center><code>0</code></td><td>AND</td></tr><tr><td style=text-align:center>NAND</td><td style=text-align:center><code>1</code></td><td>NAND</td></tr><tr><td style=text-align:center>OR</td><td style=text-align:center><code>2</code></td><td>OR</td></tr><tr><td style=text-align:center>NOR</td><td style=text-align:center><code>3</code></td><td>NOR</td></tr><tr><td style=text-align:center>XOR</td><td style=text-align:center><code>4</code></td><td>XOR</td></tr><tr><td style=text-align:center>XNOR</td><td style=text-align:center><code>5</code></td><td>XNOR</td></tr><tr><td style=text-align:center>NOT</td><td style=text-align:center><code>6</code></td><td>NOT</td></tr></tbody></table></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/google/heir aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2025 The HEIR Authors All Rights Reserved</span>
<span class=ms-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.027d75d71824837bee74c12a7806c5fe51249c1ca7accc27553a251a75cdb3a4.js integrity="sha256-An111xgkg3vudMEqeAbF/lEknBynrMwnVTolGnXNs6Q=" crossorigin=anonymous></script>
<script defer src=/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>