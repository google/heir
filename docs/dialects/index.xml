<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HEIR â€“ Dialects</title><link>https://heir.dev/docs/dialects/</link><description>Recent content in Dialects on HEIR</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://heir.dev/docs/dialects/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: BGV</title><link>https://heir.dev/docs/dialects/bgv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/bgv/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="bgv-dialect">&amp;lsquo;bgv&amp;rsquo; Dialect&lt;/h1>
&lt;p>The BGV dialect defines the types and operations of the BGV and B/FV cryptosystem.&lt;/p>
&lt;p>Due to similarity with the BFV scheme, BGV dialect also represents the B/FV scheme.&lt;/p>
&lt;p>The semantics of bgv dialect operations are determined by the &lt;code>scheme.bgv&lt;/code> or &lt;code>scheme.bfv&lt;/code>
annotation at the module level.&lt;/p>
&lt;p>In B/FV mode, bgv.modulus_switch is an no-op.&lt;/p>
&lt;h2 id="bgv-attributes">BGV attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="schemeparamattr">SchemeParamAttr&lt;/h3>
&lt;p>&lt;em>BGV Scheme Parameters&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#bgv.scheme_param&amp;lt;
int, # logN
DenseI64ArrayAttr, # Q
DenseI64ArrayAttr, # P
int64_t, # plaintextModulus
BGVEncryptionType, # encryptionType
BGVEncryptionTechnique # encryptionTechnique
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute is used for recording the scheme parameters for CKKS.&lt;/p>
&lt;p>The attribute is a struct with the following fields:&lt;/p>
&lt;ul>
&lt;li>&lt;code>int&lt;/code> logN: The log of the degree of the polynomial modulus.&lt;/li>
&lt;li>&lt;code>DenseI64ArrayAttr&lt;/code> Q: The array of primes in the ciphertext modulus.&lt;/li>
&lt;li>&lt;code>DenseI64ArrayAttr&lt;/code> P: The array of primes in the special modulus, used for key switching.&lt;/li>
&lt;li>&lt;code>int64_t&lt;/code> plaintextModulus: The plaintext modulus.&lt;/li>
&lt;/ul>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">logN&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Q&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">P&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">plaintextModulus&lt;/td>
&lt;td style="text-align:center">&lt;code>int64_t&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">encryptionType&lt;/td>
&lt;td style="text-align:center">&lt;code>BGVEncryptionType&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">encryptionTechnique&lt;/td>
&lt;td style="text-align:center">&lt;code>BGVEncryptionTechnique&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="bgv-ops">BGV ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="bgvadd-heirbgvaddop">&lt;code>bgv.add&lt;/code> (heir::bgv::AddOp)&lt;/h3>
&lt;p>&lt;em>Addition operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvadd_plain-heirbgvaddplainop">&lt;code>bgv.add_plain&lt;/code> (heir::bgv::AddPlainOp)&lt;/h3>
&lt;p>&lt;em>Addition operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.add_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AllCiphertextTypesMatch&lt;/code>, &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>IsCiphertextPlaintextOp&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvextract-heirbgvextractop">&lt;code>bgv.extract&lt;/code> (heir::bgv::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract the i-th element of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.extract` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>While this operation is costly to compute in FHE, we represent it so we can
implement efficient lowerings and folders.&lt;/p>
&lt;p>This op can be implemented as a plaintext multiplication with a one-hot
vector and a rotate into the zero-th index.&lt;/p>
&lt;p>An extraction op&amp;rsquo;s input ciphertext type is asserted to have an &lt;code>underlying_type&lt;/code>
corresponding to a ranked tensor type, and this op&amp;rsquo;s return type is
inferred to have the &lt;code>underlying_type&lt;/code> corresponding to the element type of
that tensor type.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>offset&lt;/code>&lt;/td>
&lt;td>signless integer or index&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvlevel_reduce-heirbgvlevelreduceop">&lt;code>bgv.level_reduce&lt;/code> (heir::bgv::LevelReduceOp)&lt;/h3>
&lt;p>&lt;em>Lower the modulus level of the ciphertext via dropping RNS limbs.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.level_reduce` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>levelToDrop&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvmodulus_switch-heirbgvmodulusswitchop">&lt;code>bgv.modulus_switch&lt;/code> (heir::bgv::ModulusSwitchOp)&lt;/h3>
&lt;p>&lt;em>Lower the modulus level of the ciphertext via modulus switching.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.modulus_switch` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>to_ring&lt;/code>&lt;/td>&lt;td>::mlir::heir::polynomial::RingAttr&lt;/td>&lt;td>an attribute specifying a polynomial ring&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvmul-heirbgvmulop">&lt;code>bgv.mul&lt;/code> (heir::bgv::MulOp)&lt;/h3>
&lt;p>&lt;em>Multiplication operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvmul_plain-heirbgvmulplainop">&lt;code>bgv.mul_plain&lt;/code> (heir::bgv::MulPlainOp)&lt;/h3>
&lt;p>&lt;em>Multiplication operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.mul_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>IsCiphertextPlaintextOp&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvnegate-heirbgvnegateop">&lt;code>bgv.negate&lt;/code> (heir::bgv::NegateOp)&lt;/h3>
&lt;p>&lt;em>Negate the coefficients of the ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.negate` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Involution&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvrelinearize-heirbgvrelinearizeop">&lt;code>bgv.relinearize&lt;/code> (heir::bgv::RelinearizeOp)&lt;/h3>
&lt;p>&lt;em>Relinearize the ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.relinearize` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>This op takes integer array attributes &lt;code>from_basis&lt;/code> and &lt;code>to_basis&lt;/code> that are
used to indicate the key basis from which and to which the ciphertext is
encrypted against. A ciphertext is canonically encrypted against key basis
&lt;code>(1, s)&lt;/code>. After a multiplication, its size will increase and the basis will be
&lt;code>(1, s, s^2)&lt;/code>. The array that represents the key basis is constructed by
listing the powers of &lt;code>s&lt;/code> at each position of the array. For example, &lt;code>(1, s, s^2)&lt;/code> corresponds to &lt;code>[0, 1, 2]&lt;/code>, while &lt;code>(1, s^2)&lt;/code> corresponds to &lt;code>[0, 2]&lt;/code>.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>from_basis&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>to_basis&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvrotate_cols-heirbgvrotatecolumnsop">&lt;code>bgv.rotate_cols&lt;/code> (heir::bgv::RotateColumnsOp)&lt;/h3>
&lt;p>&lt;em>Rotate the columns of the coefficients of the ciphertext using a Galois automorphism.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.rotate_cols` operands attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>This operation rotates the columns of the coefficients of the ciphertext using a
Galois automorphism.&lt;/p>
&lt;p>Often BGV scheme is instantiated with a ring of the form &lt;code>Z_q[X]/(X^N + 1)&lt;/code> and
plaintext modulus &lt;code>t&lt;/code> where &lt;code>N&lt;/code> is a power of 2 and &lt;code>t&lt;/code> is a prime number. In
this case, the plaintext slots can be viewed as a &lt;code>2 x N/2&lt;/code> matrix where
&lt;code>N/2&lt;/code> is the number of columns and &lt;code>2&lt;/code> is the number of rows.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>offset&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvrotate_rows-heirbgvrotaterowsop">&lt;code>bgv.rotate_rows&lt;/code> (heir::bgv::RotateRowsOp)&lt;/h3>
&lt;p>&lt;em>Rotate the rows of the coefficients of the ciphertext using a Galois automorphism.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.rotate_rows` operands attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>This operation rotates the rows of the coefficients of the ciphertext using a
Galois automorphism.&lt;/p>
&lt;p>Often BGV scheme is instantiated with a ring of the form &lt;code>Z_q[X]/(X^N + 1)&lt;/code> and
plaintext modulus &lt;code>t&lt;/code> where &lt;code>N&lt;/code> is a power of 2 and &lt;code>t&lt;/code> is a prime number. In
this case, the plaintext slots can be viewed as a &lt;code>2 x N/2&lt;/code> matrix where
&lt;code>N/2&lt;/code> is the number of columns and &lt;code>2&lt;/code> is the number of rows.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-4">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>offset&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvsub-heirbgvsubop">&lt;code>bgv.sub&lt;/code> (heir::bgv::SubOp)&lt;/h3>
&lt;p>&lt;em>Subtraction operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.sub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvsub_plain-heirbgvsubplainop">&lt;code>bgv.sub_plain&lt;/code> (heir::bgv::SubPlainOp)&lt;/h3>
&lt;p>&lt;em>Subtraction operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `bgv.sub_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AllCiphertextTypesMatch&lt;/code>, &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>IsCiphertextPlaintextOp&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="bgv-additional-definitions">BGV additional definitions&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="bgvencryptiontechnique">BGVEncryptionTechnique&lt;/h3>
&lt;p>&lt;em>An enum attribute representing an encryption technique&lt;/em>&lt;/p>
&lt;h4 id="cases">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">standard&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>standard&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">extended&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>extended&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bgvencryptiontype">BGVEncryptionType&lt;/h3>
&lt;p>&lt;em>An enum attribute representing an encryption method&lt;/em>&lt;/p>
&lt;h4 id="cases-1">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">pk&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>pk&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sk&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>sk&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: CGGI</title><link>https://heir.dev/docs/dialects/cggi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/cggi/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="cggi-dialect">&amp;lsquo;cggi&amp;rsquo; Dialect&lt;/h1>
&lt;p>&lt;em>A dialect for types and operations in the CGGI cryptosystem&lt;/em>&lt;/p>
&lt;h2 id="cggi-attributes">CGGI attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="cggiboolgatesattr">CGGIBoolGatesAttr&lt;/h3>
&lt;p>&lt;em>An attribute containing an array of strings to store bool gates&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#cggi.cggi_bool_gates&amp;lt;
::llvm::ArrayRef&amp;lt;::mlir::heir::cggi::CGGIBoolGateEnumAttr&amp;gt; # gates
&amp;gt;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>This attributes stores a list of integer identifiers for Boolean gates.
&lt;/code>&lt;/pre>
&lt;p>Uses following mapping:
AND_GATE = 0;
NAND_GATE = 1;
OR_GATE = 2;
NOR_GATE = 3;
XOR_GATE = 4;
XNOR_GATE = 5;
NOT_GATE = 6;&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">gates&lt;/td>
&lt;td style="text-align:center">&lt;code>::llvm::ArrayRef&amp;lt;::mlir::heir::cggi::CGGIBoolGateEnumAttr&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggiparamsattr">CGGIParamsAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#cggi.cggi_params&amp;lt;
::mlir::heir::lwe::RLWEParamsAttr, # rlweParams
unsigned, # bsk_noise_variance
unsigned, # bsk_gadget_base_log
unsigned, # bsk_gadget_num_levels
unsigned, # ksk_noise_variance
unsigned, # ksk_gadget_base_log
unsigned # ksk_gadget_num_levels
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">rlweParams&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::lwe::RLWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">bsk_noise_variance&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">bsk_gadget_base_log&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">bsk_gadget_num_levels&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ksk_noise_variance&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ksk_gadget_base_log&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ksk_gadget_num_levels&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="cggi-ops">CGGI ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="cggiadd-heircggiaddop">&lt;code>cggi.add&lt;/code> (heir::cggi::AddOp)&lt;/h3>
&lt;p>&lt;em>Arithmetic addition of two ciphertexts. One of the two ciphertext is allowed to be a scalar, this will result in the scalar addition to a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggiand-heircggiandop">&lt;code>cggi.and&lt;/code> (heir::cggi::AndOp)&lt;/h3>
&lt;p>&lt;em>Logical AND of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.and` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggicast-heircggicastop">&lt;code>cggi.cast&lt;/code> (heir::cggi::CastOp)&lt;/h3>
&lt;p>&lt;em>Change the plaintext space of a CGGI ciphertext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.cast` $input attr-dict `:` type($input) `to` type($output)
&lt;/code>&lt;/pre>&lt;p>&amp;ldquo;cast&amp;rdquo; operation to change the plaintext size of a CGGI ciphertext.
Note this operations is not a standard CGGI operation, but an mirror of the cast op implemented in TFHE-rs.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>`cggi.cast %c0 : !lwe.lwe_ciphertext&amp;lt;encoding = #unspecified_bit_field_encoding&amp;gt; to !lwe.lwe_ciphertext&amp;lt;encoding = #unspecified_bit_field_encoding1&amp;gt;`
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultShape&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggicmp-heircggicmpop">&lt;code>cggi.cmp&lt;/code> (heir::cggi::CmpOp)&lt;/h3>
&lt;p>_High level operation to check the relation of two ciphertexts.&lt;/p>
&lt;ul>
&lt;li>equal (mnemonic: &amp;ldquo;eq&amp;rdquo;; integer value: 0)&lt;/li>
&lt;li>not equal (mnemonic: &amp;ldquo;ne&amp;rdquo;; integer value: 1)&lt;/li>
&lt;li>signed less than (mnemonic: &amp;ldquo;slt&amp;rdquo;; integer value: 2)&lt;/li>
&lt;li>signed less than or equal (mnemonic: &amp;ldquo;sle&amp;rdquo;; integer value: 3)&lt;/li>
&lt;li>signed greater than (mnemonic: &amp;ldquo;sgt&amp;rdquo;; integer value: 4)&lt;/li>
&lt;li>signed greater than or equal (mnemonic: &amp;ldquo;sge&amp;rdquo;; integer value: 5)&lt;/li>
&lt;li>unsigned less than (mnemonic: &amp;ldquo;ult&amp;rdquo;; integer value: 6)&lt;/li>
&lt;li>unsigned less than or equal (mnemonic: &amp;ldquo;ule&amp;rdquo;; integer value: 7)&lt;/li>
&lt;li>unsigned greater than (mnemonic: &amp;ldquo;ugt&amp;rdquo;; integer value: 8)&lt;/li>
&lt;li>unsigned greater than or equal (mnemonic: &amp;ldquo;uge&amp;rdquo;; integer value: 9)&lt;/li>
&lt;/ul>
&lt;p>Note: &lt;a href="https://mlir.llvm.org/docs/Dialects/ArithOps/#arithcmpi-arithcmpiop">https://mlir.llvm.org/docs/Dialects/ArithOps/#arithcmpi-arithcmpiop&lt;/a>
Note this operations to indirect mirror the TFHE-rs implmementation._&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.cmp` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>predicate&lt;/code>&lt;/td>&lt;td>::mlir::arith::CmpIPredicateAttr&lt;/td>&lt;td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggicreate_trivial-heircggicreatetrivialop">&lt;code>cggi.create_trivial&lt;/code> (heir::cggi::CreateTrivialOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.create_trivial` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>value&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggieq-heircggieqop">&lt;code>cggi.eq&lt;/code> (heir::cggi::EqOp)&lt;/h3>
&lt;p>&lt;em>High level operation to check equality of two ciphertexts. Note this operations to mirror the TFHE-rs implmementation.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.eq` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggilut2-heircggilut2op">&lt;code>cggi.lut2&lt;/code> (heir::cggi::Lut2Op)&lt;/h3>
&lt;p>&lt;em>A lookup table on two inputs.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.lut2` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>An op representing a lookup table applied to some number &lt;code>n&lt;/code> of ciphertexts
encrypting boolean input bits.&lt;/p>
&lt;p>Over cleartext bits &lt;code>a, b, c&lt;/code>, using &lt;code>n = 3&lt;/code> for example, the operation
computed by this function can be interpreted as&lt;/p>
&lt;pre tabindex="0">&lt;code> truth_table &amp;gt;&amp;gt; {c, b, a}
&lt;/code>&lt;/pre>&lt;p>where &lt;code>{c, b, a}&lt;/code> is the unsigned 3-bit integer with bits &lt;code>c, b, a&lt;/code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_table&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>b&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>a&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggilut3-heircggilut3op">&lt;code>cggi.lut3&lt;/code> (heir::cggi::Lut3Op)&lt;/h3>
&lt;p>&lt;em>A lookup table on three inputs.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.lut3` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>An op representing a lookup table applied to some number &lt;code>n&lt;/code> of ciphertexts
encrypting boolean input bits.&lt;/p>
&lt;p>Over cleartext bits &lt;code>a, b, c&lt;/code>, using &lt;code>n = 3&lt;/code> for example, the operation
computed by this function can be interpreted as&lt;/p>
&lt;pre tabindex="0">&lt;code> truth_table &amp;gt;&amp;gt; {c, b, a}
&lt;/code>&lt;/pre>&lt;p>where &lt;code>{c, b, a}&lt;/code> is the unsigned 3-bit integer with bits &lt;code>c, b, a&lt;/code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_table&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>c&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>b&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>a&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggilut_lincomb-heircggilutlincombop">&lt;code>cggi.lut_lincomb&lt;/code> (heir::cggi::LutLinCombOp)&lt;/h3>
&lt;p>&lt;em>A variadic-input lookup table with inputs prepared via linear combination.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.lut_lincomb` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>An op representing a lookup table applied to an arbitrary number of
input ciphertexts, which are combined according to a static linear
combination attached to the op.&lt;/p>
&lt;p>The user must ensure the chosen linear combination does not bleed error
bits into the message space according to the underlying ciphertext&amp;rsquo;s
encoding attributes. E.g., a bit_field_encoding with 3 cleartext bits
cannot be multiplied by 16.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#encoding&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#lwe.bit_field_encoding&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">cleartext_start=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">30&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">cleartext_bitwidth=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#params&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#lwe.lwe_params&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">cmod=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7917&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">dimension=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">ciphertext =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>lwe&lt;span style="color:#000;font-weight:bold">.&lt;/span>lwe_ciphertext&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">encoding =&lt;/span> &lt;span style="color:#000">#encoding&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">lwe_params =&lt;/span> &lt;span style="color:#000">#params&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%4&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> cggi&lt;span style="color:#000;font-weight:bold">.&lt;/span>lut_lincomb &lt;span style="color:#000">%c0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c3&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f57900">coefficients =&lt;/span> array&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span> &lt;span style="color:#f57900">lookup_table =&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">68&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">index&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Represents applying the lut&lt;/p>
&lt;pre tabindex="0">&lt;code> 68 &amp;gt;&amp;gt; (1 * c0 + 2 * c1 + 3 * c2 + 2 * c3)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-4">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>coefficients&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_table&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggimax-heircggimaxop">&lt;code>cggi.max&lt;/code> (heir::cggi::MaxOp)&lt;/h3>
&lt;p>&lt;em>High level operation to return maximum of two ciphertexts. Note this operations to mirror the TFHE-rs implmementation.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.max` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggimin-heircggiminop">&lt;code>cggi.min&lt;/code> (heir::cggi::MinOp)&lt;/h3>
&lt;p>&lt;em>High level operation to return minimum of two ciphertexts. Note this operations to mirror the TFHE-rs implmementation.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.min` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggimul-heircggimulop">&lt;code>cggi.mul&lt;/code> (heir::cggi::MulOp)&lt;/h3>
&lt;p>&lt;em>Arithmetic multiplication of two ciphertexts. One of the two ciphertext is allowed to be a scalar, this will result in the scalar multiplication to a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>While CGGI does not have a native multiplication operation,
some backend targets provide a multiplication
operation that is implemented via a sequence
of other atomic CGGI ops. When lowering to
backends that do not have this, one must lower
to this op the appropriate CGGI ops.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggimulti_lut_lincomb-heircggimultilutlincombop">&lt;code>cggi.multi_lut_lincomb&lt;/code> (heir::cggi::MultiLutLinCombOp)&lt;/h3>
&lt;p>&lt;em>A multi-output version of lut_lincomb with one LUT per output.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.multi_lut_lincomb` operands attr-dict `:` functional-type($inputs, $outputs)
&lt;/code>&lt;/pre>&lt;p>An op representing multiple lookup tables applied to a shared input, which
is prepared via a static linear combination. This is equivalent to
&lt;code>cggi.lut_lincomb&lt;/code>, but where the linear combination is given to multiple
lookup tables, each producing a separate output.&lt;/p>
&lt;p>This can be achieved by a special implementation of blind rotate in the CGGI
scheme. See &lt;a href="https://ieeexplore.ieee.org/document/10413195">AutoHoG&lt;/a>.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#encoding&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#lwe.bit_field_encoding&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">cleartext_start=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">30&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">cleartext_bitwidth=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#params&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#lwe.lwe_params&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">cmod=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7917&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">dimension=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">ciphertext =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>lwe&lt;span style="color:#000;font-weight:bold">.&lt;/span>lwe_ciphertext&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">encoding =&lt;/span> &lt;span style="color:#000">#encoding&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">lwe_params =&lt;/span> &lt;span style="color:#000">#params&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%4&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> cggi&lt;span style="color:#000;font-weight:bold">.&lt;/span>multi_lut_lincomb &lt;span style="color:#000">%c0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c3&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">coefficients =&lt;/span> array&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">lookup_tables =&lt;/span> array&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">index&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">68&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">70&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">8&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>ciphertext&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Represents applying the following LUTs. Performance-wise, this is
comparable to applying a single LUT to a linear combination.&lt;/p>
&lt;pre tabindex="0">&lt;code>x = (1 * c0 + 2 * c1 + 3 * c2 + 2 * c3)
return (
(68 &amp;gt;&amp;gt; x) &amp;amp; 1,
(70 &amp;gt;&amp;gt; x) &amp;amp; 1,
(4 &amp;gt;&amp;gt; x) &amp;amp; 1,
(8 &amp;gt;&amp;gt; x) &amp;amp; 1
)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-5">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>coefficients&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_tables&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>outputs&lt;/code>&lt;/td>
&lt;td>variadic of A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cgginand-heircgginandop">&lt;code>cggi.nand&lt;/code> (heir::cggi::NandOp)&lt;/h3>
&lt;p>&lt;em>Logical NAND of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.nand` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-13">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggineq-heircggineqop">&lt;code>cggi.neq&lt;/code> (heir::cggi::NeqOp)&lt;/h3>
&lt;p>&lt;em>High level operation to check inequality of two ciphertexts. Note this operations to mirror the TFHE-rs implmementation.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.neq` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-13">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-14">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cgginor-heircgginorop">&lt;code>cggi.nor&lt;/code> (heir::cggi::NorOp)&lt;/h3>
&lt;p>&lt;em>Logical NOR of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.nor` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-14">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-15">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cgginot-heircgginotop">&lt;code>cggi.not&lt;/code> (heir::cggi::NotOp)&lt;/h3>
&lt;p>&lt;em>Logical NOT of two ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.not` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Involution&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-15">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-16">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggior-heircggiorop">&lt;code>cggi.or&lt;/code> (heir::cggi::OrOp)&lt;/h3>
&lt;p>&lt;em>Logical OR of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.or` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-16">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-17">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggipacked_lut3-heircggipackedlut3op">&lt;code>cggi.packed_lut3&lt;/code> (heir::cggi::PackedLut3Op)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.packed_lut3` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-6">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_tables&lt;/code>&lt;/td>&lt;td>::mlir::ArrayAttr&lt;/td>&lt;td>Array of integers&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-17">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>a&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>b&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>c&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-18">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggipacked_gates-heircggipackedop">&lt;code>cggi.packed_gates&lt;/code> (heir::cggi::PackedOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.packed_gates` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Operation to where different Boolean gates are executed pairwise between elements of two ciphertext arrays.&lt;/p>
&lt;p>For example,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> cggi&lt;span style="color:#000;font-weight:bold">.&lt;/span>packed_gates &lt;span style="color:#000">%a&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%b&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f57900">gates =&lt;/span> &lt;span style="color:#000">#cggi.cggi_gate&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;and&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;xor&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;}&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2x&lt;/span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>lwe&lt;span style="color:#000;font-weight:bold">.&lt;/span>lwe_ciphertext&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>applies an &amp;ldquo;and&amp;rdquo; gate to the first elements of %a and %b and an xor gate to the
second elements.&lt;/p>
&lt;p>Mapping is defined in the BooleanGates.td file.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-7">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>gates&lt;/code>&lt;/td>&lt;td>::mlir::heir::cggi::CGGIBoolGatesAttr&lt;/td>&lt;td>An attribute containing an array of strings to store bool gates&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-18">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-19">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggiprogrammable_bootstrap-heircggiprogrammablebootstrapop">&lt;code>cggi.programmable_bootstrap&lt;/code> (heir::cggi::ProgrammableBootstrapOp)&lt;/h3>
&lt;p>&lt;em>Programmable Bootstrap with a given lookup table.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.programmable_bootstrap` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>An op representing a programmable bootstrap applied to an LWE ciphertext.&lt;/p>
&lt;p>This operation evaluates a univariate function homomorphically on the
ciphertext by selecting the correct value from a lookup table. The bit size
of the lookup table integer attribute should be equal to the plaintext space
size. For example, if there ciphertext can hold 3 plaintext message bits,
then the lookup table must be represented at most by an integer with 8 bits.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-8">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookup_table&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-19">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-20">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggisshl-heircggiscalarshiftleftop">&lt;code>cggi.sshl&lt;/code> (heir::cggi::ScalarShiftLeftOp)&lt;/h3>
&lt;p>&lt;em>Arithmetic shift to left of a ciphertext by an integer. Note this operations to mirror the TFHE-rs implmementation.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.sshl` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-9">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>shiftAmount&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>index attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-20">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-21">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggisshr-heircggiscalarshiftrightop">&lt;code>cggi.sshr&lt;/code> (heir::cggi::ScalarShiftRightOp)&lt;/h3>
&lt;p>&lt;em>Arithmetic shift to the right of a ciphertext by an integer. Note this operations to mirror the TFHE-rs implmementation.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.sshr` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-10">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>shiftAmount&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>index attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-21">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-22">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggicmux-heircggiselectop">&lt;code>cggi.cmux&lt;/code> (heir::cggi::SelectOp)&lt;/h3>
&lt;p>&lt;em>Multiplexer operations, the &lt;code>select&lt;/code> ciphertext will return the &lt;code>trueCtxt&lt;/code>
if in contains a 1. In the other case, it will will return the &lt;code>falseCtxt&lt;/code>.
Note this operations to mirror the TFHE-rs implmementation.&amp;quot;&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.cmux` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-22">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>select&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>trueCtxt&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>falseCtxt&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-23">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggisub-heircggisubop">&lt;code>cggi.sub&lt;/code> (heir::cggi::SubOp)&lt;/h3>
&lt;p>&lt;em>Subtraction of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.sub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-23">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-24">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggixnor-heircggixnorop">&lt;code>cggi.xnor&lt;/code> (heir::cggi::XNorOp)&lt;/h3>
&lt;p>&lt;em>Logical XNOR of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.xnor` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-24">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-25">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cggixor-heircggixorop">&lt;code>cggi.xor&lt;/code> (heir::cggi::XorOp)&lt;/h3>
&lt;p>&lt;em>Logical XOR of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `cggi.xor` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-25">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-26">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="cggi-additional-definitions">CGGI additional definitions&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="cggiboolgateenum">CGGIBoolGateEnum&lt;/h3>
&lt;p>&lt;em>An enum attribute representing a CGGI boolean gate using u8 int&lt;/em>&lt;/p>
&lt;h4 id="cases">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">AND&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>AND&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">NAND&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>NAND&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">OR&lt;/td>
&lt;td style="text-align:center">&lt;code>2&lt;/code>&lt;/td>
&lt;td>OR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">NOR&lt;/td>
&lt;td style="text-align:center">&lt;code>3&lt;/code>&lt;/td>
&lt;td>NOR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">XOR&lt;/td>
&lt;td style="text-align:center">&lt;code>4&lt;/code>&lt;/td>
&lt;td>XOR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">XNOR&lt;/td>
&lt;td style="text-align:center">&lt;code>5&lt;/code>&lt;/td>
&lt;td>XNOR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">NOT&lt;/td>
&lt;td style="text-align:center">&lt;code>6&lt;/code>&lt;/td>
&lt;td>NOT&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: CKKS</title><link>https://heir.dev/docs/dialects/ckks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/ckks/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="ckks-dialect">&amp;lsquo;ckks&amp;rsquo; Dialect&lt;/h1>
&lt;p>The CKKS dialect defines the types and operations of the CKKS cryptosystem.&lt;/p>
&lt;h2 id="ckks-attributes">CKKS attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="schemeparamattr">SchemeParamAttr&lt;/h3>
&lt;p>&lt;em>CKKS Scheme Parameters&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#ckks.scheme_param&amp;lt;
int, # logN
DenseI64ArrayAttr, # Q
DenseI64ArrayAttr, # P
int, # logDefaultScale
CKKSEncryptionType # encryptionType
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute is used for recording the scheme parameters for CKKS.&lt;/p>
&lt;p>The attribute is a struct with the following fields:&lt;/p>
&lt;ul>
&lt;li>&lt;code>int&lt;/code> logN: The log of the degree of the polynomial modulus.&lt;/li>
&lt;li>&lt;code>DenseI64ArrayAttr&lt;/code> Q: The array of primes in the ciphertext modulus.&lt;/li>
&lt;li>&lt;code>DenseI64ArrayAttr&lt;/code> P: The array of primes in the special modulus, used for key switching.&lt;/li>
&lt;li>&lt;code>int&lt;/code> logDefaultScale: The log of the default scale.&lt;/li>
&lt;/ul>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">logN&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Q&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">P&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">logDefaultScale&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">encryptionType&lt;/td>
&lt;td style="text-align:center">&lt;code>CKKSEncryptionType&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="ckks-ops">CKKS ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="ckksadd-heirckksaddop">&lt;code>ckks.add&lt;/code> (heir::ckks::AddOp)&lt;/h3>
&lt;p>&lt;em>Addition operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksadd_plain-heirckksaddplainop">&lt;code>ckks.add_plain&lt;/code> (heir::ckks::AddPlainOp)&lt;/h3>
&lt;p>&lt;em>Addition operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.add_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AllCiphertextTypesMatch&lt;/code>, &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>IsCiphertextPlaintextOp&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksbootstrap-heirckksbootstrapop">&lt;code>ckks.bootstrap&lt;/code> (heir::ckks::BootstrapOp)&lt;/h3>
&lt;p>&lt;em>Bootstrap the ciphertext to reduce noise and refresh its parameters.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.bootstrap` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Bootstrapping is a technique used in FHE to reduce the noise in a ciphertext
and refresh its parameters, allowing for further computations on the ciphertext.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksextract-heirckksextractop">&lt;code>ckks.extract&lt;/code> (heir::ckks::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract the i-th element of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.extract` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>While this operation is costly to compute in FHE, we represent it so we can
implement efficient lowerings and folders.&lt;/p>
&lt;p>This op can be implemented as a plaintext multiplication with a one-hot
vector and a rotate into the zero-th index.&lt;/p>
&lt;p>An extraction op&amp;rsquo;s input ciphertext type is asserted to have an &lt;code>underlying_type&lt;/code>
corresponding to a ranked tensor type, and this op&amp;rsquo;s return type is
inferred to have the &lt;code>underlying_type&lt;/code> corresponding to the element type of
that tensor type.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>offset&lt;/code>&lt;/td>
&lt;td>signless integer or index&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckkslevel_reduce-heirckkslevelreduceop">&lt;code>ckks.level_reduce&lt;/code> (heir::ckks::LevelReduceOp)&lt;/h3>
&lt;p>&lt;em>Lower the modulus level of the ciphertext via dropping RNS limbs.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.level_reduce` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>levelToDrop&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksmul-heirckksmulop">&lt;code>ckks.mul&lt;/code> (heir::ckks::MulOp)&lt;/h3>
&lt;p>&lt;em>Multiplication operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksmul_plain-heirckksmulplainop">&lt;code>ckks.mul_plain&lt;/code> (heir::ckks::MulPlainOp)&lt;/h3>
&lt;p>&lt;em>Multiplication operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.mul_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>IsCiphertextPlaintextOp&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksnegate-heirckksnegateop">&lt;code>ckks.negate&lt;/code> (heir::ckks::NegateOp)&lt;/h3>
&lt;p>&lt;em>Negate the coefficients of the ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.negate` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Involution&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksrelinearize-heirckksrelinearizeop">&lt;code>ckks.relinearize&lt;/code> (heir::ckks::RelinearizeOp)&lt;/h3>
&lt;p>&lt;em>Relinearize the ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.relinearize` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>This op takes integer array attributes &lt;code>from_basis&lt;/code> and &lt;code>to_basis&lt;/code> that are
used to indicate the key basis from which and to which the ciphertext is
encrypted against. A ciphertext is canonically encrypted against key basis
&lt;code>(1, s)&lt;/code>. After a multiplication, its size will increase and the basis will be
&lt;code>(1, s, s^2)&lt;/code>. The array that represents the key basis is constructed by
listing the powers of &lt;code>s&lt;/code> at each position of the array. For example, &lt;code>(1, s, s^2)&lt;/code> corresponds to &lt;code>[0, 1, 2]&lt;/code>, while &lt;code>(1, s^2)&lt;/code> corresponds to &lt;code>[0, 2]&lt;/code>.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>from_basis&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>to_basis&lt;/code>&lt;/td>&lt;td>::mlir::DenseI32ArrayAttr&lt;/td>&lt;td>i32 dense array attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksrescale-heirckksrescaleop">&lt;code>ckks.rescale&lt;/code> (heir::ckks::RescaleOp)&lt;/h3>
&lt;p>&lt;em>Rescales the ciphertext, which is the CKKS version of modulus switching in BGV/BFV.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.rescale` operands attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>to_ring&lt;/code>&lt;/td>&lt;td>::mlir::heir::polynomial::RingAttr&lt;/td>&lt;td>an attribute specifying a polynomial ring&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksrotate-heirckksrotateop">&lt;code>ckks.rotate&lt;/code> (heir::ckks::RotateOp)&lt;/h3>
&lt;p>&lt;em>Rotate the coefficients of the ciphertext using a Galois automorphism.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.rotate` operands attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>offset&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckkssub-heirckkssubop">&lt;code>ckks.sub&lt;/code> (heir::ckks::SubOp)&lt;/h3>
&lt;p>&lt;em>Subtraction operation between ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.sub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckkssub_plain-heirckkssubplainop">&lt;code>ckks.sub_plain&lt;/code> (heir::ckks::SubPlainOp)&lt;/h3>
&lt;p>&lt;em>Subtraction operation between ciphertext-plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `ckks.sub_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AllCiphertextTypesMatch&lt;/code>, &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>IsCiphertextPlaintextOp&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="ckks-additional-definitions">CKKS additional definitions&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="ckksencryptiontype">CKKSEncryptionType&lt;/h3>
&lt;p>&lt;em>An enum attribute representing an encryption method&lt;/em>&lt;/p>
&lt;h4 id="cases">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">pk&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>pk&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sk&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>sk&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Comb</title><link>https://heir.dev/docs/dialects/comb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/comb/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="comb-dialect">&amp;lsquo;comb&amp;rsquo; Dialect&lt;/h1>
&lt;p>&lt;em>Types and operations for comb dialect&lt;/em>&lt;/p>
&lt;p>This dialect defines the &lt;code>comb&lt;/code> dialect, which is intended to be a generic
representation of combinational logic outside of a particular use-case.&lt;/p>
&lt;h2 id="operations">Operations&lt;/h2>
&lt;h3 id="combadd-heircombaddop">&lt;code>comb.add&lt;/code> (heir::comb::AddOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="comband-heircombandop">&lt;code>comb.and&lt;/code> (heir::comb::AndOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combconcat-heircombconcatop">&lt;code>comb.concat&lt;/code> (heir::comb::ConcatOp)&lt;/h3>
&lt;p>&lt;em>Concatenate a variadic list of operands together.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
&lt;/code>&lt;/pre>&lt;p>See the comb rationale document for details on operand ordering.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combextract-heircombextractop">&lt;code>comb.extract&lt;/code> (heir::comb::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lowBit&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>32-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combicmp-heircombicmpop">&lt;code>comb.icmp&lt;/code> (heir::comb::ICmpOp)&lt;/h3>
&lt;p>&lt;em>Compare two integer values&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
&lt;/code>&lt;/pre>&lt;p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.&lt;/p>
&lt;pre tabindex="0">&lt;code> %r = comb.icmp eq %a, %b : i4
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>predicate&lt;/code>&lt;/td>&lt;td>::mlir::heir::comb::ICmpPredicateAttr&lt;/td>&lt;td>hw.icmp comparison predicate&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combinv-heircombinvop">&lt;code>comb.inv&lt;/code> (heir::comb::InvOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-4">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmul-heircombmulop">&lt;code>comb.mul&lt;/code> (heir::comb::MulOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-5">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmux-heircombmuxop">&lt;code>comb.mux&lt;/code> (heir::comb::MuxOp)&lt;/h3>
&lt;p>&lt;em>Return one or the other operand depending on a selector bit&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %0 = mux %pred, %tvalue, %fvalue : i4
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-6">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cond&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>trueValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>falseValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combnand-heircombnandop">&lt;code>comb.nand&lt;/code> (heir::comb::NandOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-7">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combnor-heircombnorop">&lt;code>comb.nor&lt;/code> (heir::comb::NorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-8">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combor-heircomborop">&lt;code>comb.or&lt;/code> (heir::comb::OrOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-9">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combparity-heircombparityop">&lt;code>comb.parity&lt;/code> (heir::comb::ParityOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-10">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combreplicate-heircombreplicateop">&lt;code>comb.replicate&lt;/code> (heir::comb::ReplicateOp)&lt;/h3>
&lt;p>&lt;em>Concatenate the operand a constant number of times&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combtruth_table-heircombtruthtableop">&lt;code>comb.truth_table&lt;/code> (heir::comb::TruthTableOp)&lt;/h3>
&lt;p>&lt;em>Return a true/false based on a lookup table&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.truth_table` $inputs `-&amp;gt;` $lookupTable attr-dict
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %a = ... : i1
%b = ... : i1
%0 = comb.truth_table %a, %b -&amp;gt; 6 : ui4
&lt;/code>&lt;/pre>&lt;p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -&amp;gt; LSB from left
to right and the offset into &lt;code>lookupTable&lt;/code> is computed from them. The
integer containing the truth table value&amp;rsquo;s LSB is the output for the input
&amp;ldquo;all false&amp;rdquo;, and the MSB is the output for the input &amp;ldquo;all true&amp;rdquo;.&lt;/p>
&lt;p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&amp;rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &amp;lsquo;x&amp;rsquo; &amp;ndash; it should be the well-known result.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-11">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookupTable&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-13">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of 1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-13">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combxnor-heircombxnorop">&lt;code>comb.xnor&lt;/code> (heir::comb::XNorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-12">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-14">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-14">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combxor-heircombxorop">&lt;code>comb.xor&lt;/code> (heir::comb::XorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-13">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-15">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-15">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="enums">Enums&lt;/h2>
&lt;h3 id="icmppredicate">ICmpPredicate&lt;/h3>
&lt;p>&lt;em>Hw.icmp comparison predicate&lt;/em>&lt;/p>
&lt;h4 id="cases">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">eq&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>eq&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ne&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>ne&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">slt&lt;/td>
&lt;td style="text-align:center">&lt;code>2&lt;/code>&lt;/td>
&lt;td>slt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sle&lt;/td>
&lt;td style="text-align:center">&lt;code>3&lt;/code>&lt;/td>
&lt;td>sle&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sgt&lt;/td>
&lt;td style="text-align:center">&lt;code>4&lt;/code>&lt;/td>
&lt;td>sgt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sge&lt;/td>
&lt;td style="text-align:center">&lt;code>5&lt;/code>&lt;/td>
&lt;td>sge&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ult&lt;/td>
&lt;td style="text-align:center">&lt;code>6&lt;/code>&lt;/td>
&lt;td>ult&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ule&lt;/td>
&lt;td style="text-align:center">&lt;code>7&lt;/code>&lt;/td>
&lt;td>ule&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ugt&lt;/td>
&lt;td style="text-align:center">&lt;code>8&lt;/code>&lt;/td>
&lt;td>ugt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">uge&lt;/td>
&lt;td style="text-align:center">&lt;code>9&lt;/code>&lt;/td>
&lt;td>uge&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ceq&lt;/td>
&lt;td style="text-align:center">&lt;code>10&lt;/code>&lt;/td>
&lt;td>ceq&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cne&lt;/td>
&lt;td style="text-align:center">&lt;code>11&lt;/code>&lt;/td>
&lt;td>cne&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">weq&lt;/td>
&lt;td style="text-align:center">&lt;code>12&lt;/code>&lt;/td>
&lt;td>weq&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">wne&lt;/td>
&lt;td style="text-align:center">&lt;code>13&lt;/code>&lt;/td>
&lt;td>wne&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="comb-types">Comb types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h2 id="comb-ops">Comb ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="combadd-heircombaddop-1">&lt;code>comb.add&lt;/code> (heir::comb::AddOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-14">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-16">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-16">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="comband-heircombandop-1">&lt;code>comb.and&lt;/code> (heir::comb::AndOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-15">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-17">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-17">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combconcat-heircombconcatop-1">&lt;code>comb.concat&lt;/code> (heir::comb::ConcatOp)&lt;/h3>
&lt;p>&lt;em>Concatenate a variadic list of operands together.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
&lt;/code>&lt;/pre>&lt;p>See the comb rationale document for details on operand ordering.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-18">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-18">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combextract-heircombextractop-1">&lt;code>comb.extract&lt;/code> (heir::comb::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-16">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lowBit&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>32-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-19">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-19">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combicmp-heircombicmpop-1">&lt;code>comb.icmp&lt;/code> (heir::comb::ICmpOp)&lt;/h3>
&lt;p>&lt;em>Compare two integer values&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
&lt;/code>&lt;/pre>&lt;p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.&lt;/p>
&lt;pre tabindex="0">&lt;code> %r = comb.icmp eq %a, %b : i4
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-17">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>predicate&lt;/code>&lt;/td>&lt;td>::mlir::heir::comb::ICmpPredicateAttr&lt;/td>&lt;td>hw.icmp comparison predicate&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-20">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-20">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combinv-heircombinvop-1">&lt;code>comb.inv&lt;/code> (heir::comb::InvOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-18">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-21">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-21">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmul-heircombmulop-1">&lt;code>comb.mul&lt;/code> (heir::comb::MulOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-19">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-22">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-22">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmux-heircombmuxop-1">&lt;code>comb.mux&lt;/code> (heir::comb::MuxOp)&lt;/h3>
&lt;p>&lt;em>Return one or the other operand depending on a selector bit&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %0 = mux %pred, %tvalue, %fvalue : i4
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-20">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-23">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cond&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>trueValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>falseValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-23">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combnand-heircombnandop-1">&lt;code>comb.nand&lt;/code> (heir::comb::NandOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-21">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-24">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-24">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combnor-heircombnorop-1">&lt;code>comb.nor&lt;/code> (heir::comb::NorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-22">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-25">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-25">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combor-heircomborop-1">&lt;code>comb.or&lt;/code> (heir::comb::OrOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-23">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-26">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-26">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combparity-heircombparityop-1">&lt;code>comb.parity&lt;/code> (heir::comb::ParityOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-24">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-27">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-27">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combreplicate-heircombreplicateop-1">&lt;code>comb.replicate&lt;/code> (heir::comb::ReplicateOp)&lt;/h3>
&lt;p>&lt;em>Concatenate the operand a constant number of times&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-28">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-28">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combtruth_table-heircombtruthtableop-1">&lt;code>comb.truth_table&lt;/code> (heir::comb::TruthTableOp)&lt;/h3>
&lt;p>&lt;em>Return a true/false based on a lookup table&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.truth_table` $inputs `-&amp;gt;` $lookupTable attr-dict
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %a = ... : i1
%b = ... : i1
%0 = comb.truth_table %a, %b -&amp;gt; 6 : ui4
&lt;/code>&lt;/pre>&lt;p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -&amp;gt; LSB from left
to right and the offset into &lt;code>lookupTable&lt;/code> is computed from them. The
integer containing the truth table value&amp;rsquo;s LSB is the output for the input
&amp;ldquo;all false&amp;rdquo;, and the MSB is the output for the input &amp;ldquo;all true&amp;rdquo;.&lt;/p>
&lt;p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&amp;rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &amp;lsquo;x&amp;rsquo; &amp;ndash; it should be the well-known result.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>LUTOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-25">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>lookupTable&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-29">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of 1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-29">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combxnor-heircombxnorop-1">&lt;code>comb.xnor&lt;/code> (heir::comb::XNorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-26">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-30">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-30">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combxor-heircombxorop-1">&lt;code>comb.xor&lt;/code> (heir::comb::XorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>SameTypeOperands&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-27">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>twoState&lt;/code>&lt;/td>&lt;td>::mlir::UnitAttr&lt;/td>&lt;td>unit attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-31">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-31">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="comb-additional-definitions">Comb additional definitions&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="icmppredicate-1">ICmpPredicate&lt;/h3>
&lt;p>&lt;em>Hw.icmp comparison predicate&lt;/em>&lt;/p>
&lt;h4 id="cases-1">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">eq&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>eq&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ne&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>ne&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">slt&lt;/td>
&lt;td style="text-align:center">&lt;code>2&lt;/code>&lt;/td>
&lt;td>slt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sle&lt;/td>
&lt;td style="text-align:center">&lt;code>3&lt;/code>&lt;/td>
&lt;td>sle&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sgt&lt;/td>
&lt;td style="text-align:center">&lt;code>4&lt;/code>&lt;/td>
&lt;td>sgt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sge&lt;/td>
&lt;td style="text-align:center">&lt;code>5&lt;/code>&lt;/td>
&lt;td>sge&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ult&lt;/td>
&lt;td style="text-align:center">&lt;code>6&lt;/code>&lt;/td>
&lt;td>ult&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ule&lt;/td>
&lt;td style="text-align:center">&lt;code>7&lt;/code>&lt;/td>
&lt;td>ule&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ugt&lt;/td>
&lt;td style="text-align:center">&lt;code>8&lt;/code>&lt;/td>
&lt;td>ugt&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">uge&lt;/td>
&lt;td style="text-align:center">&lt;code>9&lt;/code>&lt;/td>
&lt;td>uge&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ceq&lt;/td>
&lt;td style="text-align:center">&lt;code>10&lt;/code>&lt;/td>
&lt;td>ceq&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cne&lt;/td>
&lt;td style="text-align:center">&lt;code>11&lt;/code>&lt;/td>
&lt;td>cne&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">weq&lt;/td>
&lt;td style="text-align:center">&lt;code>12&lt;/code>&lt;/td>
&lt;td>weq&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">wne&lt;/td>
&lt;td style="text-align:center">&lt;code>13&lt;/code>&lt;/td>
&lt;td>wne&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Jaxite</title><link>https://heir.dev/docs/dialects/jaxite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/jaxite/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="jaxite-dialect">&amp;lsquo;jaxite&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>jaxite&lt;/code> dialect is an exit dialect for generating py code against the jaxite library API,
using the jaxite parameters and encoding scheme.&lt;/p>
&lt;p>See &lt;a href="https://github.com/google/jaxite">https://github.com/google/jaxite&lt;/a>&lt;/p>
&lt;h2 id="jaxite-types">Jaxite types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="paramstype">ParamsType&lt;/h3>
&lt;p>&lt;em>The jaxite security params required to perform homomorphic operations.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!jaxite.params&lt;/code>&lt;/p>
&lt;h3 id="pmaplut3tupletype">PmapLut3TupleType&lt;/h3>
&lt;p>&lt;em>A tuple of pmap_lut3 args.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!jaxite.pmap_lut3_tuple&lt;/code>&lt;/p>
&lt;h3 id="serverkeysettype">ServerKeySetType&lt;/h3>
&lt;p>&lt;em>The jaxite server key set required to perform homomorphic operations.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!jaxite.server_key_set&lt;/code>&lt;/p>
&lt;h2 id="jaxite-ops">Jaxite ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="jaxiteconstant-heirjaxiteconstantop">&lt;code>jaxite.constant&lt;/code> (heir::jaxite::ConstantOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `jaxite.constant` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>The jaxite security params required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="jaxitelut3_args-heirjaxitelut3argsop">&lt;code>jaxite.lut3_args&lt;/code> (heir::jaxite::Lut3ArgsOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `jaxite.lut3_args` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>The operation computed by this function is generating tuples for pmap_lut3.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>a&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>b&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>c&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>truth_table&lt;/code>&lt;/td>
&lt;td>8-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A tuple of pmap_lut3 args.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="jaxitelut3-heirjaxitelut3op">&lt;code>jaxite.lut3&lt;/code> (heir::jaxite::Lut3Op)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `jaxite.lut3` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>The operation computed by this function can be
interpreted as&lt;/p>
&lt;p>truth_table &amp;raquo; {c, b, a}&lt;/p>
&lt;p>where {c, b, a} is the unsigned 3-bit integer with bits c, b, a from most
significant bit to least-significant bit.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>a&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>b&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>c&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>truth_table&lt;/code>&lt;/td>
&lt;td>8-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKeySet&lt;/code>&lt;/td>
&lt;td>The jaxite server key set required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>The jaxite security params required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="jaxitepmap_lut3-heirjaxitepmaplut3op">&lt;code>jaxite.pmap_lut3&lt;/code> (heir::jaxite::PmapLut3Op)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `jaxite.pmap_lut3` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>The operation computed by this function is a bacthed Lut3Op.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lut3_args&lt;/code>&lt;/td>
&lt;td>pmap_lut3_tuples&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKeySet&lt;/code>&lt;/td>
&lt;td>The jaxite server key set required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>The jaxite security params required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: JaxiteWord</title><link>https://heir.dev/docs/dialects/jaxiteword/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/jaxiteword/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="jaxiteword-dialect">&amp;lsquo;jaxiteword&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>jaxiteword&lt;/code> dialect is an exit dialect for generating py code against the jaxiteword library API,
using the jaxiteword parameters and encoding scheme.&lt;/p>
&lt;p>See &lt;a href="https://github.com/google/jaxite/jaxite_word">https://github.com/google/jaxite/jaxite_word&lt;/a>&lt;/p>
&lt;h2 id="jaxiteword-types">JaxiteWord types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="ccparamstype">CCParamsType&lt;/h3>
&lt;p>&lt;em>The CCParams required to create CryptoContext.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!jaxiteword.cc_params&lt;/code>&lt;/p>
&lt;h3 id="ciphertexttype">CiphertextType&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!jaxiteword.ciphertext&amp;lt;
int, # polys
int, # towers
int # degrees
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A ciphertext - a three dimensional array.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">polys&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">towers&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">degrees&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cryptocontexttype">CryptoContextType&lt;/h3>
&lt;p>&lt;em>The CryptoContext required to perform homomorphic operations in JaxiteWord.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!jaxiteword.crypto_context&lt;/code>&lt;/p>
&lt;h3 id="evalkeytype">EvalKeyType&lt;/h3>
&lt;p>&lt;em>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in JaxiteWord.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!jaxiteword.eval_key&lt;/code>&lt;/p>
&lt;h3 id="moduluslisttype">ModulusListType&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!jaxiteword.modulus_list&amp;lt;
::llvm::ArrayRef&amp;lt;::mlir::IntegerAttr&amp;gt; # modulus_list
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A list of modulus values.&lt;/p>
&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">modulus_list&lt;/td>
&lt;td style="text-align:center">&lt;code>::llvm::ArrayRef&amp;lt;::mlir::IntegerAttr&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="privatekeytype">PrivateKeyType&lt;/h3>
&lt;p>&lt;em>The private key required to decrypt a ciphertext in JaxiteWord.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!jaxiteword.private_key&lt;/code>&lt;/p>
&lt;h3 id="publickeytype">PublicKeyType&lt;/h3>
&lt;p>&lt;em>The public key required to encrypt plaintext in JaxiteWord.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!jaxiteword.public_key&lt;/code>&lt;/p>
&lt;h2 id="jaxiteword-ops">JaxiteWord ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="jaxitewordadd-heirjaxitewordaddop">&lt;code>jaxiteword.add&lt;/code> (heir::jaxiteword::AddOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `jaxiteword.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>The operation computed by this function is homomorphic addition.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value_a&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value_b&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>modulus_list&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="jaxitewordmake_ciphertext-heirjaxitewordmakeciphertextop">&lt;code>jaxiteword.make_ciphertext&lt;/code> (heir::jaxiteword::MakeCiphertextOp)&lt;/h3>
&lt;p>&lt;em>Create a JaxiteWord ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `jaxiteword.make_ciphertext` $polys `,` $towers `,` $degrees attr-dict `:` type($ciphertext)
&lt;/code>&lt;/pre>&lt;p>Creates a JaxiteWord ciphertext with the given dimensions.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>polys&lt;/code>&lt;/td>
&lt;td>32-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>towers&lt;/code>&lt;/td>
&lt;td>32-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>degrees&lt;/code>&lt;/td>
&lt;td>32-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Lattigo</title><link>https://heir.dev/docs/dialects/lattigo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/lattigo/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="lattigo-dialect">&amp;rsquo;lattigo&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>lattigo&lt;/code> dialect is an exit dialect for generating GO code against the Lattigo library API.&lt;/p>
&lt;p>See &lt;a href="https://github.com/tuneinsight/lattigo">https://github.com/tuneinsight/lattigo&lt;/a>&lt;/p>
&lt;h2 id="lattigo-attributes">Lattigo attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="bgvparametersliteralattr">BGVParametersLiteralAttr&lt;/h3>
&lt;p>&lt;em>Literal parameters for Lattigo BGV&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lattigo.bgv.parameters_literal&amp;lt;
int, # logN
DenseI64ArrayAttr, # Q
DenseI64ArrayAttr, # P
DenseI32ArrayAttr, # logQ
DenseI32ArrayAttr, # logP
int64_t # plaintextModulus
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute represents the literal parameters for Lattigo BGV.&lt;/p>
&lt;p>This is in accordance with &lt;a href="https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/bgv#ParametersLiteral">https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/bgv#ParametersLiteral&lt;/a>
where some field are not present in the current implementation.&lt;/p>
&lt;p>Users must set the polynomial degree (LogN) and the coefficient modulus,
by either setting the Q and P fields to the desired moduli chain,
or by setting the LogQ and LogP fields to the desired moduli sizes.&lt;/p>
&lt;p>Note that for Lattigo, Q/P requires []uint64, where this attribute
only provides int64. We assume user should not select moduli so large
to consider the signedness issue.&lt;/p>
&lt;p>Users must also specify the coefficient modulus in plaintext-space (T).
This modulus must be an NTT-friendly prime in the plaintext space:
it must be equal to 1 modulo 2n where n is the plaintext ring degree
(i.e., the plaintext space has n slots).&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">logN&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Q&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">P&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">logQ&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI32ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">logP&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI32ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">plaintextModulus&lt;/td>
&lt;td style="text-align:center">&lt;code>int64_t&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ckksparametersliteralattr">CKKSParametersLiteralAttr&lt;/h3>
&lt;p>&lt;em>Literal parameters for Lattigo CKKS&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lattigo.ckks.parameters_literal&amp;lt;
int, # logN
DenseI64ArrayAttr, # Q
DenseI64ArrayAttr, # P
DenseI32ArrayAttr, # logQ
DenseI32ArrayAttr, # logP
int # logDefaultScale
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute represents the literal parameters for Lattigo CKKS.&lt;/p>
&lt;p>This is in accordance with &lt;a href="https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/ckks#ParametersLiteral">https://pkg.go.dev/github.com/tuneinsight/lattigo/v6@v6.1.0/schemes/ckks#ParametersLiteral&lt;/a>
where some field are not present in the current implementation.&lt;/p>
&lt;p>Users must set the polynomial degree (LogN) and the coefficient modulus,
by either setting the Q and P fields to the desired moduli chain,
or by setting the LogQ and LogP fields to the desired moduli sizes.&lt;/p>
&lt;p>Note that for Lattigo, Q/P requires []uint64, where this attribute
only provides int64. We assume user should not select moduli so large
to consider the signedness issue.&lt;/p>
&lt;p>Users must also specify a default initial scale for the plaintexts1.&lt;/p>
&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">logN&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Q&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">P&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">logQ&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI32ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">logP&lt;/td>
&lt;td style="text-align:center">&lt;code>DenseI32ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">logDefaultScale&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="lattigo-types">Lattigo types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="bgvencodertype">BGVEncoderType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.bgv.encoder&lt;/code>&lt;/p>
&lt;p>This type represents the encoder for the BGV encryption scheme.&lt;/p>
&lt;h3 id="bgvevaluatortype">BGVEvaluatorType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.bgv.evaluator&lt;/code>&lt;/p>
&lt;p>This type represents the evaluator for the BGV encryption scheme.&lt;/p>
&lt;h3 id="bgvparametertype">BGVParameterType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.bgv.parameter&lt;/code>&lt;/p>
&lt;p>This type represents the parameters for the BGV encryption scheme.&lt;/p>
&lt;h3 id="ckksencodertype">CKKSEncoderType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.ckks.encoder&lt;/code>&lt;/p>
&lt;p>This type represents the encoder for the CKKS encryption scheme.&lt;/p>
&lt;h3 id="ckksevaluatortype">CKKSEvaluatorType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.ckks.evaluator&lt;/code>&lt;/p>
&lt;p>This type represents the evaluator for the CKKS encryption scheme.&lt;/p>
&lt;h3 id="ckksparametertype">CKKSParameterType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.ckks.parameter&lt;/code>&lt;/p>
&lt;p>This type represents the parameters for the CKKS encryption scheme.&lt;/p>
&lt;h3 id="rlweciphertexttype">RLWECiphertextType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.rlwe.ciphertext&lt;/code>&lt;/p>
&lt;p>This type represents the ciphertext for the RLWE encryption scheme.&lt;/p>
&lt;h3 id="rlwedecryptortype">RLWEDecryptorType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.rlwe.decryptor&lt;/code>&lt;/p>
&lt;p>This type represents the decryptor for the RLWE encryption scheme.&lt;/p>
&lt;h3 id="rlweencryptortype">RLWEEncryptorType&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lattigo.rlwe.encryptor&amp;lt;
bool # publicKey
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This type represents the encryptor for the RLWE encryption scheme.&lt;/p>
&lt;h4 id="parameters-2">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">publicKey&lt;/td>
&lt;td style="text-align:center">&lt;code>bool&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlweevaluationkeysettype">RLWEEvaluationKeySetType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.rlwe.evaluation_key_set&lt;/code>&lt;/p>
&lt;p>This type represents the evaluation key set for the RLWE encryption scheme.&lt;/p>
&lt;h3 id="rlwegaloiskeytype">RLWEGaloisKeyType&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lattigo.rlwe.galois_key&amp;lt;
::mlir::IntegerAttr # galoisElement
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This type represents the Galois key for the RLWE encryption scheme.&lt;/p>
&lt;p>galoisElement: Enabling the automorphism X -&amp;gt; X^{galoisElement}.&lt;/p>
&lt;h4 id="parameters-3">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">galoisElement&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::IntegerAttr&lt;/code>&lt;/td>
&lt;td>An Attribute containing a integer value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlwekeygeneratortype">RLWEKeyGeneratorType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.rlwe.key_generator&lt;/code>&lt;/p>
&lt;p>This type represents the key generator for the RLWE encryption scheme.&lt;/p>
&lt;h3 id="rlweplaintexttype">RLWEPlaintextType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.rlwe.plaintext&lt;/code>&lt;/p>
&lt;p>This type represents the plaintext for the RLWE encryption scheme.&lt;/p>
&lt;h3 id="rlwepublickeytype">RLWEPublicKeyType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.rlwe.public_key&lt;/code>&lt;/p>
&lt;p>This type represents the public key for the RLWE encryption scheme.&lt;/p>
&lt;h3 id="rlwerelinearizationkeytype">RLWERelinearizationKeyType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.rlwe.relinearization_key&lt;/code>&lt;/p>
&lt;p>This type represents the relinearization key for the RLWE encryption scheme.&lt;/p>
&lt;h3 id="rlwesecretkeytype">RLWESecretKeyType&lt;/h3>
&lt;p>Syntax: &lt;code>!lattigo.rlwe.secret_key&lt;/code>&lt;/p>
&lt;p>This type represents the secret key for the RLWE encryption scheme.&lt;/p>
&lt;h2 id="lattigo-ops">Lattigo ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="lattigobgvadd_new-heirlattigobgvaddnewop">&lt;code>lattigo.bgv.add_new&lt;/code> (heir::lattigo::BGVAddNewOp)&lt;/h3>
&lt;p>&lt;em>Add two ciphertexts in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.add_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation adds two ciphertext values in the Lattigo BGV dialect.&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvadd-heirlattigobgvaddop">&lt;code>lattigo.bgv.add&lt;/code> (heir::lattigo::BGVAddOp)&lt;/h3>
&lt;p>&lt;em>Add two ciphertexts in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation adds two ciphertext values in the Lattigo BGV dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvdecode-heirlattigobgvdecodeop">&lt;code>lattigo.bgv.decode&lt;/code> (heir::lattigo::BGVDecodeOp)&lt;/h3>
&lt;p>&lt;em>Decode a plaintext value in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.decode` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation decodes a plaintext value using the specified encoder in the Lattigo BGV dialect.&lt;/p>
&lt;p>The input value tensor should have elements of integer type.&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encoder&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>ranked tensor of integer values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>decoded&lt;/code>&lt;/td>
&lt;td>ranked tensor of integer values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvencode-heirlattigobgvencodeop">&lt;code>lattigo.bgv.encode&lt;/code> (heir::lattigo::BGVEncodeOp)&lt;/h3>
&lt;p>&lt;em>Encode a plaintext value in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.encode` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation encodes a plaintext value using the specified encoder in the Lattigo BGV dialect.&lt;/p>
&lt;p>The input value tensor should have elements of integer type.&lt;/p>
&lt;p>The &lt;code>scale&lt;/code> attribute indicates the scaling factor for encoding.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>scale&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encoder&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>ranked tensor of integer values&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encoded&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvmul_new-heirlattigobgvmulnewop">&lt;code>lattigo.bgv.mul_new&lt;/code> (heir::lattigo::BGVMulNewOp)&lt;/h3>
&lt;p>&lt;em>Multiply two ciphertexts in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.mul_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation multiplies two ciphertext values in the Lattigo BGV dialect.&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvmul-heirlattigobgvmulop">&lt;code>lattigo.bgv.mul&lt;/code> (heir::lattigo::BGVMulOp)&lt;/h3>
&lt;p>&lt;em>Multiply two ciphertexts in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation multiplies two ciphertext values in the Lattigo BGV dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvnew_encoder-heirlattigobgvnewencoderop">&lt;code>lattigo.bgv.new_encoder&lt;/code> (heir::lattigo::BGVNewEncoderOp)&lt;/h3>
&lt;p>&lt;em>Create a new encoder in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.new_encoder` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates a new encoder for encoding plaintext values in the Lattigo BGV dialect.&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encoder&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvnew_evaluator-heirlattigobgvnewevaluatorop">&lt;code>lattigo.bgv.new_evaluator&lt;/code> (heir::lattigo::BGVNewEvaluatorOp)&lt;/h3>
&lt;p>&lt;em>Create a new evaluator in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.new_evaluator` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates a new evaluator for performing operations on ciphertexts in the Lattigo BGV dialect.&lt;/p>
&lt;p>By default, the evaluator is created with the provided parameters and could execute
operations which does not relying on evaluation keys.&lt;/p>
&lt;p>To support operations that require evaluation keys,
the optional evaluation key set should be provided.&lt;/p>
&lt;p>The scaleInvariant flag is used to indicate whether the evaluator is for B/FV or BGV.
If it is set to true, the evaluator will evaluate operations in B/FV style.&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>scaleInvariant&lt;/code>&lt;/td>&lt;td>::mlir::BoolAttr&lt;/td>&lt;td>bool attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluationKeySet&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvnew_parameters_from_literal-heirlattigobgvnewparametersfromliteralop">&lt;code>lattigo.bgv.new_parameters_from_literal&lt;/code> (heir::lattigo::BGVNewParametersFromLiteralOp)&lt;/h3>
&lt;p>&lt;em>Create new BGV parameters from a literal in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.new_parameters_from_literal` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates new BGV parameters from a given literal value in the Lattigo BGV dialect.&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>paramsLiteral&lt;/code>&lt;/td>&lt;td>::mlir::heir::lattigo::BGVParametersLiteralAttr&lt;/td>&lt;td>Literal parameters for Lattigo BGV&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvnew_plaintext-heirlattigobgvnewplaintextop">&lt;code>lattigo.bgv.new_plaintext&lt;/code> (heir::lattigo::BGVNewPlaintextOp)&lt;/h3>
&lt;p>&lt;em>Create a new plaintext in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.new_plaintext` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates a new plaintext value in the Lattigo BGV dialect.&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvrelinearize_new-heirlattigobgvrelinearizenewop">&lt;code>lattigo.bgv.relinearize_new&lt;/code> (heir::lattigo::BGVRelinearizeNewOp)&lt;/h3>
&lt;p>&lt;em>Relinearize a ciphertext in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.relinearize_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation relinearizes a ciphertext value in the Lattigo BGV dialect.&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvrelinearize-heirlattigobgvrelinearizeop">&lt;code>lattigo.bgv.relinearize&lt;/code> (heir::lattigo::BGVRelinearizeOp)&lt;/h3>
&lt;p>&lt;em>Relinearize a ciphertext in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.relinearize` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation relinearizes a ciphertext value in the Lattigo BGV dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvrescale_new-heirlattigobgvrescalenewop">&lt;code>lattigo.bgv.rescale_new&lt;/code> (heir::lattigo::BGVRescaleNewOp)&lt;/h3>
&lt;p>&lt;em>Rescale a ciphertext in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.rescale_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation rescales a ciphertext value in the Lattigo BGV dialect.&lt;/p>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvrescale-heirlattigobgvrescaleop">&lt;code>lattigo.bgv.rescale&lt;/code> (heir::lattigo::BGVRescaleOp)&lt;/h3>
&lt;p>&lt;em>Rescale a ciphertext in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.rescale` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation rescales a ciphertext value in the Lattigo BGV dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-13">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvrotate_columns_new-heirlattigobgvrotatecolumnsnewop">&lt;code>lattigo.bgv.rotate_columns_new&lt;/code> (heir::lattigo::BGVRotateColumnsNewOp)&lt;/h3>
&lt;p>&lt;em>Rotate columns of a ciphertext in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.rotate_columns_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation rotates the columns of a ciphertext value in the Lattigo BGV dialect.&lt;/p>
&lt;p>Lattigo exposes the SIMD slot of BGV as a N/2 x 2 matrix, where N/2 is the column.&lt;/p>
&lt;p>Offset is valid for both positive and negative number.&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>offset&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-13">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-14">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvrotate_columns-heirlattigobgvrotatecolumnsop">&lt;code>lattigo.bgv.rotate_columns&lt;/code> (heir::lattigo::BGVRotateColumnsOp)&lt;/h3>
&lt;p>&lt;em>Rotate columns of a ciphertext in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.rotate_columns` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation rotates the columns of a ciphertext value in the Lattigo BGV dialect.&lt;/p>
&lt;p>Lattigo exposes the SIMD slot of BGV as a N/2 x 2 matrix, where N/2 is the column.&lt;/p>
&lt;p>Offset is valid for both positive and negative number.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes-4">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>offset&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-14">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-15">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvrotate_rows_new-heirlattigobgvrotaterowsnewop">&lt;code>lattigo.bgv.rotate_rows_new&lt;/code> (heir::lattigo::BGVRotateRowsNewOp)&lt;/h3>
&lt;p>&lt;em>Rotate rows of a ciphertext in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.rotate_rows_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation swap the rows of a ciphertext value in the Lattigo BGV dialect.&lt;/p>
&lt;p>Lattigo exposes the SIMD slot of BGV as a N/2 x 2 matrix, where 2 is the row.&lt;/p>
&lt;h4 id="operands-15">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-16">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvrotate_rows-heirlattigobgvrotaterowsop">&lt;code>lattigo.bgv.rotate_rows&lt;/code> (heir::lattigo::BGVRotateRowsOp)&lt;/h3>
&lt;p>&lt;em>Rotate rows of a ciphertext in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.rotate_rows` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation swap the rows of a ciphertext value in the Lattigo BGV dialect.&lt;/p>
&lt;p>Lattigo exposes the SIMD slot of BGV as a N/2 x 2 matrix, where 2 is the row.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-16">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-17">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvsub_new-heirlattigobgvsubnewop">&lt;code>lattigo.bgv.sub_new&lt;/code> (heir::lattigo::BGVSubNewOp)&lt;/h3>
&lt;p>&lt;em>Subtract two ciphertexts in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.sub_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation subtracts one ciphertext value from another in the Lattigo BGV dialect.&lt;/p>
&lt;h4 id="operands-17">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-18">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigobgvsub-heirlattigobgvsubop">&lt;code>lattigo.bgv.sub&lt;/code> (heir::lattigo::BGVSubOp)&lt;/h3>
&lt;p>&lt;em>Subtract two ciphertexts in the Lattigo BGV dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.bgv.sub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation subtracts one ciphertext value from another in the Lattigo BGV dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-18">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-19">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksadd_new-heirlattigockksaddnewop">&lt;code>lattigo.ckks.add_new&lt;/code> (heir::lattigo::CKKSAddNewOp)&lt;/h3>
&lt;p>&lt;em>Add two ciphertexts in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.add_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation adds two ciphertext values in the Lattigo CKKS dialect.&lt;/p>
&lt;h4 id="operands-19">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-20">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksadd-heirlattigockksaddop">&lt;code>lattigo.ckks.add&lt;/code> (heir::lattigo::CKKSAddOp)&lt;/h3>
&lt;p>&lt;em>Add two ciphertexts in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation adds two ciphertext values in the Lattigo CKKS dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-20">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-21">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksdecode-heirlattigockksdecodeop">&lt;code>lattigo.ckks.decode&lt;/code> (heir::lattigo::CKKSDecodeOp)&lt;/h3>
&lt;p>&lt;em>Decode a plaintext value in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.decode` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation decodes a plaintext value using the specified encoder in the Lattigo CKKS dialect.&lt;/p>
&lt;p>The input value tensor should have elements of float type or complex type.&lt;/p>
&lt;h4 id="operands-21">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encoder&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>ranked tensor of floating-point or complex-type values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-22">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>decoded&lt;/code>&lt;/td>
&lt;td>ranked tensor of floating-point or complex-type values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksencode-heirlattigockksencodeop">&lt;code>lattigo.ckks.encode&lt;/code> (heir::lattigo::CKKSEncodeOp)&lt;/h3>
&lt;p>&lt;em>Encode a plaintext value in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.encode` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation encodes a plaintext value using the specified encoder in the Lattigo CKKS dialect.&lt;/p>
&lt;p>The input value tensor should have elements of float type or complex type.&lt;/p>
&lt;p>The &lt;code>scale&lt;/code> attribute indicates the scaling factor for encoding.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes-5">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>scale&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-22">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encoder&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>ranked tensor of floating-point or complex-type values&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-23">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encoded&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksmul_new-heirlattigockksmulnewop">&lt;code>lattigo.ckks.mul_new&lt;/code> (heir::lattigo::CKKSMulNewOp)&lt;/h3>
&lt;p>&lt;em>Multiply two ciphertexts in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.mul_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation multiplies two ciphertext values in the Lattigo CKKS dialect.&lt;/p>
&lt;h4 id="operands-23">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-24">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksmul-heirlattigockksmulop">&lt;code>lattigo.ckks.mul&lt;/code> (heir::lattigo::CKKSMulOp)&lt;/h3>
&lt;p>&lt;em>Multiply two ciphertexts in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation multiplies two ciphertext values in the Lattigo CKKS dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-24">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-25">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksnew_encoder-heirlattigockksnewencoderop">&lt;code>lattigo.ckks.new_encoder&lt;/code> (heir::lattigo::CKKSNewEncoderOp)&lt;/h3>
&lt;p>&lt;em>Create a new encoder in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.new_encoder` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates a new encoder for encoding plaintext values in the Lattigo CKKS dialect.&lt;/p>
&lt;h4 id="operands-25">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-26">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encoder&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksnew_evaluator-heirlattigockksnewevaluatorop">&lt;code>lattigo.ckks.new_evaluator&lt;/code> (heir::lattigo::CKKSNewEvaluatorOp)&lt;/h3>
&lt;p>&lt;em>Create a new evaluator in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.new_evaluator` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates a new evaluator for performing operations on ciphertexts in the Lattigo CKKS dialect.&lt;/p>
&lt;p>By default, the evaluator is created with the provided parameters and could execute
operations which does not relying on evaluation keys.&lt;/p>
&lt;p>To support operations that require evaluation keys,
the optional evaluation key set should be provided.&lt;/p>
&lt;h4 id="operands-26">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluationKeySet&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-27">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksnew_parameters_from_literal-heirlattigockksnewparametersfromliteralop">&lt;code>lattigo.ckks.new_parameters_from_literal&lt;/code> (heir::lattigo::CKKSNewParametersFromLiteralOp)&lt;/h3>
&lt;p>&lt;em>Create new CKKS parameters from a literal in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.new_parameters_from_literal` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates new CKKS parameters from a given literal value in the Lattigo CKKS dialect.&lt;/p>
&lt;h4 id="attributes-6">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>paramsLiteral&lt;/code>&lt;/td>&lt;td>::mlir::heir::lattigo::CKKSParametersLiteralAttr&lt;/td>&lt;td>Literal parameters for Lattigo CKKS&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="results-28">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksnew_plaintext-heirlattigockksnewplaintextop">&lt;code>lattigo.ckks.new_plaintext&lt;/code> (heir::lattigo::CKKSNewPlaintextOp)&lt;/h3>
&lt;p>&lt;em>Create a new plaintext in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.new_plaintext` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates a new plaintext value in the Lattigo CKKS dialect.&lt;/p>
&lt;h4 id="operands-27">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-29">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksrelinearize_new-heirlattigockksrelinearizenewop">&lt;code>lattigo.ckks.relinearize_new&lt;/code> (heir::lattigo::CKKSRelinearizeNewOp)&lt;/h3>
&lt;p>&lt;em>Relinearize a ciphertext in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.relinearize_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation relinearizes a ciphertext value in the Lattigo CKKS dialect.&lt;/p>
&lt;h4 id="operands-28">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-30">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksrelinearize-heirlattigockksrelinearizeop">&lt;code>lattigo.ckks.relinearize&lt;/code> (heir::lattigo::CKKSRelinearizeOp)&lt;/h3>
&lt;p>&lt;em>Relinearize a ciphertext in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.relinearize` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation relinearizes a ciphertext value in the Lattigo CKKS dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-29">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-31">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksrescale_new-heirlattigockksrescalenewop">&lt;code>lattigo.ckks.rescale_new&lt;/code> (heir::lattigo::CKKSRescaleNewOp)&lt;/h3>
&lt;p>&lt;em>Rescale a ciphertext in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.rescale_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation rescales a ciphertext value in the Lattigo CKKS dialect.&lt;/p>
&lt;h4 id="operands-30">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-32">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksrescale-heirlattigockksrescaleop">&lt;code>lattigo.ckks.rescale&lt;/code> (heir::lattigo::CKKSRescaleOp)&lt;/h3>
&lt;p>&lt;em>Rescale a ciphertext in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.rescale` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation rescales a ciphertext value in the Lattigo CKKS dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-31">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-33">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksrotate_new-heirlattigockksrotatenewop">&lt;code>lattigo.ckks.rotate_new&lt;/code> (heir::lattigo::CKKSRotateNewOp)&lt;/h3>
&lt;p>&lt;em>Rotate slots of a ciphertext in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.rotate_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation rotates slots of a ciphertext value in the Lattigo CKKS dialect.&lt;/p>
&lt;p>For vanilla CKKS, the maximum number of slots is N/2 with each slot being complex number.
Lattigo also support a conjugate-invariant version of CKKS, i.e. the ring is
Z[X + X^{-1} ]/(X^N+1), which allows for a maximum of N slots with each slot being real number.&lt;/p>
&lt;p>Offset is valid for both positive and negative number.&lt;/p>
&lt;h4 id="attributes-7">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>offset&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-32">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-34">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockksrotate-heirlattigockksrotateop">&lt;code>lattigo.ckks.rotate&lt;/code> (heir::lattigo::CKKSRotateOp)&lt;/h3>
&lt;p>&lt;em>Rotate slots of a ciphertext in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.rotate` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation rotates slots of a ciphertext value in the Lattigo CKKS dialect.&lt;/p>
&lt;p>For vanilla CKKS, the maximum number of slots is N/2 with each slot being complex number.
Lattigo also support a conjugate-invariant version of CKKS, i.e. the ring is
Z[X + X^{-1} ]/(X^N+1), which allows for a maximum of N slots with each slot being real number.&lt;/p>
&lt;p>Offset is valid for both positive and negative number.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes-8">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>offset&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-33">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-35">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockkssub_new-heirlattigockkssubnewop">&lt;code>lattigo.ckks.sub_new&lt;/code> (heir::lattigo::CKKSSubNewOp)&lt;/h3>
&lt;p>&lt;em>Subtract two ciphertexts in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.sub_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation subtracts one ciphertext value from another in the Lattigo CKKS dialect.&lt;/p>
&lt;h4 id="operands-34">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-36">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigockkssub-heirlattigockkssubop">&lt;code>lattigo.ckks.sub&lt;/code> (heir::lattigo::CKKSSubOp)&lt;/h3>
&lt;p>&lt;em>Subtract two ciphertexts in the Lattigo CKKS dialect&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.ckks.sub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation subtracts one ciphertext value from another in the Lattigo CKKS dialect.&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-35">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-37">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwedecrypt-heirlattigorlwedecryptop">&lt;code>lattigo.rlwe.decrypt&lt;/code> (heir::lattigo::RLWEDecryptOp)&lt;/h3>
&lt;p>&lt;em>Decrypts a ciphertext using RLWE&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.decrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation decrypts a ciphertext using RLWE&lt;/p>
&lt;h4 id="operands-36">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>decryptor&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-38">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwedrop_level_new-heirlattigorlwedroplevelnewop">&lt;code>lattigo.rlwe.drop_level_new&lt;/code> (heir::lattigo::RLWEDropLevelNewOp)&lt;/h3>
&lt;p>&lt;em>Drop level of a ciphertext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.drop_level_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="attributes-9">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>levelToDrop&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-37">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-39">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwedrop_level-heirlattigorlwedroplevelop">&lt;code>lattigo.rlwe.drop_level&lt;/code> (heir::lattigo::RLWEDropLevelOp)&lt;/h3>
&lt;p>&lt;em>Drop level of a ciphertext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.drop_level` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation drops the level of a ciphertext&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code>result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes-10">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>levelToDrop&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-38">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-40">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlweencrypt-heirlattigorlweencryptop">&lt;code>lattigo.rlwe.encrypt&lt;/code> (heir::lattigo::RLWEEncryptOp)&lt;/h3>
&lt;p>&lt;em>Encrypts a plaintext using RLWE&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.encrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation encrypts a plaintext using RLWE&lt;/p>
&lt;h4 id="operands-39">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encryptor&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-41">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwegen_galois_key-heirlattigorlwegengaloiskeyop">&lt;code>lattigo.rlwe.gen_galois_key&lt;/code> (heir::lattigo::RLWEGenGaloisKeyOp)&lt;/h3>
&lt;p>&lt;em>Generates a new RLWE Galois key&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.gen_galois_key` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation generates a new RLWE Galois key&lt;/p>
&lt;p>galoisElement: Enabling the automorphism X -&amp;gt; X^{galoisElement}.&lt;/p>
&lt;h4 id="attributes-11">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>galoisElement&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-40">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>keyGenerator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>secretKey&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-42">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>galoisKey&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwegen_key_pair-heirlattigorlwegenkeypairop">&lt;code>lattigo.rlwe.gen_key_pair&lt;/code> (heir::lattigo::RLWEGenKeyPairOp)&lt;/h3>
&lt;p>&lt;em>Generates a new RLWE key pair&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.gen_key_pair` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation generates a new RLWE key pair&lt;/p>
&lt;h4 id="operands-41">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>keyGenerator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-43">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>secretKey&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>publicKey&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwegen_relinearization_key-heirlattigorlwegenrelinearizationkeyop">&lt;code>lattigo.rlwe.gen_relinearization_key&lt;/code> (heir::lattigo::RLWEGenRelinearizationKeyOp)&lt;/h3>
&lt;p>&lt;em>Generates a new RLWE relinearization key&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.gen_relinearization_key` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation generates a new RLWE relinearization key&lt;/p>
&lt;h4 id="operands-42">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>keyGenerator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>secretKey&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-44">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>relinearizationKey&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwenegate_new-heirlattigorlwenegatenewop">&lt;code>lattigo.rlwe.negate_new&lt;/code> (heir::lattigo::RLWENegateNewOp)&lt;/h3>
&lt;p>&lt;em>Negate a ciphertext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.negate_new` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="operands-43">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-45">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwenegate-heirlattigorlwenegateop">&lt;code>lattigo.rlwe.negate&lt;/code> (heir::lattigo::RLWENegateOp)&lt;/h3>
&lt;p>&lt;em>Negate of a ciphertext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.negate` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation negates a ciphertext&lt;/p>
&lt;p>The result will be written to the &lt;code>inplace&lt;/code> operand. The &lt;code>output&lt;/code> result is
a transitive reference to the &lt;code>inplace&lt;/code> operand for sake of the MLIR SSA form.&lt;/p>
&lt;p>Interfaces: &lt;code>InplaceOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-44">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluator&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inplace&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-46">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwenew_decryptor-heirlattigorlwenewdecryptorop">&lt;code>lattigo.rlwe.new_decryptor&lt;/code> (heir::lattigo::RLWENewDecryptorOp)&lt;/h3>
&lt;p>&lt;em>Creates a new RLWE decryptor&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.new_decryptor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates a new RLWE decryptor&lt;/p>
&lt;h4 id="operands-45">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>secretKey&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-47">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>decryptor&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwenew_encryptor-heirlattigorlwenewencryptorop">&lt;code>lattigo.rlwe.new_encryptor&lt;/code> (heir::lattigo::RLWENewEncryptorOp)&lt;/h3>
&lt;p>&lt;em>Creates a new RLWE encryptor&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.new_encryptor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation creates a new RLWE encryptor&lt;/p>
&lt;h4 id="operands-46">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encryptionKey&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-48">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encryptor&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwenew_evaluation_key_set-heirlattigorlwenewevaluationkeysetop">&lt;code>lattigo.rlwe.new_evaluation_key_set&lt;/code> (heir::lattigo::RLWENewEvaluationKeySetOp)&lt;/h3>
&lt;p>&lt;em>Generates a new RLWE evaluation key set&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.new_evaluation_key_set` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation generates a new RLWE evaluation key set&lt;/p>
&lt;h4 id="operands-47">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>keys&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-49">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evaluationKeySet&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lattigorlwenew_key_generator-heirlattigorlwenewkeygeneratorop">&lt;code>lattigo.rlwe.new_key_generator&lt;/code> (heir::lattigo::RLWENewKeyGeneratorOp)&lt;/h3>
&lt;p>&lt;em>Generates a new RLWE key generator&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lattigo.rlwe.new_key_generator` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This operation generates a new RLWE key generator&lt;/p>
&lt;h4 id="operands-48">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-50">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>keyGenerator&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: LWE</title><link>https://heir.dev/docs/dialects/lwe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/lwe/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="lwe-dialect">&amp;rsquo;lwe&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>lwe&lt;/code> dialect is a dialect for concepts related to cryptosystems
in the Learning With Errors (LWE) family.&lt;/p>
&lt;p>See &lt;a href="https://en.wikipedia.org/wiki/Learning_with_errors">Wikipedia&lt;/a>
for an overview of LWE and the related
&lt;a href="https://en.wikipedia.org/wiki/Ring_learning_with_errors">RLWE&lt;/a>
problem.&lt;/p>
&lt;p>While one might expect this dialect to contain types along the lines
of LWE and RLWE ciphertexts, and operations like encryption, decryption,
adding and multiplying ciphertexts, these concepts are not centralized
here because they are too scheme-specific.&lt;/p>
&lt;p>Instead, this dialect provides attributes that can be attached to tensors
of integer or &lt;code>poly.poly&lt;/code> types, which indicate that they are semantically
LWE and RLWE ciphertexts, respectively.&lt;/p>
&lt;h2 id="lwe-attributes">LWE attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="applicationdataattr">ApplicationDataAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.application_data&amp;lt;
mlir::Type, # message_type
Attribute # overflow
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An attribute describing the semantics of the underlying application data.&lt;/p>
&lt;p>The &lt;code>messageType&lt;/code> parameter is used to describe the type and bits of the
original application data, e.g. i1, i32, f32. This type is later mapped
into the plaintext space of an FHE scheme by embedding, scaling, or other
techniques.&lt;/p>
&lt;p>This attribute also contains information about the overflow semantics of the
data in the application. By default, we assume that the application program
was written so that the overflow is not expected and the overflow attribute
can can be &lt;code>no_overflow&lt;/code>. For LWE-based CGGI ciphertexts, the overflow
attribute will usually be &lt;code>preserve_overflow&lt;/code>, since messages will overflow
into padding bits.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">message_type&lt;/td>
&lt;td style="text-align:center">&lt;code>mlir::Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">overflow&lt;/td>
&lt;td style="text-align:center">&lt;code>Attribute&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bitfieldencodingattr">BitFieldEncodingAttr&lt;/h3>
&lt;p>&lt;em>An attribute describing encoded LWE plaintexts using bit fields.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.bit_field_encoding&amp;lt;
unsigned, # cleartext_start
unsigned # cleartext_bitwidth
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A bit field encoding of an integer describes which contiguous region
of bits a small integer occupies within a larger integer.&lt;/p>
&lt;p>The data describing the encoding consists of the starting bit positions of
the cleartext bit field and its width, where the LSB is bit 0 and the MSB
is bit &lt;code>bit_width-1&lt;/code>. So the above example would have starting bit &lt;code>30&lt;/code> and
width &lt;code>3&lt;/code>. The bits not specified for the message have semantics defined
by the scheme or lowering.&lt;/p>
&lt;p>Note that this encoding does not specify the underlying bit width of the
plaintext space. This is left for lowerings to decide.&lt;/p>
&lt;p>The presence of this attribute as the &lt;code>encoding&lt;/code> attribute of a tensor
indicates that the tensor is an LWE ciphertext.&lt;/p>
&lt;p>&lt;strong>Example (CGGI):&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>#encoding = #lwe.bit_field_encoding&amp;lt;cleartext_start=30, cleartext_bitwidth=3&amp;gt;
!plaintext = !lwe.lwe_plaintext&amp;lt;encoding = #encoding&amp;gt;
%0 = arith.constant 4 : i3
%1 = lwe.encode %0 { encoding = #encoding }: i3 to !plaintext
&lt;/code>&lt;/pre>&lt;p>The above represents an LWE plaintext encoding the 3-bit cleartext 4 as an
LWE ciphertext in a 32-bit integer, with a single bit of padding at the MSB.
This corresponds to the following, where 0 denotes a 0 bit, &lt;code>b&lt;/code> denotes a
bit of the cleartext, &lt;code>n&lt;/code> denotes a bit reserved for noise, and &lt;code>|&lt;/code> is a
visual aid to show where the bit fields begin and end.&lt;/p>
&lt;pre tabindex="0">&lt;code> 0|bbb|nn...n
MSB^ ^LSB
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example (BGV):&lt;/strong>&lt;/p>
&lt;p>Note: BGV uses the RLWE encodings, but they have the same bit-field encoding
attributes as here. So this example serves mainly to show how this attribute
can be used to specify storing bits in the LSB of a plaintext.&lt;/p>
&lt;pre tabindex="0">&lt;code>#encoding = #lwe.bit_field_encoding&amp;lt;cleartext_start=4, cleartext_bitwidth=4&amp;gt;
!plaintext = !lwe.lwe_plaintext&amp;lt;encoding = #encoding&amp;gt;
%0 = arith.constant 9 : i4
%1 = lwe.encode %0 { encoding = #encoding }: i4 to !plaintext
&lt;/code>&lt;/pre>&lt;p>The above represents an LWE plaintext encoding a 4-bit cleartext as an
LWE ciphertext in the least-significant bits of a larger integer.
This corresponds to the following.&lt;/p>
&lt;pre tabindex="0">&lt;code> nn...n|bbbb
MSB^ ^LSB
&lt;/code>&lt;/pre>&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cleartext_start&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cleartext_bitwidth&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ciphertextspaceattr">CiphertextSpaceAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.ciphertext_space&amp;lt;
::mlir::heir::polynomial::RingAttr, # ring
::mlir::heir::lwe::LweEncryptionType, # encryption_type
unsigned # size
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An attribute describing the ciphertext space and the transformation from
plaintext space to ciphertext space of an FHE scheme.&lt;/p>
&lt;p>The ciphertext space information includes the ring attribute, describing the
space that the ciphertext elements belong to. The ring attribute contains a
coefficient type attribute that describes the semantics of the coefficient.
For example, a ring modulo $1 + x^1024$ with coefficients modulo $q =
298374$ will be described as&lt;/p>
&lt;pre tabindex="0">&lt;code>!cmod = !mod_arith.mod_arith&amp;lt;modulus=298374 : i64&amp;gt;
#ring = #polynomial.ring&amp;lt;coefficientType = !cmod, polynomialModulus = &amp;lt;1 + x**1024&amp;gt;&amp;gt;
#ciphertext_space = #lwe.ciphertext_space&amp;lt;ring = #ring, encryption_type = lsb&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Ciphertexts using an RNS representation for $q$ will use an RNS type in
their ring&amp;rsquo;s coefficient type attribute.&lt;/p>
&lt;pre tabindex="0">&lt;code>!limb1 = !mod_arith.mod_arith&amp;lt;modulus=2251799814045697 : i64&amp;gt;
!limb2 = !mod_arith.mod_arith&amp;lt;modulus=65537 : i64&amp;gt;
#rns_mod = !rns.rns&amp;lt;!limb1, !limb2&amp;gt;
#ring = #polynomial.ring&amp;lt;coefficientType = #rns_mod, polynomialModulus = &amp;lt;1 + x**1024&amp;gt;&amp;gt;
#ciphertext_space = #lwe.ciphertext_space&amp;lt;ring = #ring, encryption_type = lsb&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Scalar LWE ciphertexts (like those used in CGGI) use an ideal polynomial of
degree 1, $x$. CGGI ciphertexts will typically use a power of two modulus
and may use a native integer type for its coefficient modulus.&lt;/p>
&lt;pre tabindex="0">&lt;code>#ring = #polynomial.ring&amp;lt;coefficientType = i32, polynomialModulus = &amp;lt;1 + x**1024&amp;gt;&amp;gt;
#ciphertext_space = #lwe.ciphertext_space&amp;lt;ring = #ring, encryption_type = lsb&amp;gt;
&lt;/code>&lt;/pre>&lt;p>The ciphertext encoding info is used to describe the way the plaintext data
is encoded into the ciphertext (in the MSB, LSB, or mixed).&lt;/p>
&lt;p>The &lt;code>size&lt;/code> parameter is used to describe the number of polynomials
comprising the ciphertext. This is typically 2 for RLWE ciphertexts that
are made up of an $(a, b)$ pair and greater than 2 for LWE instances. For
example, after an RLWE multiplication of two size 2 ciphertexts,
the ciphertext&amp;rsquo;s size will be 3.&lt;/p>
&lt;h4 id="parameters-2">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::RingAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">encryption_type&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::lwe::LweEncryptionType&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">size&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="coefficientencodingattr">CoefficientEncodingAttr&lt;/h3>
&lt;p>&lt;em>An encoding of cleartexts directly as coefficients.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.coefficient_encoding&amp;lt;
int64_t # scaling_factor
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A coefficient encoding of a list of integers asserts that the coefficients
of the polynomials contain the integers, with the same semantics as
&lt;code>constant_coefficient_encoding&lt;/code> for per-coefficient encodings.&lt;/p>
&lt;p>A &lt;code>scaling_factor&lt;/code> is optionally applied on the scalar when converting from
a rounded floating point to an integer.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#coeff_encoding = #lwe.coefficient_encoding&amp;lt;scaling_factor=10000&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-3">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">scaling_factor&lt;/td>
&lt;td style="text-align:center">&lt;code>int64_t&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="constantcoefficientencodingattr">ConstantCoefficientEncodingAttr&lt;/h3>
&lt;p>&lt;em>An encoding of a scalar in the constant coefficient&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.constant_coefficient_encoding&amp;lt;
int64_t # scaling_factor
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An encoding of a single scalar into the constant coefficient of the plaintext.&lt;/p>
&lt;p>All other coefficients of the plaintext are set to be zero. This encoding is
used to encode scalar LWE ciphertexts where the plaintext space is viewed
as a polynomial ring modulo &lt;code>x&lt;/code>.&lt;/p>
&lt;p>The scalar is first multiplied by the &lt;code>scaling_factor&lt;/code> and then rounded to
the nearest integer before encoding into the plaintext coefficient.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#coeff_encoding = #lwe.constant_coefficient_encoding&amp;lt;scaling_factor=10000&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-4">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">scaling_factor&lt;/td>
&lt;td style="text-align:center">&lt;code>int64_t&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="fullcrtpackingencodingattr">FullCRTPackingEncodingAttr&lt;/h3>
&lt;p>&lt;em>An encoding of cleartexts via CRT slots.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.full_crt_packing_encoding&amp;lt;
int64_t # scaling_factor
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This encoding maps a list of integers via the Chinese Remainder Theorem (CRT) into the plaintext space.&lt;/p>
&lt;p>Given a ring with irreducible ideal polynomial &lt;code>f(x)&lt;/code> and coefficient
modulus &lt;code>q&lt;/code>, &lt;code>f(x)&lt;/code> can be decomposed modulo &lt;code>q&lt;/code> into a direct product of
lower-degree polynomials. This allows full SIMD-style homomorphic operations
across the slots formed from each factor.&lt;/p>
&lt;p>This attribute can only be used in the context of on full CRT packing, where
the polynomial &lt;code>f(x)&lt;/code> splits completely (into linear factors) and the number
of slots equals the degree of &lt;code>f(x)&lt;/code>. This happens when &lt;code>q&lt;/code> is prime and &lt;code>q = 1 mod n&lt;/code>.&lt;/p>
&lt;p>A &lt;code>scaling_factor&lt;/code> is optionally applied on the scalar when converting from
a rounded floating point to an integer.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#coeff_encoding = #lwe.full_crt_packing_encoding&amp;lt;scaling_factor=10000&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-5">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">scaling_factor&lt;/td>
&lt;td style="text-align:center">&lt;code>int64_t&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="inversecanonicalencodingattr">InverseCanonicalEncodingAttr&lt;/h3>
&lt;p>&lt;em>An encoding of cleartexts via the inverse canonical embedding.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.inverse_canonical_encoding&amp;lt;
int64_t # scaling_factor
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Let $n$ be the degree of the polynomials in the plaintext space. An
&amp;ldquo;inverse_canonical_encoding&amp;rdquo; of a list of real or complex values
$v_1, \dots, v_{n/2}$ is (almost) the inverse of the following decoding
map.&lt;/p>
&lt;p>Define a map $\tau_N$ that maps a polynomial $p \in \mathbb{Z}[x] / (x^N + 1)
\to \mathbb{C}^{N/2}$ by evaluating it at the following $N/2$ points,
where $\omega = e^{2 \pi i / 2N}$ is the primitive $2N$th root of unity:&lt;/p>
&lt;p>[
\omega, \omega^3, \omega^5, \dots, \omega^{N-1}
]&lt;/p>
&lt;p>Then the complete decoding operation is $\textup{Decode}(p) =
(1/\Delta)\tau_N(p)$, where $\Delta$ is a scaling parameter and $\tau_N$ is
the truncated canonical embedding above. The encoding operation is the
inverse of the decoding operation, with some caveats explained below.&lt;/p>
&lt;p>The map $\tau_N$ is derived from the so-called &lt;em>canonical embedding&lt;/em>
$\tau$, though in the standard canonical embedding, we evaluate at all odd
powers of the root of unity, $\omega, \omega^3, \dots, \omega^{2N-1}$. For
polynomials in the slightly larger space $\mathbb{R}[x] / (x^N + 1)$, the
image of the canonical embedding is the subspace $H \subset \mathbb{C}^N$
defined by tuples $(z_1, \dots, z_N)$ such that $\overline{z_i} =
\overline{z_{N-i+1}}$. Note that this property holds because polynomial
evaluation commutes with complex conjugates, and the second half of the
roots of unity evaluate are complex conjugates of the first half. The
converse, that any such tuple with complex conjugate symmetry has an
inverse under $\tau$ with all real coefficients, makes $\tau$ is a
bijection onto $H$. $\tau$ and its inverse are explicitly computable as
discrete Fourier Transforms.&lt;/p>
&lt;p>Because of the symmetry in canonical embedding for real polynomials, inputs
to this encoding can be represented as a list of $N/2$ complex points, with
the extra symmetric structure left implicit. $\tau_N$ and its inverse can
also be explicitly computed without need to expand the vectors to length
$N$.&lt;/p>
&lt;p>The rounding step is required to invert the decoding because, while
cleartexts must be (implicitly) in the subspace $H$, they need not be the
output of $\tau_N$ for an &lt;em>integer&lt;/em> polynomial. The rounding step ensures
we can use integer polynomial plaintexts for the FHE operations. There are
multiple rounding mechanisms, and this attribute does not specify which is
used, because in theory two ciphertexts that have used different roundings
are still compatible, though they may have different noise growth patterns.&lt;/p>
&lt;p>The scaling parameter $\Delta$ is specified by the &lt;code>scaling_factor&lt;/code>, which
are applied coefficient-wise using the same semantics as the
&lt;code>constant_coefficient_encoding&lt;/code>.&lt;/p>
&lt;p>A typical flow for the CKKS scheme using this encoding would be to apply an
inverse FFT operation to invert the canonical embedding to be a polynomial
with real coefficients, then encrypt scale the resulting polynomial&amp;rsquo;s
coefficients according to the scaling parameters, then round to get integer
coefficients.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#canonical_encoding = #lwe.inverse_canonical_encoding&amp;lt;scaling_factor=10000&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-6">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">scaling_factor&lt;/td>
&lt;td style="text-align:center">&lt;code>int64_t&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="keyattr">KeyAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.key&amp;lt;
int # slot_index
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An attribute describing the key with which the message is currently
encrypted.&lt;/p>
&lt;p>The key attribute describes the key with which the message is currently
encrypted and decryption can be performed. For example, if the decryption of
a ciphertext $c = (c_0(x), c_1(x))$ is performed by computing the inner
product $(c_0(x), c_1(x)) \cdot (1, s(x))$ then the key is $(1, s(x))$.&lt;/p>
&lt;p>The &lt;code>slot_index&lt;/code> describes the key after using a Galois automorphism to
rotate the plaintext slots by &lt;code>slot_index&lt;/code>. This will correspond to an
action $\phi_k: x \rightarrow x^k$ for some &lt;code>k&lt;/code> that depends on the
structure of the Galois group for the chosen scheme parameters. The
corresponding key will have a new basis $(1, s(x^(k)))$.&lt;/p>
&lt;h4 id="parameters-7">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">slot_index&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lweparamsattr">LWEParamsAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.lwe_params&amp;lt;
IntegerAttr, # cmod
unsigned # dimension
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-8">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cmod&lt;/td>
&lt;td style="text-align:center">&lt;code>IntegerAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">dimension&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="moduluschainattr">ModulusChainAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.modulus_chain&amp;lt;
::llvm::ArrayRef&amp;lt;mlir::IntegerAttr&amp;gt;, # elements
int # current
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An attribute describing the elements of the modulus chain of an RLWE scheme.&lt;/p>
&lt;h4 id="parameters-9">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">elements&lt;/td>
&lt;td style="text-align:center">&lt;code>::llvm::ArrayRef&amp;lt;mlir::IntegerAttr&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">current&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="nooverflowattr">NoOverflowAttr&lt;/h3>
&lt;p>&lt;em>An attribute informing that application data never overflows.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>#lwe.no_overflow&lt;/code>&lt;/p>
&lt;p>This attribute informs lowerings that a program is written so that the message data
will never overflow beyond the message type.&lt;/p>
&lt;p>// FIXME: Have a separate WraparoundOverflow, which lowers the same as NoOverflow?&lt;/p>
&lt;h3 id="plaintextspaceattr">PlaintextSpaceAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.plaintext_space&amp;lt;
::mlir::heir::polynomial::RingAttr, # ring
Attribute # encoding
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An attribute describing the plaintext space and the transformation from
application data to plaintext space of an FHE scheme.&lt;/p>
&lt;p>The plaintext space information is the ring structure, which contains the
plaintext modulus $t$, which may be a power of two in the case of CGGI
ciphertexts, or a prime power for RLWE. LWE ciphertexts use the
ideal polynomial of degree 1 $x$. The plaintext modulus used in LWE-based
CGGI plaintexts describes the full message space $\mathbb{Z}_p$ including
the padding bits. The application data info attribute describes the space
$\mathbb{Z}_p&amp;rsquo;$ where $p&amp;rsquo; &amp;lt; p$ that the underlying message belongs to.&lt;/p>
&lt;p>For RLWE schemes, this will include the type of encoding of application data
integers to a plaintext space &lt;code>Z_p[X]/X^N + 1&lt;/code>. This may be a constant
coefficient encoding, CRT-based packing for SIMD semantics, or other slot
packing. When using full CRT packing, the ring must split into linear
factors. The CKKS scheme will also include attributes describing the complex
encoding, including the scaling factor, which will change after
multiplication and rescaling.&lt;/p>
&lt;h4 id="parameters-10">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::RingAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">encoding&lt;/td>
&lt;td style="text-align:center">&lt;code>Attribute&lt;/code>&lt;/td>
&lt;td>An encoding of a scalar in the constant coefficient or An encoding of cleartexts directly as coefficients. or An encoding of cleartexts via the inverse canonical embedding. or An encoding of cleartexts via CRT slots.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="preserveoverflowattr">PreserveOverflowAttr&lt;/h3>
&lt;p>&lt;em>An attribute informing that application data overflows in the message type.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>#lwe.preserve_overflow&lt;/code>&lt;/p>
&lt;p>This attribute informs lowerings that a program is written so that the message data
may overflow beyond the message type.&lt;/p>
&lt;h3 id="rlweparamsattr">RLWEParamsAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.rlwe_params&amp;lt;
unsigned, # dimension
::mlir::heir::polynomial::RingAttr # ring
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An attribute describing classical RLWE parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>dimension&lt;/code>: the number of polynomials used in an RLWE sample, analogous
to LWEParams.dimension.&lt;/li>
&lt;li>&lt;code>ring&lt;/code>: the polynomial ring to use.&lt;/li>
&lt;/ul>
&lt;h4 id="parameters-11">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">dimension&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::RingAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="unspecifiedbitfieldencodingattr">UnspecifiedBitFieldEncodingAttr&lt;/h3>
&lt;p>&lt;em>An attribute describing unspecified bit field encodings.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.unspecified_bit_field_encoding&amp;lt;
unsigned # cleartext_bitwidth
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>See LWE_BitFieldEncoding for a description of bit field encodings.&lt;/p>
&lt;p>This attribute describes an unspecified bit field encoding; this is where
the starting bit position of the cleartext bit field is unspecified, but its
width is fixed. A noise growth analysis should be performed to determine the
optimal amount of bits needed for noise and padding to specify the bit field
encodings starting bit position.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe_encoding = #lwe.unspecified_bit_field_encoding&amp;lt;cleartext_bitwidth=3&amp;gt;
%lwe_ciphertext = arith.constant &amp;lt;[1,2,3,4]&amp;gt; : tensor&amp;lt;4xi32, #lwe_encoding&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-12">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cleartext_bitwidth&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="lwe-types">LWE types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="lweciphertexttype">LWECiphertextType&lt;/h3>
&lt;p>&lt;em>A type for LWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.lwe_ciphertext&amp;lt;
::mlir::Attribute, # encoding
LWEParamsAttr # lwe_params
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A type for LWE ciphertexts.&lt;/p>
&lt;p>This type keeps track of the plaintext integer encoding for the LWE
Ciphertext to ensure proper decoding after decryption. It also keeps track
of the ring where the LWE ciphertext is defined, which provides information
on the ciphertext shape and the ring operations used in LWE operations.&lt;/p>
&lt;h4 id="parameters-13">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">encoding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Attribute&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">lwe_params&lt;/td>
&lt;td style="text-align:center">&lt;code>LWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lweplaintexttype">LWEPlaintextType&lt;/h3>
&lt;p>&lt;em>A type for LWE plaintexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.lwe_plaintext&amp;lt;
::mlir::Attribute # encoding
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A type for LWE plaintexts.&lt;/p>
&lt;p>This type keeps track of the plaintext integer encoding for the LWE
plaintext before it is encrypted.&lt;/p>
&lt;h4 id="parameters-14">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">encoding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Attribute&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="newlweciphertexttype">NewLWECiphertextType&lt;/h3>
&lt;p>&lt;em>A ciphertext type&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.new_lwe_ciphertext&amp;lt;
ApplicationDataAttr, # application_data
PlaintextSpaceAttr, # plaintext_space
CiphertextSpaceAttr, # ciphertext_space
KeyAttr, # key
ModulusChainAttr # modulus_chain
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An LWE ciphertext will always contain the application data, plaintext space,
ciphertext space, and key information.&lt;/p>
&lt;p>A modulus chain is optionally specified for parameter choices in RLWE
schemes that use more than one of modulus. When no modulus chain is
specified, the ciphertext modulus is always the ciphertext ring&amp;rsquo;s
coefficient modulus.&lt;/p>
&lt;h4 id="parameters-15">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">application_data&lt;/td>
&lt;td style="text-align:center">&lt;code>ApplicationDataAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">plaintext_space&lt;/td>
&lt;td style="text-align:center">&lt;code>PlaintextSpaceAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ciphertext_space&lt;/td>
&lt;td style="text-align:center">&lt;code>CiphertextSpaceAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">key&lt;/td>
&lt;td style="text-align:center">&lt;code>KeyAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">modulus_chain&lt;/td>
&lt;td style="text-align:center">&lt;code>ModulusChainAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="newlweplaintexttype">NewLWEPlaintextType&lt;/h3>
&lt;p>&lt;em>A plaintext type&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.new_lwe_plaintext&amp;lt;
ApplicationDataAttr, # application_data
PlaintextSpaceAttr # plaintext_space
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-16">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">application_data&lt;/td>
&lt;td style="text-align:center">&lt;code>ApplicationDataAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">plaintext_space&lt;/td>
&lt;td style="text-align:center">&lt;code>PlaintextSpaceAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="newlwepublickeytype">NewLWEPublicKeyType&lt;/h3>
&lt;p>&lt;em>A public key for LWE&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.new_lwe_public_key&amp;lt;
KeyAttr, # key
::mlir::heir::polynomial::RingAttr # ring
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-17">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">key&lt;/td>
&lt;td style="text-align:center">&lt;code>KeyAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::RingAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="newlwesecretkeytype">NewLWESecretKeyType&lt;/h3>
&lt;p>&lt;em>A secret key for LWE&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.new_lwe_secret_key&amp;lt;
KeyAttr, # key
::mlir::heir::polynomial::RingAttr # ring
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-18">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">key&lt;/td>
&lt;td style="text-align:center">&lt;code>KeyAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::RingAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlweciphertexttype">RLWECiphertextType&lt;/h3>
&lt;p>&lt;em>A type for RLWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.rlwe_ciphertext&amp;lt;
::mlir::Attribute, # encoding
RLWEParamsAttr, # rlwe_params
Type # underlying_type
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-19">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">encoding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Attribute&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">rlwe_params&lt;/td>
&lt;td style="text-align:center">&lt;code>RLWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">underlying_type&lt;/td>
&lt;td style="text-align:center">&lt;code>Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlweplaintexttype">RLWEPlaintextType&lt;/h3>
&lt;p>&lt;em>A type for RLWE plaintexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.rlwe_plaintext&amp;lt;
::mlir::Attribute, # encoding
::mlir::heir::polynomial::RingAttr, # ring
Type # underlying_type
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-20">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">encoding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Attribute&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::RingAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">underlying_type&lt;/td>
&lt;td style="text-align:center">&lt;code>Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlwepublickeytype">RLWEPublicKeyType&lt;/h3>
&lt;p>&lt;em>A public key for RLWE&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.rlwe_public_key&amp;lt;
RLWEParamsAttr # rlwe_params
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-21">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">rlwe_params&lt;/td>
&lt;td style="text-align:center">&lt;code>RLWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="rlwesecretkeytype">RLWESecretKeyType&lt;/h3>
&lt;p>&lt;em>A secret key for RLWE&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!lwe.rlwe_secret_key&amp;lt;
RLWEParamsAttr # rlwe_params
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-22">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">rlwe_params&lt;/td>
&lt;td style="text-align:center">&lt;code>RLWEParamsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="lwe-ops">LWE ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="lweadd-heirlweaddop">&lt;code>lwe.add&lt;/code> (heir::lwe::AddOp)&lt;/h3>
&lt;p>&lt;em>Add two LWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.add` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lweencode-heirlweencodeop">&lt;code>lwe.encode&lt;/code> (heir::lwe::EncodeOp)&lt;/h3>
&lt;p>&lt;em>Encode an integer to yield an LWE plaintext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.encode` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Encode an integer to yield an LWE plaintext.&lt;/p>
&lt;p>This op uses a an encoding attribute to encode the bits of the integer into
an LWE plaintext value that can then be encrypted.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>%Y = lwe.encode %value {encoding = #enc}: i1 to !lwe.lwe_plaintext&amp;lt;encoding = #enc&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>encoding&lt;/code>&lt;/td>&lt;td>::mlir::Attribute&lt;/td>&lt;td>An attribute describing encoded LWE plaintexts using bit fields. or An attribute describing unspecified bit field encodings.&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless-integer-like or floating-point-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwemul_scalar-heirlwemulscalarop">&lt;code>lwe.mul_scalar&lt;/code> (heir::lwe::MulScalarOp)&lt;/h3>
&lt;p>&lt;em>Multiply an LWE ciphertext by a scalar&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.mul_scalar` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>scalar&lt;/code>&lt;/td>
&lt;td>integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lweradd-heirlweraddop">&lt;code>lwe.radd&lt;/code> (heir::lwe::RAddOp)&lt;/h3>
&lt;p>&lt;em>Add two RLWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.radd` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lweradd_plain-heirlweraddplainop">&lt;code>lwe.radd_plain&lt;/code> (heir::lwe::RAddPlainOp)&lt;/h3>
&lt;p>&lt;em>Addition between RLWE ciphertext-plaintext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.radd_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>IsCiphertextPlaintextOp&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwerlwe_decode-heirlwerlwedecodeop">&lt;code>lwe.rlwe_decode&lt;/code> (heir::lwe::RLWEDecodeOp)&lt;/h3>
&lt;p>&lt;em>Decode an RLWE plaintext to an underlying type&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rlwe_decode` $input attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>encoding&lt;/code>&lt;/td>&lt;td>::mlir::Attribute&lt;/td>&lt;td>An encoding of a scalar in the constant coefficient or An encoding of cleartexts directly as coefficients. or An encoding of cleartexts via the inverse canonical embedding. or An encoding of cleartexts via CRT slots.&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>ring&lt;/code>&lt;/td>&lt;td>::mlir::heir::polynomial::RingAttr&lt;/td>&lt;td>an attribute specifying a polynomial ring&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer-like or floating-point-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwerlwe_decrypt-heirlwerlwedecryptop">&lt;code>lwe.rlwe_decrypt&lt;/code> (heir::lwe::RLWEDecryptOp)&lt;/h3>
&lt;p>&lt;em>Decrypt an RLWE ciphertext to a RLWE plaintext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rlwe_decrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Decrypt an RLWE ciphertext to yield a RLWE plaintext&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>secret_key&lt;/code>&lt;/td>
&lt;td>A secret key for LWE&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwerlwe_encode-heirlwerlweencodeop">&lt;code>lwe.rlwe_encode&lt;/code> (heir::lwe::RLWEEncodeOp)&lt;/h3>
&lt;p>&lt;em>Encode an integer to yield an RLWE plaintext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rlwe_encode` $input attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Encode an integer to yield an RLWE plaintext.&lt;/p>
&lt;p>This op uses a an encoding attribute to encode the bits of the integer into
an RLWE plaintext value that can then be encrypted. CKKS cleartext inputs may
be floating points, and a scaling factor described by the encoding will be
applied.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>%Y = lwe.rlwe_encode %value {encoding = #enc, ring = #ring}: i1 to !lwe.rlwe_plaintext&amp;lt;encoding = #enc, ring = #ring&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>encoding&lt;/code>&lt;/td>&lt;td>::mlir::Attribute&lt;/td>&lt;td>An encoding of a scalar in the constant coefficient or An encoding of cleartexts directly as coefficients. or An encoding of cleartexts via the inverse canonical embedding. or An encoding of cleartexts via CRT slots.&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>ring&lt;/code>&lt;/td>&lt;td>::mlir::heir::polynomial::RingAttr&lt;/td>&lt;td>an attribute specifying a polynomial ring&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless-integer-like or floating-point-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwerlwe_encrypt-heirlwerlweencryptop">&lt;code>lwe.rlwe_encrypt&lt;/code> (heir::lwe::RLWEEncryptOp)&lt;/h3>
&lt;p>&lt;em>Encrypt an RLWE plaintext to a RLWE ciphertext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rlwe_encrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Encrypt an RLWE plaintext to yield a RLWE ciphertext.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>key&lt;/code>&lt;/td>
&lt;td>A secret key for LWE or A public key for LWE&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwermul-heirlwermulop">&lt;code>lwe.rmul&lt;/code> (heir::lwe::RMulOp)&lt;/h3>
&lt;p>&lt;em>Multiplies two RLWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rmul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwermul_plain-heirlwermulplainop">&lt;code>lwe.rmul_plain&lt;/code> (heir::lwe::RMulPlainOp)&lt;/h3>
&lt;p>&lt;em>Multiplication between RLWE ciphertext-plaintext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rmul_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>IsCiphertextPlaintextOp&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwernegate-heirlwernegateop">&lt;code>lwe.rnegate&lt;/code> (heir::lwe::RNegateOp)&lt;/h3>
&lt;p>&lt;em>Negate a RLWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rnegate` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>new-lwe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>new-lwe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwersub-heirlwersubop">&lt;code>lwe.rsub&lt;/code> (heir::lwe::RSubOp)&lt;/h3>
&lt;p>&lt;em>Subtract two RLWE ciphertexts&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rsub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwersub_plain-heirlwersubplainop">&lt;code>lwe.rsub_plain&lt;/code> (heir::lwe::RSubPlainOp)&lt;/h3>
&lt;p>&lt;em>Subtraction between RLWE ciphertext-plaintext&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.rsub_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>IsCiphertextPlaintextOp&lt;/code>, &lt;code>SameOperandsAndResultPlaintextTypes&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-13">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-13">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwetrivial_encrypt-heirlwetrivialencryptop">&lt;code>lwe.trivial_encrypt&lt;/code> (heir::lwe::TrivialEncryptOp)&lt;/h3>
&lt;p>&lt;em>Create a trivial encryption of a plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.trivial_encrypt` operands attr-dict `:` qualified(type(operands)) `to` qualified(type(results))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>params&lt;/code>&lt;/td>&lt;td>::mlir::heir::lwe::LWEParamsAttr&lt;/td>&lt;td>&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-14">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A type for LWE plaintexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-14">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A type for LWE ciphertexts&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lwereinterpret_application_data-heirlwereinterpretapplicationdataop">&lt;code>lwe.reinterpret_application_data&lt;/code> (heir::lwe::ReinterpretApplicationDataOp)&lt;/h3>
&lt;p>&lt;em>A placeholder cast from one ciphertext type to another&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `lwe.reinterpret_application_data` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>The &lt;code>cast&lt;/code> op is thus used to translate application data (e.g., &lt;code>message_type&lt;/code>)
between ciphertexts in particular situations, such as when the bitwidth of the
message type changes, but this change is not observed in the plaintext space,
or when lowering to an API that does not keep track of types.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-15">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-15">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="lwe-additional-definitions">LWE additional definitions&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="lweencryptiontype">LweEncryptionType&lt;/h3>
&lt;p>&lt;em>An enum attribute representing an encryption method&lt;/em>&lt;/p>
&lt;h4 id="cases">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">msb&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>msb&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">lsb&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>lsb&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">mix&lt;/td>
&lt;td style="text-align:center">&lt;code>2&lt;/code>&lt;/td>
&lt;td>mix&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Mgmt</title><link>https://heir.dev/docs/dialects/mgmt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/mgmt/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="mgmt-dialect">&amp;lsquo;mgmt&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>mgmt&lt;/code> dialect contains scheme-agnostic ciphertext management ops
(like relinearize and mod reduce), to enable initial high-level compiler
passes to perform a first pass at parameter selection, while lower-level
passes may refine them with scheme-specific information.&lt;/p>
&lt;h2 id="mgmt-attributes">Mgmt attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="mgmtattr">MgmtAttr&lt;/h3>
&lt;p>&lt;em>Container attribute for all mgmt parameter&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#mgmt.mgmt&amp;lt;
int, # level
int, # dimension
int64_t # scale
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute is used to store all mgmt parameters.&lt;/p>
&lt;p>The attribute is a struct with the following fields:&lt;/p>
&lt;ul>
&lt;li>&lt;code>level&lt;/code> : the level of the ciphertext, from L to 0&lt;/li>
&lt;li>&lt;code>dimension&lt;/code> : the dimension of the ciphertext, defaults to 2&lt;/li>
&lt;/ul>
&lt;p>Internally, this attribute is used by secret-to-&lt;scheme>
for determining the level and dimension of the ciphertext.&lt;/p>
&lt;p>It should be populated by &amp;ndash;secret-with-mgmt-&lt;scheme> before
going through the secret-to-&lt;scheme> pass.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#mgmt = #mgmt.mgmt&amp;lt;level = 1&amp;gt; // dimension defaults to 2
#mgmt1 = #mgmt.mgmt&amp;lt;level = 1, dimension = 3&amp;gt;
%0 = secret.generic(%arg0, %arg1 : !secret.secret&amp;lt;i16&amp;gt;) attrs = {mgmt.mgmt = #mgmt} {
...
} -&amp;gt; !secret.secret&amp;lt;i16&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">level&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">dimension&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">scale&lt;/td>
&lt;td style="text-align:center">&lt;code>int64_t&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfheparamsattr">OpenfheParamsAttr&lt;/h3>
&lt;p>&lt;em>Container attribute for some OpenFHE-specific parameters&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#mgmt.openfhe_params&amp;lt;
int, # evalAddCount
int # keySwitchCount
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute is used to store some OpenFHE-specific parameters.&lt;/p>
&lt;p>The attribute is a struct with the following fields:&lt;/p>
&lt;ul>
&lt;li>&lt;code>evalAddCount&lt;/code> : param for OpenFHE SetEvalAddCount&lt;/li>
&lt;li>&lt;code>keySwitchCount&lt;/code> : param for OpenFHE SetKeySwitchCount&lt;/li>
&lt;/ul>
&lt;p>When this attribute presents, the lowering of openfhe pass
will use these parameters to set the corresponding OpenFHE
parameters.&lt;/p>
&lt;p>It should be populated by &amp;ndash;secret-with-mgmt-bgv before
going through the secret-to-bgv bgv-to-openfhe pass.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#openfhe_params = #mgmt.openfhe_params&amp;lt;evalAddCount = 1, keySwitchCount = 1&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">evalAddCount&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">keySwitchCount&lt;/td>
&lt;td style="text-align:center">&lt;code>int&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="mgmt-ops">Mgmt ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="mgmtadjust_scale-heirmgmtadjustscaleop">&lt;code>mgmt.adjust_scale&lt;/code> (heir::mgmt::AdjustScaleOp)&lt;/h3>
&lt;p>&lt;em>Adjust the scale of the input ciphertext (for BGV and CKKS)&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mgmt.adjust_scale` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>This is scheme-agonistic operation that adjust the scale of the input
ciphertext. This is an opaque operation, and the concrete value of the
scale is determined by other methods.&lt;/p>
&lt;p>To distinguish different opaque adjust_scale operations, the &lt;code>id&lt;/code> attribute
is used.&lt;/p>
&lt;p>At the time of &lt;code>secret-insert-mgmt-&amp;lt;scheme&amp;gt;&lt;/code>, the concrete scale
is not known as the scheme parameter is not generated.
Further passes like &lt;code>populate-scale-&amp;lt;scheme&amp;gt;&lt;/code> is responsible for materializing
the concrete scale when the scheme parameter is known.&lt;/p>
&lt;p>When further lowered, it could be lowered to &lt;code>bgv.mul_plain&lt;/code>
or &lt;code>ckks.mul_plain&lt;/code> depending on the scheme.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>id&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mgmtbootstrap-heirmgmtbootstrapop">&lt;code>mgmt.bootstrap&lt;/code> (heir::mgmt::BootstrapOp)&lt;/h3>
&lt;p>&lt;em>Bootstrap the input ciphertext to refresh its noise budget&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mgmt.bootstrap` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>This is a scheme-agnostic operation that implies bootstrapping
of the input ciphertext to refresh its noise budget.&lt;/p>
&lt;p>Bootstrapping is a technique used in homomorphic encryption to
reduce the noise in a ciphertext, allowing further operations
to be performed on it without decryption.&lt;/p>
&lt;p>When further lowered, it could be lowered to bgv.bootstrap
or ckks.bootstrap depending on the scheme.&lt;/p>
&lt;p>For the current backend, only ckks.bootstrap is supported.
Further backend may include bgv.bootstrap.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mgmtinit-heirmgmtinitop">&lt;code>mgmt.init&lt;/code> (heir::mgmt::InitOp)&lt;/h3>
&lt;p>&lt;em>Init the plaintext with mgmt attributes&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mgmt.init` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>This is a scheme-agnostic operation that initializes the plaintext
with &lt;code>mgmt&lt;/code> attributes.&lt;/p>
&lt;p>Plaintext has multiple sources, e.g. function argument, arith.constant,
tensor.empty, etc. However, they may have multiple uses in HE circuit
and the level/scale information for them may be different, so we could
not annotate them with &lt;code>mgmt&lt;/code> attributes directly, as they could not have
more than one annotation.&lt;/p>
&lt;p>Also, &lt;code>mgmt&lt;/code> attributes annotated on them may get lost as other optimization
like CSE or constant folding may canonicalize them away.&lt;/p>
&lt;p>To address the problem, for each &lt;em>use&lt;/em> of the plaintext, we insert an &lt;code>mgmt.init&lt;/code>
operation to initialize the plaintext with &lt;code>mgmt&lt;/code> attributes.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mgmtlevel_reduce-heirmgmtlevelreduceop">&lt;code>mgmt.level_reduce&lt;/code> (heir::mgmt::LevelReduceOp)&lt;/h3>
&lt;p>&lt;em>Reduce the level of input ciphertext by dropping the last k RNS limbs&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mgmt.level_reduce` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>This scheme-agonistic operation reduces the ciphertext level
by k, as specified by the &lt;code>levelToDrop&lt;/code> attribute.&lt;/p>
&lt;p>If &lt;code>levelToDrop&lt;/code> is not specified, it defaults to 1.&lt;/p>
&lt;p>Input ciphertext is assumed to be in RNS form when further lowered.&lt;/p>
&lt;p>Later passes may lower this op to &lt;code>bgv.level_reduce&lt;/code>
or &lt;code>ckks.level_reduce&lt;/code> depending on the scheme.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>levelToDrop&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mgmtmodreduce-heirmgmtmodreduceop">&lt;code>mgmt.modreduce&lt;/code> (heir::mgmt::ModReduceOp)&lt;/h3>
&lt;p>&lt;em>Modulus switch the input ciphertext down by one limb (RNS assumed)&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mgmt.modreduce` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>This is scheme-agonistic operation that implies modulus switching/rescaling
by one limb.&lt;/p>
&lt;p>Input ciphertext is assumed to be in RNS form when further lowered.&lt;/p>
&lt;p>When further lowered, it could be lowered to bgv.modulus_switch
or ckks.rescale depending on the scheme.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mgmtrelinearize-heirmgmtrelinearizeop">&lt;code>mgmt.relinearize&lt;/code> (heir::mgmt::RelinearizeOp)&lt;/h3>
&lt;p>&lt;em>Relinearize the input ciphertext to be &lt;em>linear&lt;/em>&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mgmt.relinearize` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>This is scheme-agonistic operation that implies relinearization
of the input ciphertext to be &lt;em>linear&lt;/em> (i.e. returns to dimension 2).&lt;/p>
&lt;p>This is used solely by multiplication. For rotation, currently HEIR
assumes relinearization is done internally and does not have a separate
scheme-specific operation for it.&lt;/p>
&lt;p>This accepts a ciphertext with dimension &amp;gt; 2 and returns a ciphertext
with dimension 2. Note that the semantic includes the relinearization
of higher dimension input like input with dimension 4 or higher,
which when materialized should require multiple relinearization keys.&lt;/p>
&lt;p>When further lowered, it could be lowered to bgv.relinearize
or ckks.relinearize depending on the scheme.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: ModArith</title><link>https://heir.dev/docs/dialects/modarith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/modarith/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="mod_arith-dialect">&amp;lsquo;mod_arith&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>mod_arith&lt;/code> dialect contains operations used for modulo arithmetic.&lt;/p>
&lt;h2 id="modarith-types">ModArith types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="modarithtype">ModArithType&lt;/h3>
&lt;p>&lt;em>Integer type with modular arithmetic&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!mod_arith.int&amp;lt;
::mlir::IntegerAttr # modulus
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>&lt;code>mod_arith.int&amp;lt;p&amp;gt;&lt;/code> represents an element of the ring of integers modulo $p$.
The &lt;code>modulus&lt;/code> attribute is the ring modulus, and &lt;code>mod_arith&lt;/code> operations lower to
&lt;code>arith&lt;/code> operations that produce results in the range &lt;code>[0, modulus)&lt;/code>, often called
the &lt;em>canonical representative&lt;/em>.&lt;/p>
&lt;p>&lt;code>modulus&lt;/code> is specified with an integer type suffix, for example,
&lt;code>mod_arith.int&amp;lt;65537 : i32&amp;gt;&lt;/code>. This corresponds to the storage type for the
modulus, and is &lt;code>i64&lt;/code> by default.&lt;/p>
&lt;p>It is required that the underlying integer type should be larger than
twice the modulus (have one extra bit of storage space) to avoid signedness
issues. For example, when &lt;code>modulus == 2 ** 32 - 1&lt;/code>, the underlying type
for the modulus should be at least &lt;code>i33&lt;/code>, though &lt;code>i64&lt;/code> is a natural choice.&lt;/p>
&lt;p>Passes may allow intermediate values that do not always produce a
canonical representative in &lt;code>[0, modulus)&lt;/code>. For example, if the machine storage
type is &lt;code>i64&lt;/code>, but the &lt;code>modulus&lt;/code> fits within an &lt;code>i32&lt;/code>, a lowering could
allow intermediate arithmetic values to grow to as large as an &lt;code>i64&lt;/code> before
reducing them. However, all passes must ensure that values used outside
the local scope (e.g., function return values or arguments to calls to linked
functions) are appropriately reduced to the canonical representative.
&lt;code>modulus&lt;/code> is the modulus the arithmetic working with.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>!Zp1 = !mod_arith.int&amp;lt;7&amp;gt; // implicitly being i64
!Zp2 = !mod_arith.int&amp;lt;65537 : i32&amp;gt;
!Zp3 = !mod_arith.int&amp;lt;536903681 : i64&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">modulus&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::IntegerAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="modarith-ops">ModArith ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="mod_arithadd-heirmod_arithaddop">&lt;code>mod_arith.add&lt;/code> (heir::mod_arith::AddOp)&lt;/h3>
&lt;p>&lt;em>Modular addition operation&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.add` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Computes modular addition.&lt;/p>
&lt;p>Unless otherwise specified, the operation assumes both inputs are canonical
representatives and guarantees the output being canonical representative.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithbarrett_reduce-heirmod_arithbarrettreduceop">&lt;code>mod_arith.barrett_reduce&lt;/code> (heir::mod_arith::BarrettReduceOp)&lt;/h3>
&lt;p>&lt;em>Compute the first step of the Barrett reduction.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.barrett_reduce` operands attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Let $q$ denote a statically known modulus and $b = 4^{w}$, where $w$ is the
smallest bit-width that contains the range $[0, q)$. The Barrett reduce
operation computes &lt;code>barret_reduce x = x - floor(x * floor(b / q) / b) * q&lt;/code>.&lt;/p>
&lt;p>Given $0 &amp;lt;= x &amp;lt; q^2$, then this will compute $(x \mod q)$ or $(x \mod q) + q$.&lt;/p>
&lt;p>Traits: &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>modulus&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>arbitrary integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless-integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithconstant-heirmod_arithconstantop">&lt;code>mod_arith.constant&lt;/code> (heir::mod_arith::ConstantOp)&lt;/h3>
&lt;p>&lt;em>Define a constant value via an attribute.&lt;/em>&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> mod_arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">123&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>mod_arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>int&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">65537&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>ConstantLike&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>value&lt;/code>&lt;/td>&lt;td>::mlir::TypedAttr&lt;/td>&lt;td>TypedAttr instance&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithencapsulate-heirmod_arithencapsulateop">&lt;code>mod_arith.encapsulate&lt;/code> (heir::mod_arith::EncapsulateOp)&lt;/h3>
&lt;p>&lt;em>Encapsulate an integer into a mod_arith type&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.encapsulate` operands attr-dict `:` type($input) `-&amp;gt;` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>mod_arith.encapsulate&lt;/code> converts the integer to be of mod_arith type.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>mod_arith.encapsulate %c0 : i32 -&amp;gt; mod_arith.int&amp;lt;65537 : i32&amp;gt;
mod_arith.encapsulate %c1 : i64 -&amp;gt; mod_arith.int&amp;lt;65537&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless-integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithextract-heirmod_arithextractop">&lt;code>mod_arith.extract&lt;/code> (heir::mod_arith::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract the integer stored inside mod_arith type&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.extract` operands attr-dict `:` type($input) `-&amp;gt;` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>mod_arith.extract&lt;/code> extracts the integer inside the mod_arith type.&lt;/p>
&lt;p>It is required that the bitwidth of the output integer type is the same
as that of the storage type of the input mod_arith type.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>%m0 = mod_arith.encapsulate %c0 : i32 -&amp;gt; mod_arith.int&amp;lt;65537 : i32&amp;gt;
%m1 = mod_arith.encapsulate %c1 : i64 -&amp;gt; mod_arith.int&amp;lt;65537&amp;gt;
%c2 = mod_arith.extract %m0 : mod_arith.int&amp;lt;65537 : i32&amp;gt; -&amp;gt; i32
%c3 = mod_arith.extract %m1 : mod_arith.int&amp;lt;65537&amp;gt; -&amp;gt; i64
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithmac-heirmod_arithmacop">&lt;code>mod_arith.mac&lt;/code> (heir::mod_arith::MacOp)&lt;/h3>
&lt;p>&lt;em>Modular multiplication-and-accumulation operation&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.mac` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>mod_arith.mac x, y, z&lt;/code> computes $(x * y) + z$&lt;/p>
&lt;p>Unless otherwise specified, the operation assumes all inputs are canonical
representatives and guarantees the output being canonical representative.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>acc&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithmod_switch-heirmod_arithmodswitchop">&lt;code>mod_arith.mod_switch&lt;/code> (heir::mod_arith::ModSwitchOp)&lt;/h3>
&lt;p>&lt;em>Change the modulus of a mod_arith&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.mod_switch` $input attr-dict `:` type($input) `to` type($output)
&lt;/code>&lt;/pre>&lt;p>&amp;ldquo;mod_switch&amp;rdquo; operation to change the modulus of a mod_arith type to a
bigger space.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>`mod_arith.mod_switch %c0 : mod_arith.int&amp;lt;65537 : i32&amp;gt; to mod_arith.int&amp;lt;65539 : i32&amp;gt;`
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>SameOperandsAndResultShape&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>Integer type with modular arithmetic&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>Integer type with modular arithmetic&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithmul-heirmod_arithmulop">&lt;code>mod_arith.mul&lt;/code> (heir::mod_arith::MulOp)&lt;/h3>
&lt;p>&lt;em>Modular multiplication operation&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.mul` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Computes modular multiplication.&lt;/p>
&lt;p>Unless otherwise specified, the operation assumes both inputs are canonical
representatives and guarantees the output being canonical representative.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithreduce-heirmod_arithreduceop">&lt;code>mod_arith.reduce&lt;/code> (heir::mod_arith::ReduceOp)&lt;/h3>
&lt;p>&lt;em>Reduce the mod arith type to its canonical representative&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.reduce` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>mod_arith.reduce x&lt;/code> produces $y$, the canonical representative in $[0, q)$
such that $x \equiv y \mod q$.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;pre tabindex="0">&lt;code>%c0 = arith.constant 65538 : i32
%m0 = mod_arith.encapsulate %c0 : i32 -&amp;gt; mod_arith.int&amp;lt;65537 : i32&amp;gt;
// mod_arith.extract %m0 produces 65538
%m1 = mod_arith.reduce %m0 : mod_arith.int&amp;lt;65537: i32&amp;gt;
// mod_arith.extract %m1 produces 1
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithsubifge-heirmod_arithsubifgeop">&lt;code>mod_arith.subifge&lt;/code> (heir::mod_arith::SubIfGEOp)&lt;/h3>
&lt;p>&lt;em>Compute (x &amp;gt;= y) ? x - y : x.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.subifge` operands attr-dict `:` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>SameOperandsAndResultType&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless-integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless-integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mod_arithsub-heirmod_arithsubop">&lt;code>mod_arith.sub&lt;/code> (heir::mod_arith::SubOp)&lt;/h3>
&lt;p>&lt;em>Modular subtraction operation&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `mod_arith.sub` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>Computes modular subtraction.&lt;/p>
&lt;p>Unless otherwise specified, the operation assumes both inputs are canonical
representatives and guarantees the output being canonical representative.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>mod_arith-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Openfhe</title><link>https://heir.dev/docs/dialects/openfhe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/openfhe/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="openfhe-dialect">&amp;lsquo;openfhe&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>openfhe&lt;/code> dialect is an exit dialect for generating c++ code against the OpenFHE library API.&lt;/p>
&lt;p>See &lt;a href="https://github.com/openfheorg/openfhe-development">https://github.com/openfheorg/openfhe-development&lt;/a>&lt;/p>
&lt;h2 id="openfhe-types">Openfhe types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="ccparamstype">CCParamsType&lt;/h3>
&lt;p>&lt;em>The CCParams required to create CryptoContext.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.cc_params&lt;/code>&lt;/p>
&lt;h3 id="cryptocontexttype">CryptoContextType&lt;/h3>
&lt;p>&lt;em>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.crypto_context&lt;/code>&lt;/p>
&lt;h3 id="evalkeytype">EvalKeyType&lt;/h3>
&lt;p>&lt;em>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.eval_key&lt;/code>&lt;/p>
&lt;h3 id="privatekeytype">PrivateKeyType&lt;/h3>
&lt;p>&lt;em>The private key required to decrypt a ciphertext in OpenFHE.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.private_key&lt;/code>&lt;/p>
&lt;h3 id="publickeytype">PublicKeyType&lt;/h3>
&lt;p>&lt;em>The public key required to encrypt plaintext in OpenFHE.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!openfhe.public_key&lt;/code>&lt;/p>
&lt;h2 id="openfhe-ops">Openfhe ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="openfheadd_inplace-heiropenfheaddinplaceop">&lt;code>openfhe.add_inplace&lt;/code> (heir::openfhe::AddInPlaceOp)&lt;/h3>
&lt;p>&lt;em>Performs in-place homomorphic addition, modifying lhs.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.add_inplace` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfheadd-heiropenfheaddop">&lt;code>openfhe.add&lt;/code> (heir::openfhe::AddOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE add operation of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfheadd_plain-heiropenfheaddplainop">&lt;code>openfhe.add_plain&lt;/code> (heir::openfhe::AddPlainOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE add operation of a ciphertext and a plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.add_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AllCiphertextTypesMatch&lt;/code>, &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfheautomorph-heiropenfheautomorphop">&lt;code>openfhe.automorph&lt;/code> (heir::openfhe::AutomorphOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.automorph` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evalKey&lt;/code>&lt;/td>
&lt;td>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhebootstrap-heiropenfhebootstrapop">&lt;code>openfhe.bootstrap&lt;/code> (heir::openfhe::BootstrapOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE bootstrap operation of a ciphertext. (For CKKS)&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.bootstrap` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhedecrypt-heiropenfhedecryptop">&lt;code>openfhe.decrypt&lt;/code> (heir::openfhe::DecryptOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.decrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>privateKey&lt;/code>&lt;/td>
&lt;td>The private key required to decrypt a ciphertext in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfheencrypt-heiropenfheencryptop">&lt;code>openfhe.encrypt&lt;/code> (heir::openfhe::EncryptOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.encrypt` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>encryptionKey&lt;/code>&lt;/td>
&lt;td>The public key required to encrypt plaintext in OpenFHE. or The private key required to decrypt a ciphertext in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhegen_bootstrapkey-heiropenfhegenbootstrapkeyop">&lt;code>openfhe.gen_bootstrapkey&lt;/code> (heir::openfhe::GenBootstrapKeyOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.gen_bootstrapkey` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>privateKey&lt;/code>&lt;/td>
&lt;td>The private key required to decrypt a ciphertext in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhegen_context-heiropenfhegencontextop">&lt;code>openfhe.gen_context&lt;/code> (heir::openfhe::GenContextOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.gen_context` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>supportFHE&lt;/code>&lt;/td>&lt;td>::mlir::BoolAttr&lt;/td>&lt;td>bool attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>The CCParams required to create CryptoContext.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>context&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhegen_mulkey-heiropenfhegenmulkeyop">&lt;code>openfhe.gen_mulkey&lt;/code> (heir::openfhe::GenMulKeyOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.gen_mulkey` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>privateKey&lt;/code>&lt;/td>
&lt;td>The private key required to decrypt a ciphertext in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhegen_params-heiropenfhegenparamsop">&lt;code>openfhe.gen_params&lt;/code> (heir::openfhe::GenParamsOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.gen_params` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Generates the parameters for the OpenFHE scheme.&lt;/p>
&lt;p>&lt;code>mulDepth&lt;/code> is the depth of the multiplication circuit,
including the bootstrapping depth.&lt;/p>
&lt;p>&lt;code>plainMod&lt;/code> is the modulus of the plaintext space. If we
are using CKKS, this is 0.&lt;/p>
&lt;p>&lt;code>insecure&lt;/code> is a flag that determines whether the parameters
are generated securely or not. In Openfhe, this means setting
HEStd_NotSet for security level.&lt;/p>
&lt;p>For other flags, see the OpenFHE documentation in
&lt;a href="https://github.com/openfheorg/openfhe-development/blob/main/src/pke/examples/README.md#description-of-the-cryptocontext-parameters-and-their-restrictions">https://github.com/openfheorg/openfhe-development/blob/main/src/pke/examples/README.md#description-of-the-cryptocontext-parameters-and-their-restrictions&lt;/a>&lt;/p>
&lt;p>Interfaces: &lt;code>InferTypeOpInterface&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>mulDepth&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>plainMod&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>ringDim&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>batchSize&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>firstModSize&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>scalingModSize&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>evalAddCount&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>keySwitchCount&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>digitSize&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>numLargeDigits&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>maxRelinSkDeg&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>insecure&lt;/code>&lt;/td>&lt;td>::mlir::BoolAttr&lt;/td>&lt;td>bool attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>encryptionTechniqueExtended&lt;/code>&lt;/td>&lt;td>::mlir::BoolAttr&lt;/td>&lt;td>bool attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>keySwitchingTechniqueBV&lt;/code>&lt;/td>&lt;td>::mlir::BoolAttr&lt;/td>&lt;td>bool attribute&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>scalingTechniqueFixedManual&lt;/code>&lt;/td>&lt;td>::mlir::BoolAttr&lt;/td>&lt;td>bool attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>params&lt;/code>&lt;/td>
&lt;td>The CCParams required to create CryptoContext.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhegen_rotkey-heiropenfhegenrotkeyop">&lt;code>openfhe.gen_rotkey&lt;/code> (heir::openfhe::GenRotKeyOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.gen_rotkey` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>indices&lt;/code>&lt;/td>&lt;td>::mlir::DenseI64ArrayAttr&lt;/td>&lt;td>i64 dense array attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>privateKey&lt;/code>&lt;/td>
&lt;td>The private key required to decrypt a ciphertext in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhekey_switch-heiropenfhekeyswitchop">&lt;code>openfhe.key_switch&lt;/code> (heir::openfhe::KeySwitchOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.key_switch` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>evalKey&lt;/code>&lt;/td>
&lt;td>The evaluation key required to keyswitch/relinearize/rotate/automorphism operation in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhelevel_reduce-heiropenfhelevelreduceop">&lt;code>openfhe.level_reduce&lt;/code> (heir::openfhe::LevelReduceOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE level_reduce operation of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.level_reduce` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>levelToDrop&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>64-bit signless integer attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemake_ckks_packed_plaintext-heiropenfhemakeckkspackedplaintextop">&lt;code>openfhe.make_ckks_packed_plaintext&lt;/code> (heir::openfhe::MakeCKKSPackedPlaintextOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.make_ckks_packed_plaintext` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-13">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>ranked tensor of floating-point or integer values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemake_packed_plaintext-heiropenfhemakepackedplaintextop">&lt;code>openfhe.make_packed_plaintext&lt;/code> (heir::openfhe::MakePackedPlaintextOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.make_packed_plaintext` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-14">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>ranked tensor of integer values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemod_reduce-heiropenfhemodreduceop">&lt;code>openfhe.mod_reduce&lt;/code> (heir::openfhe::ModReduceOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mod_reduce operation of a ciphertext. (used only for BGV/CKKS)&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mod_reduce` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-15">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemul_const-heiropenfhemulconstop">&lt;code>openfhe.mul_const&lt;/code> (heir::openfhe::MulConstOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mul operation of a ciphertext and a constant.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mul_const` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-16">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>constant&lt;/code>&lt;/td>
&lt;td>64-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-13">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemul_no_relin-heiropenfhemulnorelinop">&lt;code>openfhe.mul_no_relin&lt;/code> (heir::openfhe::MulNoRelinOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mul operation of two ciphertexts without relinearization.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mul_no_relin` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-17">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-14">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemul-heiropenfhemulop">&lt;code>openfhe.mul&lt;/code> (heir::openfhe::MulOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mul operation of two ciphertexts with relinearization.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-18">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-15">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhemul_plain-heiropenfhemulplainop">&lt;code>openfhe.mul_plain&lt;/code> (heir::openfhe::MulPlainOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE mul operation of a ciphertext and a plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.mul_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-19">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>plaintext&lt;/code>&lt;/td>
&lt;td>A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-16">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhenegate-heiropenfhenegateop">&lt;code>openfhe.negate&lt;/code> (heir::openfhe::NegateOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE negate operation of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.negate` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-20">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-17">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfherelin-heiropenfherelinop">&lt;code>openfhe.relin&lt;/code> (heir::openfhe::RelinOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE relinearize operation of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.relin` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-21">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-18">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfherot-heiropenfherotop">&lt;code>openfhe.rot&lt;/code> (heir::openfhe::RotOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.rot` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-4">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>index&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-22">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-19">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhesetup_bootstrap-heiropenfhesetupbootstrapop">&lt;code>openfhe.setup_bootstrap&lt;/code> (heir::openfhe::SetupBootstrapOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.setup_bootstrap` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="attributes-5">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>levelBudgetEncode&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>levelBudgetDecode&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-23">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhesquare-heiropenfhesquareop">&lt;code>openfhe.square&lt;/code> (heir::openfhe::SquareOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE square operation of a ciphertext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.square` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-24">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-20">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhesub_inplace-heiropenfhesubinplaceop">&lt;code>openfhe.sub_inplace&lt;/code> (heir::openfhe::SubInPlaceOp)&lt;/h3>
&lt;p>&lt;em>Performs in-place homomorphic subtraction, modifying lhs.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.sub_inplace` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;h4 id="operands-25">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhesub-heiropenfhesubop">&lt;code>openfhe.sub&lt;/code> (heir::openfhe::SubOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE sub operation of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.sub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>, &lt;code>SameOperandsAndResultRings&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-26">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-21">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="openfhesub_plain-heiropenfhesubplainop">&lt;code>openfhe.sub_plain&lt;/code> (heir::openfhe::SubPlainOp)&lt;/h3>
&lt;p>&lt;em>OpenFHE sub operation of a ciphertext and a plaintext.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `openfhe.sub_plain` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AllCiphertextTypesMatch&lt;/code>, &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-27">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cryptoContext&lt;/code>&lt;/td>
&lt;td>The CryptoContext required to perform homomorphic operations in OpenFHE.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>A ciphertext type or A plaintext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-22">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A ciphertext type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Polynomial</title><link>https://heir.dev/docs/dialects/polynomial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/polynomial/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="polynomial-dialect">&amp;lsquo;polynomial&amp;rsquo; Dialect&lt;/h1>
&lt;p>The Polynomial dialect defines single-variable polynomial types and
operations.&lt;/p>
&lt;p>The simplest use of &lt;code>polynomial&lt;/code> is to represent mathematical operations in
a polynomial ring &lt;code>R[x]&lt;/code>, where &lt;code>R&lt;/code> is another MLIR type like &lt;code>i32&lt;/code>.&lt;/p>
&lt;p>More generally, this dialect supports representing polynomial operations in a
quotient ring &lt;code>R[X]/(f(x))&lt;/code> for some statically fixed polynomial &lt;code>f(x)&lt;/code>.
Two polyomials &lt;code>p(x), q(x)&lt;/code> are considered equal in this ring if they have the
same remainder when dividing by &lt;code>f(x)&lt;/code>. When a modulus is given, ring operations
are performed with reductions modulo &lt;code>f(x)&lt;/code> and relative to the coefficient ring
&lt;code>R&lt;/code>.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// A constant polynomial in a ring with i32 coefficients and no polynomial modulus
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%a&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3x&lt;/span>&lt;span style="color:#000;font-weight:bold">**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// A constant polynomial in a ring with i32 coefficients, modulo (x^1024 + 1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">#modulus&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#modulus&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%a&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3x&lt;/span>&lt;span style="color:#000;font-weight:bold">**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// A constant polynomial in a ring with i32 coefficients, with a polynomial
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// modulus of (x^1024 + 1) and a coefficient modulus of 17.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">#modulus&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">coeff_ty =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>mod_arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>mod_arith&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">17&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>coeff_ty&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#modulus&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%a&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3x&lt;/span>&lt;span style="color:#000;font-weight:bold">**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="polynomial-attributes">Polynomial attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="chebyshevpolynomialattr">ChebyshevPolynomialAttr&lt;/h3>
&lt;p>&lt;em>An attribute containing a single-variable polynomial with float coefficients in the Chebyshev basis&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#polynomial.chebyshev_polynomial&amp;lt;
ArrayAttr # coefficients
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute represents a single-variable polynomial with double
precision floating point coefficients, represented in the basis of
Chebyshev polynomials of the first kind.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.chebyshev_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1.0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2.0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3.0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4.0&lt;/span>&lt;span style="color:#000;font-weight:bold">]&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">coefficients&lt;/td>
&lt;td style="text-align:center">&lt;code>ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="floatpolynomialattr">FloatPolynomialAttr&lt;/h3>
&lt;p>&lt;em>An attribute containing a single-variable polynomial with double precision floating point coefficients&lt;/em>&lt;/p>
&lt;p>A polynomial attribute represents a single-variable polynomial with double
precision floating point coefficients.&lt;/p>
&lt;p>The polynomial must be expressed as a list of monomial terms, with addition
or subtraction between them. The choice of variable name is arbitrary, but
must be consistent across all the monomials used to define a single
attribute. The order of monomial terms is arbitrary, each monomial degree
must occur at most once.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.float_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0.5&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1.5&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">polynomial&lt;/td>
&lt;td style="text-align:center">&lt;code>FloatPolynomial&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="intpolynomialattr">IntPolynomialAttr&lt;/h3>
&lt;p>&lt;em>An attribute containing a single-variable polynomial with integer coefficients&lt;/em>&lt;/p>
&lt;p>A polynomial attribute represents a single-variable polynomial with integer
coefficients, which is used to define the modulus of a &lt;code>RingAttr&lt;/code>, as well
as to define constants and perform constant folding for &lt;code>polynomial&lt;/code> ops.&lt;/p>
&lt;p>The polynomial must be expressed as a list of monomial terms, with addition
or subtraction between them. The choice of variable name is arbitrary, but
must be consistent across all the monomials used to define a single
attribute. The order of monomial terms is arbitrary, each monomial degree
must occur at most once.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="parameters-2">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">polynomial&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::IntPolynomial&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="primitiverootattr">PrimitiveRootAttr&lt;/h3>
&lt;p>&lt;em>An attribute containing an integer and its degree as a root of unity&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#polynomial.primitive_root&amp;lt;
::mlir::IntegerAttr, # value
::mlir::IntegerAttr # degree
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A primitive root attribute stores an integer root &lt;code>value&lt;/code> and an integer
&lt;code>degree&lt;/code>, corresponding to a primitive root of unity of the given degree in
an unspecified ring.&lt;/p>
&lt;p>This is used as an attribute on &lt;code>polynomial.ntt&lt;/code> and &lt;code>polynomial.intt&lt;/code> ops
to specify the root of unity used in lowering the transform.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.primitive_root&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">value=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">123&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> degree &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> &lt;span style="color:#204a87;font-weight:bold">index&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="parameters-3">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">value&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::IntegerAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">degree&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::IntegerAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ringattr">RingAttr&lt;/h3>
&lt;p>&lt;em>An attribute specifying a polynomial ring&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#polynomial.ring&amp;lt;
Type, # coefficientType
::mlir::heir::polynomial::IntPolynomialAttr # polynomialModulus
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A ring describes the domain in which polynomial arithmetic occurs. The ring
attribute in &lt;code>polynomial&lt;/code> represents the more specific case of polynomials
with a single indeterminate; whose coefficients can be represented by
another MLIR type (&lt;code>coefficientType&lt;/code>).&lt;/p>
&lt;p>All semantics pertaining to arithmetic in the ring must be owned by the
coefficient type. For example, if the polynomials are with integer
coefficients taken modulo a prime $p$, then &lt;code>coefficientType&lt;/code> must be a
type that represents integers modulo $p$, such as &lt;code>mod_arith&amp;lt;p&amp;gt;&lt;/code>.&lt;/p>
&lt;p>Additionally, a polynomial ring may specify a &lt;code>polynomialModulus&lt;/code>, which
converts polynomial arithmetic to the analogue of modular integer
arithmetic, where each polynomial is represented as its remainder when
dividing by the modulus. For single-variable polynomials, a polynomial
modulus is always specified via a single polynomial.&lt;/p>
&lt;p>An expressive example is polynomials with i32 coefficients, whose
coefficients are taken modulo &lt;code>2**32 - 5&lt;/code>, with a polynomial modulus of
&lt;code>x**1024 - 1&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly_mod&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">-1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#poly_mod&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">...&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this case, the value of a polynomial is always &amp;ldquo;converted&amp;rdquo; to a
canonical form by applying repeated reductions by setting &lt;code>x**1024 = 1&lt;/code>
and simplifying.&lt;/p>
&lt;h4 id="parameters-4">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">coefficientType&lt;/td>
&lt;td style="text-align:center">&lt;code>Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">polynomialModulus&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::IntPolynomialAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="typedchebyshevpolynomialattr">TypedChebyshevPolynomialAttr&lt;/h3>
&lt;p>&lt;em>A typed chebyshev_polynomial&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#polynomial.typed_chebyshev_polynomial&amp;lt;
::mlir::Type, # type
::mlir::heir::polynomial::ChebyshevPolynomialAttr # value
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">poly_ty =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">ring=&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">f32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> float&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1.4&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4.5&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>poly_ty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly_verbose&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.typed_chebyshev_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1.4&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4.5&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">6.0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">7.0&lt;/span>&lt;span style="color:#000;font-weight:bold">]&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>poly_ty
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="parameters-5">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">type&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">value&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::ChebyshevPolynomialAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="typedfloatpolynomialattr">TypedFloatPolynomialAttr&lt;/h3>
&lt;p>&lt;em>A typed float_polynomial&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#polynomial.typed_float_polynomial&amp;lt;
::mlir::Type, # type
::mlir::heir::polynomial::FloatPolynomialAttr # value
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">poly_ty =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">ring=&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">f32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> float&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1.4&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4.5&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>poly_ty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly_verbose&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.typed_float_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1.4&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4.5&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>poly_ty
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="parameters-6">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">type&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">value&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::FloatPolynomialAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="typedintpolynomialattr">TypedIntPolynomialAttr&lt;/h3>
&lt;p>&lt;em>A typed int_polynomial&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#polynomial.typed_int_polynomial&amp;lt;
::mlir::Type, # type
::mlir::heir::polynomial::IntPolynomialAttr # value
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">poly_ty =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">ring=&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1 x&lt;/span>&lt;span style="color:#000;font-weight:bold">**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>poly_ty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly_verbose&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.typed_int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1 x&lt;/span>&lt;span style="color:#000;font-weight:bold">**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>poly_ty
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="parameters-7">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">type&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">value&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::IntPolynomialAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="polynomial-types">Polynomial types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="polynomialtype">PolynomialType&lt;/h3>
&lt;p>&lt;em>An element of a polynomial ring.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!polynomial.polynomial&amp;lt;
::mlir::heir::polynomial::RingAttr # ring
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A type for polynomials in a polynomial quotient ring.&lt;/p>
&lt;h4 id="parameters-8">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::polynomial::RingAttr&lt;/code>&lt;/td>
&lt;td>an attribute specifying a polynomial ring&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="polynomial-ops">Polynomial ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="polynomialadd-heirpolynomialaddop">&lt;code>polynomial.add&lt;/code> (heir::polynomial::AddOp)&lt;/h3>
&lt;p>&lt;em>Addition operation between polynomials.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.add` operands attr-dict `:` type($result)
&lt;/code>&lt;/pre>&lt;p>Performs polynomial addition on the operands. The operands may be single
polynomials or containers of identically-typed polynomials, i.e., polynomials
from the same underlying ring with the same coefficient types.&lt;/p>
&lt;p>This op is defined to occur in the ring defined by the ring attribute of
the two operands, meaning the arithmetic is taken modulo the
polynomialModulus of the ring as well as modulo any semantics defined by
the coefficient type.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// add two polynomials modulo x^1024 - 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#poly&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">5&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#000;font-weight:bold">x&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%2&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>add &lt;span style="color:#000">%0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialconstant-heirpolynomialconstantop">&lt;code>polynomial.constant&lt;/code> (heir::polynomial::ConstantOp)&lt;/h3>
&lt;p>&lt;em>Define a constant polynomial via an attribute.&lt;/em>&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">int_poly_ty =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">ring=&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>int_poly_ty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">float_poly_ty =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">ring=&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">f32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> float&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0.5&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1.3e06&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>float_poly_ty
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>InferTypeOpAdaptor&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>value&lt;/code>&lt;/td>&lt;td>::mlir::Attribute&lt;/td>&lt;td>a typed float_polynomial or a typed int_polynomial or a typed chebyshev_polynomial&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An element of a polynomial ring.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialeval-heirpolynomialevalop">&lt;code>polynomial.eval&lt;/code> (heir::polynomial::EvalOp)&lt;/h3>
&lt;p>&lt;em>Evaluate a static polynomial attribute at a given SSA value.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.eval` $polynomial `,` $value attr-dict `:` type($value)
&lt;/code>&lt;/pre>&lt;p>Evaluates the result of a polynomial specified as a static attribute at
a given SSA value. The result represents the evaluation of the
polynomial at the input value and produces a corresponding scalar
value.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>&lt;span style="color:#f57900">poly_ty =&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">ring=&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.typed_int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>poly_ty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%x&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">5&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%result&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>eval &lt;span style="color:#000">#poly&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%x&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The coefficient type of the polynomial does not necessarily need to be
the same as the scalar input type. For example, one may evaluate a
square matrix in a polynomial, because the scalar-matrix operation is
well-defined. It is the responsibility of the lowering to determine
if the input is compatible with the polynomial coefficient type.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>polynomial&lt;/code>&lt;/td>&lt;td>::mlir::Attribute&lt;/td>&lt;td>a typed float_polynomial or a typed int_polynomial or a typed chebyshev_polynomial&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialfrom_tensor-heirpolynomialfromtensorop">&lt;code>polynomial.from_tensor&lt;/code> (heir::polynomial::FromTensorOp)&lt;/h3>
&lt;p>&lt;em>Creates a polynomial from integer coefficients stored in a tensor.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.from_tensor` $input attr-dict `:` type($input) `-&amp;gt;` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>polynomial.from_tensor&lt;/code> creates a polynomial value from a tensor of coefficients.
The input tensor must list the coefficients in degree-increasing order.&lt;/p>
&lt;p>The input one-dimensional tensor may have size at most the degree of the
ring&amp;rsquo;s polynomialModulus generator polynomial, with smaller dimension implying that
all higher-degree terms have coefficient zero.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#poly&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%two&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%five&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">5&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%coeffs&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>from_elements &lt;span style="color:#000">%two&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%two&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%five&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>from_tensor &lt;span style="color:#000">%coeffs&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>ranked tensor of any type values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An element of a polynomial ring.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialintt-heirpolynomialinttop">&lt;code>polynomial.intt&lt;/code> (heir::polynomial::INTTOp)&lt;/h3>
&lt;p>&lt;em>Computes the reverse integer Number Theoretic Transform (NTT).&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.intt` $input attr-dict `:` qualified(type($input)) `-&amp;gt;` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>polynomial.intt&lt;/code> computes the reverse integer Number Theoretic Transform
(INTT) on the input tensor. This is the inverse operation of the
&lt;code>polynomial.ntt&lt;/code> operation.&lt;/p>
&lt;p>The input tensor is interpreted as a point-value representation of the
output polynomial at powers of a primitive &lt;code>n&lt;/code>-th root of unity (see
&lt;code>polynomial.ntt&lt;/code>). The ring of the polynomial is taken from the required
encoding attribute of the tensor.&lt;/p>
&lt;p>The choice of primitive root may be optionally specified.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>root&lt;/code>&lt;/td>&lt;td>::mlir::heir::polynomial::PrimitiveRootAttr&lt;/td>&lt;td>an attribute containing an integer and its degree as a root of unity&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>ranked tensor of Integer type with modular arithmetic values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An element of a polynomial ring.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialleading_term-heirpolynomialleadingtermop">&lt;code>polynomial.leading_term&lt;/code> (heir::polynomial::LeadingTermOp)&lt;/h3>
&lt;p>&lt;em>Compute the leading term of the polynomial.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.leading_term` operands attr-dict `:` type($input) `-&amp;gt;` `(` type($degree) `,` type($coefficient) `)`
&lt;/code>&lt;/pre>&lt;p>The degree of a polynomial is the largest $k$ for which the coefficient
&lt;code>a_k&lt;/code> of &lt;code>x^k&lt;/code> is nonzero. The leading term is the term &lt;code>a_k * x^k&lt;/code>, which
this op represents as a pair of results. The first is the degree &lt;code>k&lt;/code> as an
index, and the second is the coefficient, whose type matches the
coefficient type of the polynomial&amp;rsquo;s ring attribute.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#poly&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%2&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>leading_term &lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">index&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>An element of a polynomial ring.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>degree&lt;/code>&lt;/td>
&lt;td>index&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>coefficient&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialmonic_monomial_mul-heirpolynomialmonicmonomialmulop">&lt;code>polynomial.monic_monomial_mul&lt;/code> (heir::polynomial::MonicMonomialMulOp)&lt;/h3>
&lt;p>&lt;em>Multiply a polynomial by a monic monomial.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.monic_monomial_mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Multiply a polynomial by a monic monomial, meaning a polynomial of the form
&lt;code>1 * x^k&lt;/code> for an index operand &lt;code>k&lt;/code>.&lt;/p>
&lt;p>In some special rings of polynomials, such as a ring of polynomials
modulo &lt;code>x^n - 1&lt;/code>, &lt;code>monomial_mul&lt;/code> can be interpreted as a cyclic shift of
the coefficients of the polynomial. For some rings, this results in
optimized lowerings that involve rotations and rescaling of the
coefficients of the input.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>monomialDegree&lt;/code>&lt;/td>
&lt;td>index&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialmonomial-heirpolynomialmonomialop">&lt;code>polynomial.monomial&lt;/code> (heir::polynomial::MonomialOp)&lt;/h3>
&lt;p>&lt;em>Create a polynomial that consists of a single monomial.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.monomial` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Construct a polynomial that consists of a single monomial term, from its
degree and coefficient as dynamic inputs.&lt;/p>
&lt;p>The coefficient type of the output polynomial&amp;rsquo;s ring attribute must match
the &lt;code>coefficient&lt;/code> input type.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#poly&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%deg&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1023&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">index&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%five&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">5&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>monomial &lt;span style="color:#000">%five&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%deg&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">index&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>coefficient&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>degree&lt;/code>&lt;/td>
&lt;td>index&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An element of a polynomial ring.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialmul-heirpolynomialmulop">&lt;code>polynomial.mul&lt;/code> (heir::polynomial::MulOp)&lt;/h3>
&lt;p>&lt;em>Multiplication operation between polynomials.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.mul` operands attr-dict `:` type($result)
&lt;/code>&lt;/pre>&lt;p>Performs polynomial multiplication on the operands. The operands may be single
polynomials or containers of identically-typed polynomials, i.e., polynomials
from the same underlying ring with the same coefficient types.&lt;/p>
&lt;p>This op is defined to occur in the ring defined by the ring attribute of
the two operands, meaning the arithmetic is taken modulo the
polynomialModulus of the ring as well as modulo any semantics defined by
the coefficient type.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// multiply two polynomials modulo x^1024 - 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#poly&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">5&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#000;font-weight:bold">x&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%2&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>mul &lt;span style="color:#000">%0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialmul_scalar-heirpolynomialmulscalarop">&lt;code>polynomial.mul_scalar&lt;/code> (heir::polynomial::MulScalarOp)&lt;/h3>
&lt;p>&lt;em>Multiplication by a scalar of the field.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.mul_scalar` operands attr-dict `:` type($polynomial) `,` type($scalar)
&lt;/code>&lt;/pre>&lt;p>Multiplies the polynomial operand&amp;rsquo;s coefficients by a given scalar value.
The &lt;code>scalar&lt;/code> input must have the same type as the polynomial ring&amp;rsquo;s
coefficientType.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// multiply two polynomials modulo x^1024 - 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#poly&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%2&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>mul_scalar &lt;span style="color:#000">%0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>polynomial&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>scalar&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialntt-heirpolynomialnttop">&lt;code>polynomial.ntt&lt;/code> (heir::polynomial::NTTOp)&lt;/h3>
&lt;p>&lt;em>Computes point-value tensor representation of a polynomial.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.ntt` $input attr-dict `:` qualified(type($input)) `-&amp;gt;` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>polynomial.ntt&lt;/code> computes the forward integer Number Theoretic Transform
(NTT) on the input polynomial. It returns a tensor containing a point-value
representation of the input polynomial. The output tensor has shape equal
to the degree of the ring&amp;rsquo;s &lt;code>polynomialModulus&lt;/code>. The polynomial&amp;rsquo;s RingAttr
is embedded as the encoding attribute of the output tensor.&lt;/p>
&lt;p>Given an input polynomial &lt;code>F(x)&lt;/code> over a ring whose &lt;code>polynomialModulus&lt;/code> has
degree &lt;code>n&lt;/code>, and a primitive &lt;code>n&lt;/code>-th root of unity &lt;code>omega_n&lt;/code>, the output is
the list of $n$ evaluations&lt;/p>
&lt;p>&lt;code>f[k] = F(omega[n]^k) ; k = {0, ..., n-1}&lt;/code>&lt;/p>
&lt;p>The choice of primitive root may be optionally specified.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>root&lt;/code>&lt;/td>&lt;td>::mlir::heir::polynomial::PrimitiveRootAttr&lt;/td>&lt;td>an attribute containing an integer and its degree as a root of unity&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>An element of a polynomial ring.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ranked tensor of Integer type with modular arithmetic values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialsub-heirpolynomialsubop">&lt;code>polynomial.sub&lt;/code> (heir::polynomial::SubOp)&lt;/h3>
&lt;p>&lt;em>Subtraction operation between polynomials.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.sub` operands attr-dict `:` type($result)
&lt;/code>&lt;/pre>&lt;p>Performs polynomial subtraction on the operands. The operands may be single
polynomials or containers of identically-typed polynomials, i.e., polynomials
from the same underlying ring with the same coefficient types.&lt;/p>
&lt;p>This op is defined to occur in the ring defined by the ring attribute of
the two operands, meaning the arithmetic is taken modulo the
polynomialModulus of the ring as well as modulo any semantics defined by
the coefficient type.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// subtract two polynomials modulo x^1024 - 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#poly&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#000;font-weight:bold">x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> int&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">5&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#000;font-weight:bold">x&lt;/span> &lt;span style="color:#a40000">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%2&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>sub &lt;span style="color:#000">%0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>SameOperandsAndResultType&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>polynomial-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="polynomialto_tensor-heirpolynomialtotensorop">&lt;code>polynomial.to_tensor&lt;/code> (heir::polynomial::ToTensorOp)&lt;/h3>
&lt;p>&lt;em>Creates a tensor containing the coefficients of a polynomial.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `polynomial.to_tensor` $input attr-dict `:` type($input) `-&amp;gt;` type($output)
&lt;/code>&lt;/pre>&lt;p>&lt;code>polynomial.to_tensor&lt;/code> creates a dense tensor value containing the
coefficients of the input polynomial. The output tensor contains the
coefficients in degree-increasing order.&lt;/p>
&lt;p>Operations that act on the coefficients of a polynomial, such as extracting
a specific coefficient or extracting a range of coefficients, should be
implemented by composing &lt;code>to_tensor&lt;/code> with the relevant &lt;code>tensor&lt;/code> dialect
ops.&lt;/p>
&lt;p>The output tensor has shape equal to the degree of the polynomial ring
attribute&amp;rsquo;s polynomialModulus, including zeroes.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.int_polynomial&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;x**&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024&lt;/span> &lt;span style="color:#a40000">-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#ring&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#polynomial.ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#f57900">coefficientType=&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#f57900">polynomialModulus=&lt;/span>&lt;span style="color:#000">#poly&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%two&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%five&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">5&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%coeffs&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>from_elements &lt;span style="color:#000">%two&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%two&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%five&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%poly&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>from_tensor &lt;span style="color:#000">%coeffs&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%tensor&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>to_tensor &lt;span style="color:#000">%poly&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">.&lt;/span>polynomial&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">#ring&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1024x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>An element of a polynomial ring.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ranked tensor of any type values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Random</title><link>https://heir.dev/docs/dialects/random/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/random/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="random-dialect">&amp;lsquo;random&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>random&lt;/code> dialect contains operations used to generate random numbers.&lt;/p>
&lt;h2 id="random-types">Random types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="distributiontype">DistributionType&lt;/h3>
&lt;p>&lt;em>A random distribution type&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!random.distribution&amp;lt;
::mlir::heir::random::Distribution # distribution_type
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A generic type, representing a specific random distribution type of either
uniform or gaussian as an attribute ($distribution_type).&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">distribution_type&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::random::Distribution&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="prngtype">PRNGType&lt;/h3>
&lt;p>&lt;em>A pseudorandom number generator type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!random.prng&lt;/code>&lt;/p>
&lt;p>A type that provides pseudorandom number generator.&lt;/p>
&lt;h2 id="random-ops">Random ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="randomdiscrete_gaussian_distribution-heirrandomdiscretegaussiandistributionop">&lt;code>random.discrete_gaussian_distribution&lt;/code> (heir::random::DiscreteGaussianDistributionOp)&lt;/h3>
&lt;p>&lt;em>Initializes the Discrete Gaussian Distribution&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `random.discrete_gaussian_distribution` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Initializes the Discrete Gaussian Distribution. The distribution is
initialized with a mean and a standard deviation and pseudorandom generator
that provides the source of the randomness.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>mean&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>stddev&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value whose value is non-negative&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A pseudorandom number generator type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A random distribution type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="randomdiscrete_uniform_distribution-heirrandomdiscreteuniformdistributionop">&lt;code>random.discrete_uniform_distribution&lt;/code> (heir::random::DiscreteUniformDistributionOp)&lt;/h3>
&lt;p>&lt;em>Initializes the Discrete Uniform Distribution&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `random.discrete_uniform_distribution` $input `{` `range` `=` `[` $min `,` $max `]` `}` attr-dict `:` `(` qualified(type($input)) `)` `-&amp;gt;` type($output)
&lt;/code>&lt;/pre>&lt;p>Initializes the Discrete Uniform Distribution. The distribution is
initialized with a minimum and a maximum value and pseudo random generator
that provides the source of the randomness. The distribution is inclusive of
the minimum and exclusive of the maximum.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>min&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>max&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A pseudorandom number generator type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A random distribution type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="randominit_prng-heirrandominitop">&lt;code>random.init_prng&lt;/code> (heir::random::InitOp)&lt;/h3>
&lt;p>&lt;em>Initializes the pseudorandom number generator with a seed.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `random.init_prng` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Initializes the PRNG with a seed. The seed is dynamically provided due to
protocols that agree on shared randomness. The PRNG is used to initialized
the random distributions such as the discrete gaussian distribution and the
discrete uniform distribution. This initialization also takes as input a
number of bits that are generated for each number value sampled (num_bits).
For instance, a num_bits of 32 will mean that distributions will generate a
32-bit integer value. We expect that the seed initialization is done statically
and globally once per thread for all distributions; however, if multiple threads are
generating randomness, then seed initialization should be done per thread;
otherwise there is no guarantee of consistent behavior. Thread safety is so
far not considered.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>num_bits&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>seed&lt;/code>&lt;/td>
&lt;td>signless-integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A pseudorandom number generator type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="randomsample-heirrandomsampleop">&lt;code>random.sample&lt;/code> (heir::random::SampleOp)&lt;/h3>
&lt;p>&lt;em>Samples from a distribution&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `random.sample` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Samples from the distribution to obtain a random value
or tensor of values.&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A random distribution type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>signless-integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="random-additional-definitions">Random additional definitions&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="distribution">Distribution&lt;/h3>
&lt;p>&lt;em>An enum attribute representing a random distribution&lt;/em>&lt;/p>
&lt;h4 id="cases">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">uniform&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>uniform&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">gaussian&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>gaussian&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: RNS</title><link>https://heir.dev/docs/dialects/rns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/rns/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="rns-dialect">&amp;lsquo;rns&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>rns&lt;/code> dialect represents types and ops related to residue number
system (RNS) representations of ring-like types, such as integers or
polynomials decomposed from high-bit width to lower-bit-width prime
moduli. Sometimes RNS is referred to as CRT, for &amp;ldquo;Chinese Remainder
Theorem.&amp;rdquo;&lt;/p>
&lt;p>This dialect is intended to be as generic as possible in terms of its
interaction with standard MLIR. However, because of upstream MLIR
constraints, we do not have the ability to override, say, &lt;code>arith.addi&lt;/code>
to operate on an &lt;code>rns&lt;/code> type. So such situations require dedicated ops,
canonicalization patterns, etc.&lt;/p>
&lt;h2 id="rns-types">RNS types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="rnstype">RNSType&lt;/h3>
&lt;p>&lt;em>A residue number system representation&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!rns.rns&amp;lt;
::llvm::ArrayRef&amp;lt;mlir::Type&amp;gt; # basisTypes
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">basisTypes&lt;/td>
&lt;td style="text-align:center">&lt;code>::llvm::ArrayRef&amp;lt;mlir::Type&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="rns-ops">RNS ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h2 id="rns-additional-definitions">RNS additional definitions&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="typeinterface-definitions">TypeInterface definitions&lt;/h1>
&lt;h2 id="rnsbasistypeinterface-rnsbasistypeinterface">RNSBasisTypeInterface (&lt;code>RNSBasisTypeInterface&lt;/code>)&lt;/h2>
&lt;p>This interface is required for a type to be used as a parameter
to an &lt;code>rns&lt;/code> type.&lt;/p>
&lt;h3 id="methods">Methods:&lt;/h3>
&lt;h4 id="iscompatiblewith">&lt;code>isCompatibleWith&lt;/code>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#000">isCompatibleWith&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">mlir&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">Type&lt;/span> &lt;span style="color:#000">otherRnsBasisType&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Returns true if this type is compatible with another type in the
same RNS basis. In particular, the set of types used for a single
RNS basis are never equal as types, but instead have some common
attribute that must be checked here. For example, an RNS type where
the basis types are polynomials would return true if the two types
are both polynomial types, even if they have different coefficient
moduli.&lt;/p>
&lt;p>Another example is using mod arith types as the basis types, where
by the nature of chinese reminder theorem, it is required that
the modulus of them must be mutually coprime.&lt;/p>
&lt;p>&lt;code>isCompatibleWith&lt;/code> must be commutative, in the sense
that &lt;code>type1.isCompatibleWith(type2)&lt;/code> if and only if
&lt;code>type2.isCompatibleWith(type1)&lt;/code>.&lt;/p>
&lt;p>NOTE: This method &lt;em>must&lt;/em> be implemented by the user.&lt;/p></description></item><item><title>Docs: Secret</title><link>https://heir.dev/docs/dialects/secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/secret/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="secret-dialect">&amp;lsquo;secret&amp;rsquo; Dialect&lt;/h1>
&lt;p>Secret is a dialect for computations that operate on encrypted data.&lt;/p>
&lt;p>Secret is intended to serve as a scheme-agnostic front-end for the HEIR
ecosystem of dialects. It is supposed to be fully interoperable with the
rest of MLIR via secret.generic, while lower-level HEIR dialects would have
custom types for arithmetic on secret integers of various bit widths.&lt;/p>
&lt;h2 id="secret-types">Secret types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="secrettype">SecretType&lt;/h3>
&lt;p>&lt;em>A secret value&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!secret.secret&amp;lt;
Type # valueType
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A generic wrapper around another MLIR type, representing an encrypted value
but not specifying the manner of encryption. This is useful in HEIR because
the compiler may choose various details of the FHE scheme based on the
properties of the input program, the backend target hardware, and cost
models of the various passes.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">valueType&lt;/td>
&lt;td style="text-align:center">&lt;code>Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="secret-ops">Secret ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="secretcast-heirsecretcastop">&lt;code>secret.cast&lt;/code> (heir::secret::CastOp)&lt;/h3>
&lt;p>&lt;em>A placeholder cast from one secret type to another&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `secret.cast` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>A &lt;code>cast&lt;/code> operation represents a type cast from one secret type to another,
that is used to enable the intermixing of various equivalent secret types
before a lower-level FHE scheme has been chosen.&lt;/p>
&lt;p>For example, &lt;code>secret.cast&lt;/code> can be used to convert a &lt;code>secret&amp;lt;i8&amp;gt;&lt;/code> to a
&lt;code>secret&amp;lt;tensor&amp;lt;8xi1&amp;gt;&amp;gt;&lt;/code> as a compatibility layer between boolean and
non-boolean parts of a program. The pass that later lowers the IR to
specific FHE schemes would need to replace these casts with appropriate
scheme-specific operations, and it is left to those later passes to
determine which casts are considered valid.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%result&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>cast &lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i8&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> to &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">8x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i1&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%result2&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>cast &lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i8&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> to &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i4&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A secret value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A secret value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretconceal-heirsecretconcealop">&lt;code>secret.conceal&lt;/code> (heir::secret::ConcealOp)&lt;/h3>
&lt;p>&lt;em>Convert a non-secret value into a secret&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `secret.conceal` $cleartext attr-dict `:` qualified(type($cleartext)) `-&amp;gt;` qualified(type($output))
&lt;/code>&lt;/pre>&lt;p>Convert a value to a secret containing the same value.&lt;/p>
&lt;p>This op represents a scheme-agnostic encryption operation, as well as a
&amp;ldquo;trivial encryption&amp;rdquo; operation which is needed for some FHE schemes. This
op is also useful for type materialization in the dialect conversion
framework.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Y&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>conceal &lt;span style="color:#000">%value&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cleartext&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>A secret value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretgeneric-heirsecretgenericop">&lt;code>secret.generic&lt;/code> (heir::secret::GenericOp)&lt;/h3>
&lt;p>&lt;em>Lift a plaintext computation to operate on secrets.&lt;/em>&lt;/p>
&lt;p>&lt;code>secret.generic&lt;/code> lifts a plaintext computation to operate on one or more
secrets. The lifted computation is represented as a region containing a
single block terminated by &lt;code>secret.yield&lt;/code>. The arguments of the &lt;code>secret.generic&lt;/code>
may include one or more &lt;code>!secret.secret&lt;/code> types. The arguments of the block
in the op&amp;rsquo;s body correspond to the underlying plaintext types of the secrets.&lt;/p>
&lt;p>&lt;code>secret.generic&lt;/code> is not isolated from above, so you may directly reference
values in the enclosing scope. This is required to support using
&lt;code>secret.generic&lt;/code> inside of ops with &lt;code>AffineScope&lt;/code>, while having the body
of the generic use the induction variables defined by the affine scope.&lt;/p>
&lt;p>Basic examples:&lt;/p>
&lt;p>Add two secret integers together&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>generic&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%X&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%Y&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">^bb0&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>addi &lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>yield &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Add a secret value with a plaintext value. I.e., not all arguments to the
op need be secret.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>generic&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%X&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%Y&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">^bb0&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>addi &lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>yield &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The same as above, but the plaintext op is not passed through the basic
block.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%y&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">7&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>generic&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%X&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">^bb0&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>addi &lt;span style="color:#000">%x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%y&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>yield &lt;span style="color:#000">%z&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>SingleBlockImplicitTerminator&amp;lt;YieldOp&amp;gt;&lt;/code>, &lt;code>SingleBlock&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>OpAsmOpInterface&lt;/code>, &lt;code>OperandAndResultAttrInterface&lt;/code>, &lt;code>RegionBranchOpInterface&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>results&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretreveal-heirsecretrevealop">&lt;code>secret.reveal&lt;/code> (heir::secret::RevealOp)&lt;/h3>
&lt;p>&lt;em>Convert a secret value into a non-secret&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `secret.reveal` $input attr-dict `:` qualified(type($input)) `-&amp;gt;` qualified(type($cleartext))
&lt;/code>&lt;/pre>&lt;p>Convert a secret into a non-secret containing the same value.&lt;/p>
&lt;p>This op represents a scheme-agnostic decryption operation. This op is also
useful for target materialization in the dialect conversion framework.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%Y&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>reveal &lt;span style="color:#000">%secret_value&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>A secret value&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cleartext&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretseparator-heirsecretseparatorop">&lt;code>secret.separator&lt;/code> (heir::secret::SeparatorOp)&lt;/h3>
&lt;p>&lt;em>Convert a non-secret value into a secret&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `secret.separator` attr-dict ($inputs^ `:` type($inputs))?
&lt;/code>&lt;/pre>&lt;p>This operation is used as a separation boundary between logical subunits of
the module. This is used in conjunction with
&lt;code>--secret-distribute-generic=distribute-through=secret.separator&lt;/code> to break a
generic around these separators and allow for optimization passses to
analyze and optimize the sub-units locally.&lt;/p>
&lt;p>In order to allow bufferization of modules with this operation, we must
register a (bogus) memory effect that also prevents this operation from
being trivially dead during operation folding.&lt;/p>
&lt;p>This operation also accepts operands, which act as boundaries between the
logical units. This enforces separation of memref and affine optimizations
between the subunits, preventing optimizations from removing the operand and
combining the two separated regions. The operand can be thought of as an
return value of the logical subunit.&lt;/p>
&lt;p>Interfaces: &lt;code>MemoryEffectOpInterface (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="secretyield-heirsecretyieldop">&lt;code>secret.yield&lt;/code> (heir::secret::YieldOp)&lt;/h3>
&lt;p>&lt;em>Secret yield operation&lt;/em>&lt;/p>
&lt;p>&lt;code>secret.yield&lt;/code> is a special terminator operation for blocks inside regions
in &lt;code>secret&lt;/code> generic ops. It returns the cleartext value of the
corresponding private computation to the immediately enclosing &lt;code>secret&lt;/code>
generic op.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>HasParent&amp;lt;GenericOp&amp;gt;&lt;/code>, &lt;code>ReturnLike&lt;/code>, &lt;code>Terminator&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>, &lt;code>RegionBranchTerminatorOpInterface&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>values&lt;/code>&lt;/td>
&lt;td>variadic of any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: TensorExt</title><link>https://heir.dev/docs/dialects/tensorext/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/tensorext/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="tensor_ext-dialect">&amp;rsquo;tensor_ext&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>tensor_ext&lt;/code> dialect contains operations on plaintext tensors that
correspond to the computation model of certain FHE schemes, but are
unlikely to be upstreamed to MLIR due to their specificity to FHE.&lt;/p>
&lt;h2 id="tensorext-attributes">TensorExt attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="alignmentattr">AlignmentAttr&lt;/h3>
&lt;p>&lt;em>An attribute describing padding and alignment of a tensor.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#tensor_ext.alignment&amp;lt;
::mlir::DenseI64ArrayAttr, # in
::mlir::DenseI64ArrayAttr, # out
::mlir::DenseI64ArrayAttr, # insertedDims
::mlir::DenseI64ArrayAttr, # padding
TypedAttr # paddingValue
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute is used to describe how a data-semantic value is padded
and replicated to align its size before applying a ciphertext layout
(see &lt;code>tensor_ext.layout&lt;/code>).&lt;/p>
&lt;p>It describes transformations to be applied to an input tensor or scalar.&lt;/p>
&lt;p>The &lt;code>in&lt;/code> attribute describes the shape of the original value. An empty list
for &lt;code>in&lt;/code> indicates a scalar value that must be materialized as a tensor.
The following transformations are applied to the input tensor.&lt;/p>
&lt;ol>
&lt;li>New unit dimensions are inserted to match the number of dimensions
of the output tensor. The &lt;code>insertedDims&lt;/code> attribute is an array
specifying which axes in the output tensor are new unit dimensions. By
default no new dimensions are inserted.&lt;/li>
&lt;li>Padding is applied. The &lt;code>padding&lt;/code> attribute is an array with the same
size as the output tensor shape, which each entry denoting the number of
values to pad at the end of that axis. The &lt;code>paddingValue&lt;/code> attribute
describes the value used for padding, and must be set if &lt;code>padding&lt;/code> is set.&lt;/li>
&lt;li>The padded result is replicated to fill the output tensor shape.&lt;/li>
&lt;/ol>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#repl&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#tensor_ext.alignment&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">in =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">7&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">padding =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">paddingValue =&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">out =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">16&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This indicates that the original input tensor is a &lt;code>tensor&amp;lt;7xi32&amp;gt;&lt;/code>, and it
is being padded and replicated into a &lt;code>tensor&amp;lt;16xi32&amp;gt;&lt;/code>. If the input tensor
has values &lt;code>[1, 2, 3, 4, 5, 6, 7]&lt;/code> then the packed tensor contains the data
&lt;code>[1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0]&lt;/code>.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#repl&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#tensor_ext.alignment&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">in =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">padding =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">6&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">paddingValue =&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">out =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">32&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This indicates that the original input tensor is a &lt;code>tensor&amp;lt;3x10xi32&amp;gt;&lt;/code>, and
it is being padded and replicated into a &lt;code>tensor&amp;lt;32x32xi32&amp;gt;&lt;/code>. One row of
zeros and six columns of zeros are added to the input tensor, and then it
is repeated once along the column dimension and four times along the row
dimension to fill the 32x32 output tensor.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#repl&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#tensor_ext.alignment&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">in =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">insertedDims =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">padding =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">6&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">paddingValue =&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">out =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">32&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This indicates that the original input tensor is a &lt;code>tensor&amp;lt;10xi32&amp;gt;&lt;/code>, and it
is being padded and replicated into a &lt;code>tensor&amp;lt;32x32xi32&amp;gt;&lt;/code>. First a unit
dimension is inserted as the first axis, then zeros are padded along the
second axis to make a &lt;code>tensor&amp;lt;1x16xi32&amp;gt;&lt;/code>. Finally, it is replicated twice
along the columns and 32 times along the rows to fill the 32x32 output
tensor.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">#repl&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">#tensor_ext.alignment&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">in =&lt;/span> &lt;span style="color:#000;font-weight:bold">[],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">insertedDims =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">out =&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This indicates that the original input is a scalar such as &lt;code>i32&lt;/code>, and it is
elevated to a &lt;code>tensor&amp;lt;1xi32&amp;gt;&lt;/code> before being replicated to fill the
ciphertext shape.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">in&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">out&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">insertedDims&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">padding&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::DenseI64ArrayAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">paddingValue&lt;/td>
&lt;td style="text-align:center">&lt;code>TypedAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="layoutattr">LayoutAttr&lt;/h3>
&lt;p>&lt;em>The description of the layout of a data-semantic tensor.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#tensor_ext.layout&amp;lt;
::mlir::AffineMap, # map
::mlir::heir::tensor_ext::AlignmentAttr # alignment
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute describes how a data-semantic tensor is laid out
among a tensor of ciphertexts. The layout is described by an affine map
mapping the data-semantic tensor indices to the ciphertext tensor indices,
where the trailing affine map&amp;rsquo;s result expressions mark the slot index
(or indices) of the ciphertext.&lt;/p>
&lt;p>The layout may include optional padding and alignment of the data-semantic
tensor before the layout is applied. This would be required if, for
example, a &lt;code>tensor&amp;lt;4xi32&amp;gt;&lt;/code> is to be laid out in a &lt;code>tensor&amp;lt;16xi32&amp;gt;&lt;/code>
ciphertext tensor. The data-semantic tensor must be extended somehow to
fill the 16 slots. If an alignment attribute is not provided, then
lowerings may raise errors if there is no unambiguous way to align the
tensor.&lt;/p>
&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">map&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::AffineMap&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">alignment&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::tensor_ext::AlignmentAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="originaltypeattr">OriginalTypeAttr&lt;/h3>
&lt;p>&lt;em>The original type of a secret tensor whose layout has been converted to ciphertext semantics.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#tensor_ext.original_type&amp;lt;
::mlir::Type, # originalType
::mlir::heir::tensor_ext::LayoutAttr # layout
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attribute is used to retain the original type of a secret tensor after
its conversion to ciphertext semantics, i.e. after applying any padding or
alignment to fill ciphertext data types. For example, if a
&lt;code>!secret.secret&amp;lt;tensor&amp;lt;32xi8&amp;gt;&amp;gt;&lt;/code> is laid out in a ciphertext with
1024 slots, the new type would be &lt;code>!secret.secret&amp;lt;tensor&amp;lt;1024xi8&amp;gt;&amp;gt;&lt;/code>
with attribute &lt;code>tensor_ext.original_type&amp;lt;!secret.secret&amp;lt;tensor&amp;lt;32xi8&amp;gt;&amp;gt;&lt;/code>.&lt;/p>
&lt;h4 id="parameters-2">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">originalType&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">layout&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::tensor_ext::LayoutAttr&lt;/code>&lt;/td>
&lt;td>The description of the layout of a data-semantic tensor.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="tensorext-ops">TensorExt ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="tensor_extassign_layout-heirtensor_extassignlayoutop">&lt;code>tensor_ext.assign_layout&lt;/code> (heir::tensor_ext::AssignLayoutOp)&lt;/h3>
&lt;p>&lt;em>Assign a layout to a plaintext tensor or scalar.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tensor_ext.assign_layout` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>This op allows the ingestion of a plaintext value into the layout system.
For example, ops like &lt;code>linalg.reduce&lt;/code>, require a tensor input to represent
initial values. These will generally be created by an &lt;code>arith.constant&lt;/code> or
&lt;code>tensor.empty&lt;/code> op, which does not have secret results. Lowerings will
convert this to a packed plaintext, so that the subsequent ops can be
lowered as ciphertext-plaintext ops.&lt;/p>
&lt;p>This op is inserted by layout selection passes.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>layout&lt;/code>&lt;/td>&lt;td>::mlir::heir::tensor_ext::LayoutAttr&lt;/td>&lt;td>The description of the layout of a data-semantic tensor.&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tensor_extconvert_layout-heirtensor_extconvertlayoutop">&lt;code>tensor_ext.convert_layout&lt;/code> (heir::tensor_ext::ConvertLayoutOp)&lt;/h3>
&lt;p>&lt;em>Convert from one layout to another.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tensor_ext.convert_layout` operands attr-dict `:` type($output)
&lt;/code>&lt;/pre>&lt;p>This op represents the conversion of a value from one packed layout to
another. This is implemented via a &amp;ldquo;shift network&amp;rdquo; of ciphertext rotations,
plaintext masks (ciphertext-plaintext multiplications), and additions.&lt;/p>
&lt;p>This op is inserted by layout selection passes.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>from_layout&lt;/code>&lt;/td>&lt;td>::mlir::heir::tensor_ext::LayoutAttr&lt;/td>&lt;td>The description of the layout of a data-semantic tensor.&lt;/td>&lt;/tr>
&lt;tr>&lt;td>&lt;code>to_layout&lt;/code>&lt;/td>&lt;td>::mlir::heir::tensor_ext::LayoutAttr&lt;/td>&lt;td>The description of the layout of a data-semantic tensor.&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tensor_extpermute-heirtensor_extpermuteop">&lt;code>tensor_ext.permute&lt;/code> (heir::tensor_ext::PermuteOp)&lt;/h3>
&lt;p>&lt;em>Permute a tensor by a static permutation.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tensor_ext.permute` operands attr-dict `:` type($input)
&lt;/code>&lt;/pre>&lt;p>This op represents a permutation of a tensor.&lt;/p>
&lt;p>This is lowered from a &lt;code>convert_layout&lt;/code> op, and is implemented in terms of
&lt;code>rotate&lt;/code> operations.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>permutation&lt;/code>&lt;/td>&lt;td>::mlir::Attribute&lt;/td>&lt;td>An Attribute containing an AffineMap object or 64-bit integer elements attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>ranked tensor of any type values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ranked tensor of any type values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tensor_extrotate-heirtensor_extrotateop">&lt;code>tensor_ext.rotate&lt;/code> (heir::tensor_ext::RotateOp)&lt;/h3>
&lt;p>&lt;em>Rotate a tensor some number of indices left.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tensor_ext.rotate` operands attr-dict `:` qualified(type($tensor)) `,` type($shift)
&lt;/code>&lt;/pre>&lt;p>This op represents a left-rotation of a tensor by given number of indices.
Negative shift values are interpreted as right-rotations.&lt;/p>
&lt;p>This corresponds to the &lt;code>rotate&lt;/code> operation in arithmetic FHE schemes like
BGV.&lt;/p>
&lt;p>This operation&amp;rsquo;s current behavior allows rotating multi-dimensional tensors
by rotating along the tensor&amp;rsquo;s only non-unit dimension. This assumes the
tensor is packed along the non-unit dimension.&lt;/p>
&lt;p>// In the future, the op will be adjusted to support rotations of general
// multi-dimensional tensors with a vector of rotation indices for each
// dimension. The lowering will implement the correct operations to rotate
// the tensor along the indices given its packing.&lt;/p>
&lt;p>Examples:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">...&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">16x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%c7&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">7&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>_ext&lt;span style="color:#000;font-weight:bold">.&lt;/span>rotate &lt;span style="color:#000">%0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%c7&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">16x&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>tensor&lt;/code>&lt;/td>
&lt;td>ranked tensor of any type values&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>shift&lt;/code>&lt;/td>
&lt;td>signless-integer-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>ranked tensor of any type values&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tensor_extunpack-heirtensor_extunpackop">&lt;code>tensor_ext.unpack&lt;/code> (heir::tensor_ext::UnpackOp)&lt;/h3>
&lt;p>&lt;em>Unpack data from a ciphertext-semantic tensor.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tensor_ext.unpack` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>This op extracts the underlying cleartext data from a ciphertext-semantic
tensor.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>layout&lt;/code>&lt;/td>&lt;td>::mlir::heir::tensor_ext::LayoutAttr&lt;/td>&lt;td>The description of the layout of a data-semantic tensor.&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: TfheRust</title><link>https://heir.dev/docs/dialects/tfherust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/tfherust/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="tfhe_rust-dialect">&amp;rsquo;tfhe_rust&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>thfe_rust&lt;/code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the shortint parameters and encoding scheme.&lt;/p>
&lt;p>See &lt;a href="https://github.com/zama-ai/tfhe-rs">https://github.com/zama-ai/tfhe-rs&lt;/a>&lt;/p>
&lt;h2 id="tfherust-types">TfheRust types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="encryptedbooltype">EncryptedBoolType&lt;/h3>
&lt;p>&lt;em>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.
Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.bool&lt;/code>&lt;/p>
&lt;h3 id="encryptedint2type">EncryptedInt2Type&lt;/h3>
&lt;p>&lt;em>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt2 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei2&lt;/code>&lt;/p>
&lt;h3 id="encryptedint4type">EncryptedInt4Type&lt;/h3>
&lt;p>&lt;em>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt4 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei4&lt;/code>&lt;/p>
&lt;h3 id="encryptedint8type">EncryptedInt8Type&lt;/h3>
&lt;p>&lt;em>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei8&lt;/code>&lt;/p>
&lt;h3 id="encryptedint16type">EncryptedInt16Type&lt;/h3>
&lt;p>&lt;em>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei16&lt;/code>&lt;/p>
&lt;h3 id="encryptedint32type">EncryptedInt32Type&lt;/h3>
&lt;p>&lt;em>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei32&lt;/code>&lt;/p>
&lt;h3 id="encryptedint64type">EncryptedInt64Type&lt;/h3>
&lt;p>&lt;em>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei64&lt;/code>&lt;/p>
&lt;h3 id="encryptedint128type">EncryptedInt128Type&lt;/h3>
&lt;p>&lt;em>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei128&lt;/code>&lt;/p>
&lt;h3 id="encryptedint256type">EncryptedInt256Type&lt;/h3>
&lt;p>&lt;em>An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.ei256&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint2type">EncryptedUInt2Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui2&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint3type">EncryptedUInt3Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui3&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint4type">EncryptedUInt4Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui4&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint8type">EncryptedUInt8Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui8&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint10type">EncryptedUInt10Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui10&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint12type">EncryptedUInt12Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui12&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint14type">EncryptedUInt14Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui14&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint16type">EncryptedUInt16Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui16&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint32type">EncryptedUInt32Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui32&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint64type">EncryptedUInt64Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui64&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint128type">EncryptedUInt128Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui128&lt;/code>&lt;/p>
&lt;h3 id="encrypteduint256type">EncryptedUInt256Type&lt;/h3>
&lt;p>&lt;em>An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.eui256&lt;/code>&lt;/p>
&lt;h3 id="lookuptabletype">LookupTableType&lt;/h3>
&lt;p>&lt;em>A univariate lookup table used for programmable bootstrapping.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.lookup_table&lt;/code>&lt;/p>
&lt;h3 id="serverkeytype">ServerKeyType&lt;/h3>
&lt;p>&lt;em>The short int server key required to perform homomorphic operations.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust.server_key&lt;/code>&lt;/p>
&lt;h2 id="tfherust-ops">TfheRust ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="tfhe_rustadd-heirtfhe_rustaddop">&lt;code>tfhe_rust.add&lt;/code> (heir::tfhe_rust::AddOp)&lt;/h3>
&lt;p>&lt;em>Arithmetic add of two tfhe ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.add` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustapply_lookup_table-heirtfhe_rustapplylookuptableop">&lt;code>tfhe_rust.apply_lookup_table&lt;/code> (heir::tfhe_rust::ApplyLookupTableOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.apply_lookup_table` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lookupTable&lt;/code>&lt;/td>
&lt;td>A univariate lookup table used for programmable bootstrapping.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustbitand-heirtfhe_rustbitandop">&lt;code>tfhe_rust.bitand&lt;/code> (heir::tfhe_rust::BitAndOp)&lt;/h3>
&lt;p>&lt;em>Logical AND of two tfhe ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.bitand` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustbitor-heirtfhe_rustbitorop">&lt;code>tfhe_rust.bitor&lt;/code> (heir::tfhe_rust::BitOrOp)&lt;/h3>
&lt;p>&lt;em>Logical OR of two tfhe ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.bitor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustbitxor-heirtfhe_rustbitxorop">&lt;code>tfhe_rust.bitxor&lt;/code> (heir::tfhe_rust::BitXorOp)&lt;/h3>
&lt;p>&lt;em>Logical XOR of two tfhe ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.bitxor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustcast-heirtfhe_rustcastop">&lt;code>tfhe_rust.cast&lt;/code> (heir::tfhe_rust::CastOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.cast` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustcmp-heirtfhe_rustcmpop">&lt;code>tfhe_rust.cmp&lt;/code> (heir::tfhe_rust::CmpOp)&lt;/h3>
&lt;p>_High level operation to check the relation of two ciphertexts.&lt;/p>
&lt;ul>
&lt;li>equal (mnemonic: &amp;ldquo;eq&amp;rdquo;; integer value: 0)&lt;/li>
&lt;li>not equal (mnemonic: &amp;ldquo;ne&amp;rdquo;; integer value: 1)&lt;/li>
&lt;li>signed less than (mnemonic: &amp;ldquo;slt&amp;rdquo;; integer value: 2)&lt;/li>
&lt;li>signed less than or equal (mnemonic: &amp;ldquo;sle&amp;rdquo;; integer value: 3)&lt;/li>
&lt;li>signed greater than (mnemonic: &amp;ldquo;sgt&amp;rdquo;; integer value: 4)&lt;/li>
&lt;li>signed greater than or equal (mnemonic: &amp;ldquo;sge&amp;rdquo;; integer value: 5)&lt;/li>
&lt;li>unsigned less than (mnemonic: &amp;ldquo;ult&amp;rdquo;; integer value: 6)&lt;/li>
&lt;li>unsigned less than or equal (mnemonic: &amp;ldquo;ule&amp;rdquo;; integer value: 7)&lt;/li>
&lt;li>unsigned greater than (mnemonic: &amp;ldquo;ugt&amp;rdquo;; integer value: 8)&lt;/li>
&lt;li>unsigned greater than or equal (mnemonic: &amp;ldquo;uge&amp;rdquo;; integer value: 9)&lt;/li>
&lt;/ul>
&lt;p>Note: &lt;a href="https://mlir.llvm.org/docs/Dialects/ArithOps/#arithcmpi-arithcmpiop">https://mlir.llvm.org/docs/Dialects/ArithOps/#arithcmpi-arithcmpiop&lt;/a>_&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.cmp` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>predicate&lt;/code>&lt;/td>&lt;td>::mlir::arith::CmpIPredicateAttr&lt;/td>&lt;td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp.&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustcreate_trivial-heirtfhe_rustcreatetrivialop">&lt;code>tfhe_rust.create_trivial&lt;/code> (heir::tfhe_rust::CreateTrivialOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.create_trivial` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rusteq-heirtfhe_rusteqop">&lt;code>tfhe_rust.eq&lt;/code> (heir::tfhe_rust::EqOp)&lt;/h3>
&lt;p>&lt;em>High level operation to check equality of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.eq` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustgenerate_lookup_table-heirtfhe_rustgeneratelookuptableop">&lt;code>tfhe_rust.generate_lookup_table&lt;/code> (heir::tfhe_rust::GenerateLookupTableOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.generate_lookup_table` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>truthTable&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>An Attribute containing a integer value&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lookupTable&lt;/code>&lt;/td>
&lt;td>A univariate lookup table used for programmable bootstrapping.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustmax-heirtfhe_rustmaxop">&lt;code>tfhe_rust.max&lt;/code> (heir::tfhe_rust::MaxOp)&lt;/h3>
&lt;p>&lt;em>High level operation to return maximum of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.max` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustmin-heirtfhe_rustminop">&lt;code>tfhe_rust.min&lt;/code> (heir::tfhe_rust::MinOp)&lt;/h3>
&lt;p>&lt;em>High level operation to return minimum of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.min` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustmul-heirtfhe_rustmulop">&lt;code>tfhe_rust.mul&lt;/code> (heir::tfhe_rust::MulOp)&lt;/h3>
&lt;p>&lt;em>Arithmetic mul of two tfhe ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.mul` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-12">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-12">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustneq-heirtfhe_rustneqop">&lt;code>tfhe_rust.neq&lt;/code> (heir::tfhe_rust::NeqOp)&lt;/h3>
&lt;p>&lt;em>High level operation to check inequality of two ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.neq` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-13">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-13">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustscalar_left_shift-heirtfhe_rustscalarleftshiftop">&lt;code>tfhe_rust.scalar_left_shift&lt;/code> (heir::tfhe_rust::ScalarLeftShiftOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.scalar_left_shift` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>shiftAmount&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>index attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-14">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-14">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustscalar_right_shift-heirtfhe_rustscalarrightshiftop">&lt;code>tfhe_rust.scalar_right_shift&lt;/code> (heir::tfhe_rust::ScalarRightShiftOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.scalar_right_shift` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>shiftAmount&lt;/code>&lt;/td>&lt;td>::mlir::IntegerAttr&lt;/td>&lt;td>index attribute&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-15">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>ciphertext&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-15">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustcmux-heirtfhe_rustselectop">&lt;code>tfhe_rust.cmux&lt;/code> (heir::tfhe_rust::SelectOp)&lt;/h3>
&lt;p>&lt;em>Multiplexer operations, the &lt;code>select&lt;/code> ciphertext will return the &lt;code>trueCtxt&lt;/code>
if in contains a 1. In the other case, it will will return the &lt;code>falseCtxt&lt;/code>.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.cmux` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-16">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>select&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp.&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>trueCtxt&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>falseCtxt&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-16">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rustsub-heirtfhe_rustsubop">&lt;code>tfhe_rust.sub&lt;/code> (heir::tfhe_rust::SubOp)&lt;/h3>
&lt;p>&lt;em>Arithmetic sub of two tfhe ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust.sub` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-17">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The short int server key required to perform homomorphic operations.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>tfhe-ciphertext-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>Integer type with arbitrary precision up to a fixed limit or An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-17">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted bool corresponding to tfhe-rs&amp;rsquo;s FHEBool, not in the Boolean TFHE-rs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Note this is not an encryption of a boolean, but the outcome of operations as Eq or Cmp. or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint2 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint3 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint4 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint8 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint10 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint12 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint14 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint16 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint32 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint64 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint128 type or An encrypted unsigned integer corresponding to tfhe-rs&amp;rsquo;s FHEUint256 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt8 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt16 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt32 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt64 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt128 type or An encrypted signed integer corresponding to tfhe-rs&amp;rsquo;s FHEInt256 type&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: TfheRustBool</title><link>https://heir.dev/docs/dialects/tfherustbool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/dialects/tfherustbool/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h1 id="tfhe_rust_bool-dialect">&amp;rsquo;tfhe_rust_bool&amp;rsquo; Dialect&lt;/h1>
&lt;p>The &lt;code>tfhe_rust_bool&lt;/code> dialect is an exit dialect for generating rust code against the tfhe-rs library API,
using the boolean parameter set.&lt;/p>
&lt;p>See &lt;a href="https://github.com/zama-ai/tfhe-rs">https://github.com/zama-ai/tfhe-rs&lt;/a>&lt;/p>
&lt;h2 id="tfherustbool-attributes">TfheRustBool attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="tfherustboolgatesattr">TfheRustBoolGatesAttr&lt;/h3>
&lt;p>&lt;em>An Attribute containing an array of strings to store bool gates&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#tfhe_rust_bool.tfhe_rust_bool_gates&amp;lt;
::llvm::ArrayRef&amp;lt;::mlir::heir::tfhe_rust_bool::TfheRustBoolGateEnumAttr&amp;gt; # gates
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>This attributes stores a list of integer identifiers for Boolean gates.&lt;/p>
&lt;p>Uses following mapping:
AND_GATE = 0;
NAND_GATE = 1;
OR_GATE = 2;
NOR_GATE = 3;
XOR_GATE = 4;
XNOR_GATE = 5;
NOT_GATE = 6;&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">gates&lt;/td>
&lt;td style="text-align:center">&lt;code>::llvm::ArrayRef&amp;lt;::mlir::heir::tfhe_rust_bool::TfheRustBoolGateEnumAttr&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="tfherustbool-types">TfheRustBool types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="encryptedbooltype">EncryptedBoolType&lt;/h3>
&lt;p>&lt;em>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.eb&lt;/code>&lt;/p>
&lt;h3 id="packedserverkeytype">PackedServerKeyType&lt;/h3>
&lt;p>&lt;em>The Belfort packed API boolean server key.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.server_key_enum&lt;/code>&lt;/p>
&lt;h3 id="serverkeytype">ServerKeyType&lt;/h3>
&lt;p>&lt;em>The boolean server key required to perform homomorphic operations.&lt;/em>&lt;/p>
&lt;p>Syntax: &lt;code>!tfhe_rust_bool.server_key&lt;/code>&lt;/p>
&lt;h2 id="tfherustbool-ops">TfheRustBool ops&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="tfhe_rust_boolcreate_trivial-heirtfhe_rust_boolcreatetrivialop">&lt;code>tfhe_rust_bool.create_trivial&lt;/code> (heir::tfhe_rust_bool::CreateTrivialOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.create_trivial` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>tfhe rust bool server key&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>value&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_booland-heirtfhe_rust_boolandop">&lt;code>tfhe_rust_bool.and&lt;/code> (heir::tfhe_rust_bool::AndOp)&lt;/h3>
&lt;p>&lt;em>Logical AND of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.and` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolmux-heirtfhe_rust_boolmuxop">&lt;code>tfhe_rust_bool.mux&lt;/code> (heir::tfhe_rust_bool::MuxOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.mux` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cnd&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>An encrypted Boolean corresponding to tfhe-rs&amp;rsquo;s FHEBool type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolnand-heirtfhe_rust_boolnandop">&lt;code>tfhe_rust_bool.nand&lt;/code> (heir::tfhe_rust_bool::NandOp)&lt;/h3>
&lt;p>&lt;em>Logical NAND of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.nand` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolnor-heirtfhe_rust_boolnorop">&lt;code>tfhe_rust_bool.nor&lt;/code> (heir::tfhe_rust_bool::NorOp)&lt;/h3>
&lt;p>&lt;em>Logical NOR of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.nor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolnot-heirtfhe_rust_boolnotop">&lt;code>tfhe_rust_bool.not&lt;/code> (heir::tfhe_rust_bool::NotOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.not` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolor-heirtfhe_rust_boolorop">&lt;code>tfhe_rust_bool.or&lt;/code> (heir::tfhe_rust_bool::OrOp)&lt;/h3>
&lt;p>&lt;em>Logical OR of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.or` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolgates_packed-heirtfhe_rust_boolpackedop">&lt;code>tfhe_rust_bool.gates_packed&lt;/code> (heir::tfhe_rust_bool::PackedOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.gates_packed` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Operation to where different Boolean gates are executed pairwise between elements of two ciphertext arrays.&lt;/p>
&lt;p>For example,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> tfhe_rust_bool&lt;span style="color:#000;font-weight:bold">.&lt;/span>packed_gates &lt;span style="color:#000">%a&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%b&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f57900">gates =&lt;/span> &lt;span style="color:#000">#tfhe_rust_bool.tfhe_rust_bool_gates&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">4&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;}&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">(!&lt;/span>tfhe_rust_bool&lt;span style="color:#000;font-weight:bold">.&lt;/span>server_key&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2x&lt;/span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>tfhe_rust_bool&lt;span style="color:#000;font-weight:bold">.&lt;/span>eb&lt;span style="color:#000;font-weight:bold">&amp;gt;,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2x&lt;/span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>tfhe_rust_bool&lt;span style="color:#000;font-weight:bold">.&lt;/span>eb&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">tensor&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2x&lt;/span>&lt;span style="color:#000;font-weight:bold">!&lt;/span>tfhe_rust_bool&lt;span style="color:#000;font-weight:bold">.&lt;/span>eb&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>applies an &amp;ldquo;and&amp;rdquo; gate to the first elements of %a and %b and an xor gate to the
second elements.&lt;/p>
&lt;p>Mapping is defined in the BooleanGates.td file.&lt;/p>
&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;tr>&lt;th>Attribute&lt;/th>&lt;th>MLIR Type&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
&lt;tr>&lt;td>&lt;code>gates&lt;/code>&lt;/td>&lt;td>::mlir::heir::tfhe_rust_bool::TfheRustBoolGatesAttr&lt;/td>&lt;td>An Attribute containing an array of strings to store bool gates&lt;/td>&lt;/tr>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolxnor-heirtfhe_rust_boolxnorop">&lt;code>tfhe_rust_bool.xnor&lt;/code> (heir::tfhe_rust_bool::XnorOp)&lt;/h3>
&lt;p>&lt;em>Logical XNOR of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.xnor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tfhe_rust_boolxor-heirtfhe_rust_boolxorop">&lt;code>tfhe_rust_bool.xor&lt;/code> (heir::tfhe_rust_bool::XorOp)&lt;/h3>
&lt;p>&lt;em>Logical XOR of two TFHE-rs Bool ciphertexts.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `tfhe_rust_bool.xor` operands attr-dict `:` functional-type(operands, results)
&lt;/code>&lt;/pre>&lt;p>Traits: &lt;code>AlwaysSpeculatableImplTrait&lt;/code>, &lt;code>Commutative&lt;/code>, &lt;code>Elementwise&lt;/code>, &lt;code>Scalarizable&lt;/code>, &lt;code>Tensorizable&lt;/code>, &lt;code>Vectorizable&lt;/code>&lt;/p>
&lt;p>Interfaces: &lt;code>ConditionallySpeculatable&lt;/code>, &lt;code>InferTypeOpInterface&lt;/code>, &lt;code>NoMemoryEffect (MemoryEffectOpInterface)&lt;/code>&lt;/p>
&lt;p>Effects: &lt;code>MemoryEffects::Effect{}&lt;/code>&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>serverKey&lt;/code>&lt;/td>
&lt;td>The boolean server key required to perform homomorphic operations. or The Belfort packed API boolean server key.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>output&lt;/code>&lt;/td>
&lt;td>eb-like&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="tfherustbool-additional-definitions">TfheRustBool additional definitions&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="tfherustboolgateenum">TfheRustBoolGateEnum&lt;/h3>
&lt;p>&lt;em>An enum attribute representing a TFHE-rs boolean gate using u8 int&lt;/em>&lt;/p>
&lt;h4 id="cases">Cases:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Symbol&lt;/th>
&lt;th style="text-align:center">Value&lt;/th>
&lt;th>String&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">AND&lt;/td>
&lt;td style="text-align:center">&lt;code>0&lt;/code>&lt;/td>
&lt;td>AND&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">NAND&lt;/td>
&lt;td style="text-align:center">&lt;code>1&lt;/code>&lt;/td>
&lt;td>NAND&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">OR&lt;/td>
&lt;td style="text-align:center">&lt;code>2&lt;/code>&lt;/td>
&lt;td>OR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">NOR&lt;/td>
&lt;td style="text-align:center">&lt;code>3&lt;/code>&lt;/td>
&lt;td>NOR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">XOR&lt;/td>
&lt;td style="text-align:center">&lt;code>4&lt;/code>&lt;/td>
&lt;td>XOR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">XNOR&lt;/td>
&lt;td style="text-align:center">&lt;code>5&lt;/code>&lt;/td>
&lt;td>XNOR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">NOT&lt;/td>
&lt;td style="text-align:center">&lt;code>6&lt;/code>&lt;/td>
&lt;td>NOT&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>