<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.113.0"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>LWE | HEIR</title><meta name=description content="LWE attributes PlaintextEncodingAttr Syntax: #lwe.plaintext_encoding
ApplicationDataAttr Syntax:
#lwe.application_data&amp;lt; mlir::Type, # message_type Attribute # overflow &amp;gt; An attribute describing the semantics of the underlying application data.
The messageType parameter is used to describe the type and bits of the original application data, e.g. i1, i32, f32. This type is later mapped into the plaintext space of an FHE scheme by embedding, scaling, or other techniques.
This attribute also contains information about the overflow semantics of the data in the application."><meta property="og:title" content="LWE"><meta property="og:description" content="LWE attributes PlaintextEncodingAttr Syntax: #lwe.plaintext_encoding
ApplicationDataAttr Syntax:
#lwe.application_data< mlir::Type, # message_type Attribute # overflow > An attribute describing the semantics of the underlying application data.
The messageType parameter is used to describe the type and bits of the original application data, e.g. i1, i32, f32. This type is later mapped into the plaintext space of an FHE scheme by embedding, scaling, or other techniques.
This attribute also contains information about the overflow semantics of the data in the application."><meta property="og:type" content="article"><meta property="og:url" content="https://heir.dev/docs/dialects/lwe/"><meta property="article:section" content="docs"><meta itemprop=name content="LWE"><meta itemprop=description content="LWE attributes PlaintextEncodingAttr Syntax: #lwe.plaintext_encoding
ApplicationDataAttr Syntax:
#lwe.application_data< mlir::Type, # message_type Attribute # overflow > An attribute describing the semantics of the underlying application data.
The messageType parameter is used to describe the type and bits of the original application data, e.g. i1, i32, f32. This type is later mapped into the plaintext space of an FHE scheme by embedding, scaling, or other techniques.
This attribute also contains information about the overflow semantics of the data in the application."><meta itemprop=wordCount content="4478"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="LWE"><meta name=twitter:description content="LWE attributes PlaintextEncodingAttr Syntax: #lwe.plaintext_encoding
ApplicationDataAttr Syntax:
#lwe.application_data< mlir::Type, # message_type Attribute # overflow > An attribute describing the semantics of the underlying application data.
The messageType parameter is used to describe the type and bits of the original application data, e.g. i1, i32, f32. This type is later mapped into the plaintext space of an FHE scheme by embedding, scaling, or other techniques.
This attribute also contains information about the overflow semantics of the data in the application."><link rel=preload href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css as=style><link href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=td-page><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="32" height="32" fill="#fff" fill-opacity=".01"/><path d="M18.6889 10.124l7.7916 5.0511 2.6263-1.6684-2.6146-1.6779-7.8033-4.96754 2.8526 1.84162L18.6889 10.124z" fill="#efcf6f"/><path d="M29.1185 6.86125 18.6979.13981 16.06 1.79876 26.4922 8.52025l2.6263-1.659z" fill="#efcf6f"/><path d="M8.2405 6.74134 5.60033 5.07291 3.05751 6.79935 5.67334 8.49344 8.2405 6.74134z" fill="#ee958a"/><path d="M10.8697 8.49344 8.2405 10.124v3.3995l5.2049-3.3348-2.5757-1.69526z" fill="#ee958a"/><path d="M5.67334 8.49344 3.05751 6.79935 3.03318 23.4932l2.64016 1.6897V8.49344z" fill="#a32e24"/><path d="M29.1185 6.86126 26.4922 8.52025V11.8288l2.6263-1.6401V6.86126z" fill="#d38041"/><path d="M21.5415 8.70288 18.6889 6.86126V10.124l2.8526-1.42112z" fill="#d38041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M8.2405 6.74134V10.124v3.3995l5.2049-3.3348V3.58723l2.6145-1.7885L16.1123 11.8484V18.467l-2.6158 1.6181L13.4574 13.5235 10.849 15.1694 8.2405 16.8152v6.678L5.67334 25.1829V8.49344L8.2405 6.74134z" fill="#dd583b"/><path d="M13.4965 20.0851 13.4574 13.5235 10.849 15.1694 10.8077 18.467l2.6888 1.6181z" fill="#a32e24"/><path fill-rule="evenodd" clip-rule="evenodd" d="M13.4454 3.58723V10.1887L10.8697 8.49344 10.9293 1.79873l2.5161 1.7885z" fill="#a32e24"/><path d="M16.0599 1.79873 13.4454.13981 10.9293 1.79873l2.5161 1.7885 2.6145-1.7885z" fill="#ee958a"/><path d="M16.06 1.79876 16.0793 5.52165 16.1123 11.8484V18.467l2.5766-1.6518V13.4696 10.124 6.86126l7.8033 4.96754V8.52025L16.06 1.79876z" fill="#e5ad11"/><path d="M18.6889 16.8152 16.1123 18.467l10.3682 6.7159V21.8372l-7.7916-5.022z" fill="#e5ad11"/><path d="M26.4805 15.1751 18.6889 10.124v3.3456l2.7505 1.7641 5.0411 3.2333V15.1751z" fill="#e5ad11"/><path d="M29.1068 13.5067l-2.6263 1.6684V18.467l2.6263-1.6518V13.5067z" fill="#d48041"/><path d="M29.1185 20.0851l-2.638 1.7521v3.3457l2.6263-1.6897L29.1185 20.0851z" fill="#d48041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M26.4805 21.8372l-7.7916-5.022 2.7505-1.5815 5.0411 3.2333 2.638 1.6181-2.638 1.7521z" fill="#efcf6f"/><path d="M18.6889 13.4696v3.3456l2.7505-1.5815-2.7505-1.7641z" fill="#d48041"/><path d="M20.1621 26.5165l-4.2015-2.7017-4.2015-2.7016L11.7108 23.8491l6.3384 4.0776 2.1129 1.3512V26.5165z" fill="#395aad"/><path d="M7.49852 23.8491v2.6674l8.41958 5.4439V29.2779L7.49852 23.8491z" fill="#276e3a"/><path d="M9.57951 22.4781l-2.08099 1.371 8.41958 5.4288 2.1311-1.3512-6.3384-4.0776-2.13129-1.371z" fill="#add284"/><path d="M24.3747 26.5165V23.8491L22.174 22.8377l-2.0054.9665 2.1815 1.3793 2.0246 1.333z" fill="#395aad"/><path d="M18.0492 19.7061l2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#395aad"/><path fill-rule="evenodd" clip-rule="evenodd" d="M20.1621 18.4432l-2.0415-.596-2.1581.596-2.1017 1.3349-2.1017 1.3351 2.1012 1.3511 6.3018 4.0522 2.188-1.333-2.1815-1.3793 2.0054-.9665 2.2007 1.0114 2.0995-1.329-2.0811-1.4069L22.3501 21.1371l-.1752-1.4237L22.174 19.7061l-2.0119-1.2629zm-2.1129 1.2629 2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#9ec4e0"/><path d="M26.4742 22.5201l-2.0995 1.329v2.6674l2.1289-1.3305L26.4742 22.5201z" fill="#4285f4"/><path d="M20.1621 26.5165v2.7614l2.188-1.3512V25.1835l-2.188 1.333z" fill="#4285f4"/><path d="M15.9181 29.2779v2.6825l2.1311-1.3708V27.9267l-2.1311 1.3512z" fill="#4e9c68"/></svg></span><span class=navbar-brand__name>HEIR</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/><span>Home</span></a></li><li class=nav-item><a class="nav-link active" href=/docs/><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://github.com/google/heir/ target=_blank rel=noopener><span>GitHub</span></a></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ms-3 fas fa-bars" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="collapse td-sidebar-nav" id=td-section-nav><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m--li><a href=/ title="HEIR: Homomorphic Encryption Intermediate Representation" class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-><span>Home</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-docs-li><a href=/docs/ title=Documentation class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docs><span>Docs</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsgetting_started-li><a href=/docs/getting_started/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsgetting_started><span>Getting Started</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docscontributing-li><a href=/docs/contributing/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docscontributing><span>Contributing to HEIR</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdevelopment-li><a href=/docs/development/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdevelopment><span>Development</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docstutorials-li><a href=/docs/tutorials/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docstutorials><span>Tutorials and Talks</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-docsdesign-li><a href=/docs/design/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsdesign><span>Design</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesigndo_transformation-li><a href=/docs/design/do_transformation/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesigndo_transformation><span>Data-oblivious Transformations</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesignsecret-li><a href=/docs/design/secret/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignsecret><span>Secret</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesignsimd-li><a href=/docs/design/simd/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignsimd><span>SIMD Optimizations</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesignrelinearization_ilp-li><a href=/docs/design/relinearization_ilp/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignrelinearization_ilp><span>Optimizing relinearization</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docspipelines-li><a href=/docs/pipelines/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docspipelines><span>Pipelines</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-docsdialects-li><a href=/docs/dialects/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsdialects><span>Dialects</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsbgv-li><a href=/docs/dialects/bgv/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsbgv><span>BGV</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectscggi-li><a href=/docs/dialects/cggi/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectscggi><span>CGGI</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsckks-li><a href=/docs/dialects/ckks/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsckks><span>CKKS</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectscomb-li><a href=/docs/dialects/comb/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectscomb><span>Comb</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsjaxite-li><a href=/docs/dialects/jaxite/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsjaxite><span>Jaxite</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-docsdialectslwe-li><a href=/docs/dialects/lwe/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-docsdialectslwe><span class=td-sidebar-nav-active-item>LWE</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsmodarith-li><a href=/docs/dialects/modarith/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsmodarith><span>ModArith</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsopenfhe-li><a href=/docs/dialects/openfhe/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsopenfhe><span>Openfhe</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectspolynomial-li><a href=/docs/dialects/polynomial/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectspolynomial><span>Polynomial</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsrandom-li><a href=/docs/dialects/random/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsrandom><span>Random</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsrns-li><a href=/docs/dialects/rns/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsrns><span>RNS</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectssecret-li><a href=/docs/dialects/secret/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectssecret><span>Secret</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectstensorext-li><a href=/docs/dialects/tensorext/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectstensorext><span>TensorExt</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectstfherust-li><a href=/docs/dialects/tfherust/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectstfherust><span>TfheRust</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectstfherustbool-li><a href=/docs/dialects/tfherustbool/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectstfherustbool><span>TfheRustBool</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docspasses-li><a href=/docs/passes/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docspasses><span>Passes</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-community-li><a href=/community/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-community><span>Community</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-search-li><a href=/search/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-search><span>Search Results</span></a></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ms-2 pb-1 pt-2 mb-0"><a href=https://github.com/google/heir/edit/main/lib/Dialect/LWE/IR target=_blank><i class="fa-solid fa-pen-to-square fa-fw"></i> Edit this page</a>
<a id=print href=https://heir.dev/docs/dialects/_print/><i class="fa-solid fa-print fa-fw"></i> Print entire section</a></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#lwe-attributes>LWE attributes</a><ul><li><a href=#plaintextencodingattr>PlaintextEncodingAttr</a></li><li><a href=#applicationdataattr>ApplicationDataAttr</a></li><li><a href=#bitfieldencodingattr>BitFieldEncodingAttr</a></li><li><a href=#ciphertextspaceattr>CiphertextSpaceAttr</a></li><li><a href=#coefficientencodingattr>CoefficientEncodingAttr</a></li><li><a href=#constantcoefficientencodingattr>ConstantCoefficientEncodingAttr</a></li><li><a href=#fullcrtpackingencodingattr>FullCRTPackingEncodingAttr</a></li><li><a href=#inversecanonicalencodingattr>InverseCanonicalEncodingAttr</a></li><li><a href=#keyattr>KeyAttr</a></li><li><a href=#lweparamsattr>LWEParamsAttr</a></li><li><a href=#moduluschainattr>ModulusChainAttr</a></li><li><a href=#nooverflowattr>NoOverflowAttr</a></li><li><a href=#plaintextspaceattr>PlaintextSpaceAttr</a></li><li><a href=#preserveoverflowattr>PreserveOverflowAttr</a></li><li><a href=#rlweparamsattr>RLWEParamsAttr</a></li><li><a href=#unspecifiedbitfieldencodingattr>UnspecifiedBitFieldEncodingAttr</a></li><li><a href=#inversecanonicalembeddingencodingattr>InverseCanonicalEmbeddingEncodingAttr</a></li><li><a href=#polynomialcoefficientencodingattr>PolynomialCoefficientEncodingAttr</a></li><li><a href=#polynomialevaluationencodingattr>PolynomialEvaluationEncodingAttr</a></li></ul></li><li><a href=#lwe-types>LWE types</a><ul><li><a href=#lweciphertexttype>LWECiphertextType</a></li><li><a href=#lweplaintexttype>LWEPlaintextType</a></li><li><a href=#newlweciphertexttype>NewLWECiphertextType</a></li><li><a href=#newlweplaintexttype>NewLWEPlaintextType</a></li><li><a href=#newlwepublickeytype>NewLWEPublicKeyType</a></li><li><a href=#newlwesecretkeytype>NewLWESecretKeyType</a></li><li><a href=#rlweciphertexttype>RLWECiphertextType</a></li><li><a href=#rlweplaintexttype>RLWEPlaintextType</a></li><li><a href=#rlwepublickeytype>RLWEPublicKeyType</a></li><li><a href=#rlwesecretkeytype>RLWESecretKeyType</a></li></ul></li><li><a href=#lwe-ops>LWE ops</a><ul><li><a href=#lweadd-heirlweaddop><code>lwe.add</code> (heir::lwe::AddOp)</a></li><li><a href=#lweencode-heirlweencodeop><code>lwe.encode</code> (heir::lwe::EncodeOp)</a></li><li><a href=#lwemul_scalar-heirlwemulscalarop><code>lwe.mul_scalar</code> (heir::lwe::MulScalarOp)</a></li><li><a href=#lweradd-heirlweraddop><code>lwe.radd</code> (heir::lwe::RAddOp)</a></li><li><a href=#lwerlwe_decode-heirlwerlwedecodeop><code>lwe.rlwe_decode</code> (heir::lwe::RLWEDecodeOp)</a></li><li><a href=#lwerlwe_decrypt-heirlwerlwedecryptop><code>lwe.rlwe_decrypt</code> (heir::lwe::RLWEDecryptOp)</a></li><li><a href=#lwerlwe_encode-heirlwerlweencodeop><code>lwe.rlwe_encode</code> (heir::lwe::RLWEEncodeOp)</a></li><li><a href=#lwerlwe_encrypt-heirlwerlweencryptop><code>lwe.rlwe_encrypt</code> (heir::lwe::RLWEEncryptOp)</a></li><li><a href=#lwermul-heirlwermulop><code>lwe.rmul</code> (heir::lwe::RMulOp)</a></li><li><a href=#lwernegate-heirlwernegateop><code>lwe.rnegate</code> (heir::lwe::RNegateOp)</a></li><li><a href=#lwersub-heirlwersubop><code>lwe.rsub</code> (heir::lwe::RSubOp)</a></li><li><a href=#lwetrivial_encrypt-heirlwetrivialencryptop><code>lwe.trivial_encrypt</code> (heir::lwe::TrivialEncryptOp)</a></li><li><a href=#lwereinterpret_underlying_type-heirlwereinterpretunderlyingtypeop><code>lwe.reinterpret_underlying_type</code> (heir::lwe::ReinterpretUnderlyingTypeOp)</a></li></ul></li></ul></nav></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=https://heir.dev/docs/>Docs</a></li><li class=breadcrumb-item><a href=https://heir.dev/docs/dialects/>Dialects</a></li><li class="breadcrumb-item active" aria-current=page>LWE</li></ol></nav><div class=td-content><h1>LWE</h1><header class=article-meta></header><h2 id=lwe-attributes>LWE attributes</h2><h3 id=plaintextencodingattr>PlaintextEncodingAttr</h3><p>Syntax: <code>#lwe.plaintext_encoding</code></p><h3 id=applicationdataattr>ApplicationDataAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.application_data&lt;
  mlir::Type,   # message_type
  Attribute   # overflow
&gt;
</code></pre><p>An attribute describing the semantics of the underlying application data.</p><p>The <code>messageType</code> parameter is used to describe the type and bits of the
original application data, e.g. i1, i32, f32. This type is later mapped
into the plaintext space of an FHE scheme by embedding, scaling, or other
techniques.</p><p>This attribute also contains information about the overflow semantics of the
data in the application. By default, we assume that the application program
was written so that the overflow is not expected and the overflow attribute
can can be <code>no_overflow</code>. For LWE-based CGGI ciphertexts, the overflow
attribute will usually be <code>preserve_overflow</code>, since messages will overflow
into padding bits.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>message_type</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>overflow</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=bitfieldencodingattr>BitFieldEncodingAttr</h3><p>An attribute describing encoded LWE plaintexts using bit fields.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.bit_field_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>A bit field encoding of an integer describes which contiguous region
of bits a small integer occupies within a larger integer.</p><p>The data describing the encoding consists of the starting bit positions of
the cleartext bit field and its width, where the LSB is bit 0 and the MSB
is bit <code>bit_width-1</code>. So the above example would have starting bit <code>30</code> and
width <code>3</code>. The bits not specified for the message have semantics defined
by the scheme or lowering.</p><p>Note that this encoding does not specify the underlying bit width of the
plaintext space. This is left for lowerings to decide.</p><p>The presence of this attribute as the <code>encoding</code> attribute of a tensor
indicates that the tensor is an LWE ciphertext.</p><p><strong>Example (CGGI):</strong></p><pre tabindex=0><code>#encoding = #lwe.bit_field_encoding&lt;cleartext_start=30, cleartext_bitwidth=3&gt;
!plaintext = !lwe.lwe_plaintext&lt;encoding = #encoding&gt;

%0 = arith.constant 4 : i3
%1 = lwe.encode %0 { encoding = #encoding }: i3 to !plaintext
</code></pre><p>The above represents an LWE plaintext encoding the 3-bit cleartext 4 as an
LWE ciphertext in a 32-bit integer, with a single bit of padding at the MSB.
This corresponds to the following, where 0 denotes a 0 bit, <code>b</code> denotes a
bit of the cleartext, <code>n</code> denotes a bit reserved for noise, and <code>|</code> is a
visual aid to show where the bit fields begin and end.</p><pre tabindex=0><code>   0|bbb|nn...n
MSB^          ^LSB
</code></pre><p><strong>Example (BGV):</strong></p><p>Note: BGV uses the RLWE encodings, but they have the same bit-field encoding
attributes as here. So this example serves mainly to show how this attribute
can be used to specify storing bits in the LSB of a plaintext.</p><pre tabindex=0><code>#encoding = #lwe.bit_field_encoding&lt;cleartext_start=4, cleartext_bitwidth=4&gt;
!plaintext = !lwe.lwe_plaintext&lt;encoding = #encoding&gt;

%0 = arith.constant 9 : i4
%1 = lwe.encode %0 { encoding = #encoding }: i4 to !plaintext
</code></pre><p>The above represents an LWE plaintext encoding a 4-bit cleartext as an
LWE ciphertext in the least-significant bits of a larger integer.
This corresponds to the following.</p><pre tabindex=0><code>   nn...n|bbbb
MSB^         ^LSB
</code></pre><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=ciphertextspaceattr>CiphertextSpaceAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.ciphertext_space&lt;
  ::mlir::heir::polynomial::RingAttr,   # ring
  ::mlir::heir::lwe::LweEncryptionType,   # encryption_type
  unsigned   # size
&gt;
</code></pre><p>An attribute describing the ciphertext space and the transformation from
plaintext space to ciphertext space of an FHE scheme.</p><p>The ciphertext space information includes the ring attribute, describing the
space that the ciphertext elements belong to. The ring attribute contains a
coefficient type attribute that describes the semantics of the coefficient.
For example, a ring modulo $1 + x^1024$ with coefficients modulo $q =
298374$ will be described as</p><pre tabindex=0><code>!ideal = !polynomial.int_polynomial&lt;1 + x**1024&gt;
!cmod = !mod_arith.mod_arith&lt;modulus=298374 : i64&gt;
#ring = #polynomial.ring&lt;coefficientType = !cmod, modulus = !ideal&gt;
#ciphertext_space = #lwe.ciphertext_space&lt;ring = #ring, encryption_type = #encryption_type&gt;
</code></pre><p>Ciphertexts using an RNS representation for $q$ will use an RNS type in
their ring&rsquo;s coefficient type attribute.</p><p>// TODO(#1085): Validate syntax of polynomial ring after coefficientType changes.</p><pre tabindex=0><code>!ideal = !polynomial.int_polynomial&lt;1 + x**1024&gt;
!limb1 = !mod_arith.mod_arith&lt;modulus=2251799814045697 : i64&gt;
!limb2 = !mod_arith.mod_arith&lt;modulus=65537 : i64&gt;
#rns_mod = !rns.rns&lt;!limb1, !limb2&gt;
#ring = #polynomial.ring&lt;coefficientType = #rns_mod, modulus = #ideal&gt;
#ciphertext_space = #lwe.ciphertext_space&lt;ring = #ring, encryption_type = #encryption_type&gt;
</code></pre><p>Scalar LWE ciphertexts (like those used in CGGI) use an ideal polynomial of
degree 1, $x$. CGGI ciphertexts will typically use a power of two modulus
and may use a native integer type for its coefficient modulus.</p><pre tabindex=0><code>!ideal = !polynomial.int_polynomial&lt;1 + x**1024&gt;
#ring = #polynomial.ring&lt;coefficientType = i32, modulus = #ideal&gt;
#ciphertext_space = #lwe.ciphertext_space&lt;ring = #ring, encryption_type = #encryption_type&gt;
</code></pre><p>The ciphertext encoding info is used to describe the way the plaintext data
is encoded into the ciphertext (in the MSB, LSB, or mixed).</p><p>The <code>size</code> parameter is used to describe the number of polynomials
comprising the ciphertext. This is typically 2 for RLWE ciphertexts that
are made up of an $(a, b)$ pair and greater than 2 for LWE instances. For
example, after an RLWE multiplication of two size 2 ciphertexts,
the ciphertext&rsquo;s size will be 3.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr><tr><td style=text-align:center>encryption_type</td><td style=text-align:center><code>::mlir::heir::lwe::LweEncryptionType</code></td><td></td></tr><tr><td style=text-align:center>size</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=coefficientencodingattr>CoefficientEncodingAttr</h3><p>An encoding of cleartexts directly as coefficients.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.coefficient_encoding&lt;
  unsigned   # scaling_factor
&gt;
</code></pre><p>A coefficient encoding of a list of integers asserts that the coefficients
of the polynomials contain the integers, with the same semantics as
<code>constant_coefficient_encoding</code> for per-coefficient encodings.</p><p>A <code>scaling_factor</code> is optionally applied on the scalar when converting from
a rounded floating point to an integer.</p><p>Example:</p><pre tabindex=0><code>#coeff_encoding = #lwe.coefficient_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=constantcoefficientencodingattr>ConstantCoefficientEncodingAttr</h3><p>An encoding of a scalar in the constant coefficient</p><p>Syntax:</p><pre tabindex=0><code>#lwe.constant_coefficient_encoding&lt;
  unsigned   # scaling_factor
&gt;
</code></pre><p>An encoding of a single scalar into the constant coefficient of the plaintext.</p><p>All other coefficients of the plaintext are set to be zero. This encoding is
used to encode scalar LWE ciphertexts where the plaintext space is viewed
as a polynomial ring modulo <code>x</code>.</p><p>The scalar is first multiplied by the <code>scaling_factor</code> and then rounded to
the nearest integer before encoding into the plaintext coefficient.</p><p>Example:</p><pre tabindex=0><code>#coeff_encoding = #lwe.constant_coefficient_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=fullcrtpackingencodingattr>FullCRTPackingEncodingAttr</h3><p>An encoding of cleartexts via CRT slots.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.full_crt_packing_encoding&lt;
  unsigned   # scaling_factor
&gt;
</code></pre><p>This encoding maps a list of integers via the Chinese Remainder Theorem (CRT) into the plaintext space.</p><p>Given a ring with irreducible ideal polynomial <code>f(x)</code> and coefficient
modulus <code>q</code>, <code>f(x)</code> can be decomposed modulo <code>q</code> into a direct product of
lower-degree polynomials. This allows full SIMD-style homomorphic operations
across the slots formed from each factor.</p><p>This attribute can only be used in the context of on full CRT packing, where
the polynomial <code>f(x)</code> splits completely (into linear factors) and the number
of slots equals the degree of <code>f(x)</code>. This happens when <code>q</code> is prime and <code>q = 1 mod n</code>.</p><p>A <code>scaling_factor</code> is optionally applied on the scalar when converting from
a rounded floating point to an integer.</p><p>Example:</p><pre tabindex=0><code>#coeff_encoding = #lwe.full_crt_packing_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=inversecanonicalencodingattr>InverseCanonicalEncodingAttr</h3><p>An encoding of cleartexts via the inverse canonical embedding.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.inverse_canonical_encoding&lt;
  unsigned   # scaling_factor
&gt;
</code></pre><p>Let $n$ be the degree of the polynomials in the plaintext space. An
&ldquo;inverse_canonical_encoding&rdquo; of a list of real or complex values
$v_1, \dots, v_{n/2}$ is (almost) the inverse of the following decoding
map.</p><p>Define a map $\tau_N$ that maps a polynomial $p \in \mathbb{Z}[x] / (x^N + 1)
\to \mathbb{C}^{N/2}$ by evaluating it at the following $N/2$ points,
where $\omega = e^{2 \pi i / 2N}$ is the primitive $2N$th root of unity:</p><p>[
\omega, \omega^3, \omega^5, \dots, \omega^{N-1}
]</p><p>Then the complete decoding operation is $\textup{Decode}(p) =
(1/\Delta)\tau_N(p)$, where $\Delta$ is a scaling parameter and $\tau_N$ is
the truncated canonical embedding above. The encoding operation is the
inverse of the decoding operation, with some caveats explained below.</p><p>The map $\tau_N$ is derived from the so-called <em>canonical embedding</em>
$\tau$, though in the standard canonical embedding, we evaluate at all odd
powers of the root of unity, $\omega, \omega^3, \dots, \omega^{2N-1}$. For
polynomials in the slightly larger space $\mathbb{R}[x] / (x^N + 1)$, the
image of the canonical embedding is the subspace $H \subset \mathbb{C}^N$
defined by tuples $(z_1, \dots, z_N)$ such that $\overline{z_i} =
\overline{z_{N-i+1}}$. Note that this property holds because polynomial
evaluation commutes with complex conjugates, and the second half of the
roots of unity evaluate are complex conjugates of the first half. The
converse, that any such tuple with complex conjugate symmetry has an
inverse under $\tau$ with all real coefficients, makes $\tau$ is a
bijection onto $H$. $\tau$ and its inverse are explicitly computable as
discrete Fourier Transforms.</p><p>Because of the symmetry in canonical embedding for real polynomials, inputs
to this encoding can be represented as a list of $N/2$ complex points, with
the extra symmetric structure left implicit. $\tau_N$ and its inverse can
also be explicitly computed without need to expand the vectors to length
$N$.</p><p>The rounding step is required to invert the decoding because, while
cleartexts must be (implicitly) in the subspace $H$, they need not be the
output of $\tau_N$ for an <em>integer</em> polynomial. The rounding step ensures
we can use integer polynomial plaintexts for the FHE operations. There are
multiple rounding mechanisms, and this attribute does not specify which is
used, because in theory two ciphertexts that have used different roundings
are still compatible, though they may have different noise growth patterns.</p><p>The scaling parameter $\Delta$ is specified by the <code>scaling_factor</code>, which
are applied coefficient-wise using the same semantics as the
<code>constant_coefficient_encoding</code>.</p><p>A typical flow for the CKKS scheme using this encoding would be to apply an
inverse FFT operation to invert the canonical embedding to be a polynomial
with real coefficients, then encrypt scale the resulting polynomial&rsquo;s
coefficients according to the scaling parameters, then round to get integer
coefficients.</p><p>Example:</p><pre tabindex=0><code>#canonical_encoding = #lwe.inverse_canonical_encoding&lt;scaling_factor=10000&gt;
</code></pre><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scaling_factor</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=keyattr>KeyAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.key&lt;
  int   # slot_index
&gt;
</code></pre><p>An attribute describing the key with which the message is currently
encrypted.</p><p>The key attribute describes the key with which the message is currently
encrypted and decryption can be performed. For example, if the decryption of
a ciphertext $c = (c_0(x), c_1(x))$ is performed by computing the inner
product $(c_0(x), c_1(x)) \cdot (1, s(x))$ then the key is $(1, s(x))$.</p><p>The <code>slot_index</code> describes the key after using a Galois automorphism to
rotate the plaintext slots by <code>slot_index</code>. This will correspond to an
action $\phi_k: x \rightarrow x^k$ for some <code>k</code> that depends on the
structure of the Galois group for the chosen scheme parameters. The
corresponding key will have a new basis $(1, s(x^(k)))$.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>slot_index</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=lweparamsattr>LWEParamsAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.lwe_params&lt;
  IntegerAttr,   # cmod
  unsigned   # dimension
&gt;
</code></pre><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cmod</td><td style=text-align:center><code>IntegerAttr</code></td><td></td></tr><tr><td style=text-align:center>dimension</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=moduluschainattr>ModulusChainAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.modulus_chain&lt;
  ::llvm::ArrayRef&lt;mlir::IntegerAttr&gt;,   # elements
  int   # current
&gt;
</code></pre><p>An attribute describing the elements of the modulus chain of an RLWE scheme.</p><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::IntegerAttr></code></td><td></td></tr><tr><td style=text-align:center>current</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=nooverflowattr>NoOverflowAttr</h3><p>An attribute informing that application data never overflows.</p><p>Syntax: <code>#lwe.no_overflow</code></p><p>This attribute informs lowerings that a program is written so that the message data
will never overflow beyond the message type.</p><p>// FIXME: Have a separate WraparoundOverflow, which lowers the same as NoOverflow?</p><h3 id=plaintextspaceattr>PlaintextSpaceAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.plaintext_space&lt;
  ::mlir::heir::polynomial::RingAttr,   # ring
  Attribute   # encoding
&gt;
</code></pre><p>An attribute describing the plaintext space and the transformation from
application data to plaintext space of an FHE scheme.</p><p>The plaintext space information is the ring structure, which contains the
plaintext modulus $t$, which may be a power of two in the case of CGGI
ciphertexts, or a prime power for RLWE. LWE ciphertexts use the
ideal polynomial of degree 1 $x$. The plaintext modulus used in LWE-based
CGGI plaintexts describes the full message space $\mathbb{Z}_p$ including
the padding bits. The application data info attribute describes the space
$\mathbb{Z}_p&rsquo;$ where $p&rsquo; &lt; p$ that the underlying message belongs to.</p><p>For RLWE schemes, this will include the type of encoding of application data
integers to a plaintext space <code>Z_p[X]/X^N + 1</code>. This may be a constant
coefficient encoding, CRT-based packing for SIMD semantics, or other slot
packing. When using full CRT packing, the ring must split into linear
factors. The CKKS scheme will also include attributes describing the complex
encoding, including the scaling factor, which will change after
multiplication and rescaling.</p><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=preserveoverflowattr>PreserveOverflowAttr</h3><p>An attribute informing that application data overflows in the message type.</p><p>Syntax: <code>#lwe.preserve_overflow</code></p><p>This attribute informs lowerings that a program is written so that the message data
may overflow beyond the message type.</p><h3 id=rlweparamsattr>RLWEParamsAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.rlwe_params&lt;
  unsigned,   # dimension
  ::mlir::heir::polynomial::RingAttr   # ring
&gt;
</code></pre><p>An attribute describing classical RLWE parameters:</p><ul><li><code>dimension</code>: the number of polynomials used in an RLWE sample, analogous
to LWEParams.dimension.</li><li><code>ring</code>: the polynomial ring to use.</li></ul><h4 id=parameters-11>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>dimension</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr></tbody></table><h3 id=unspecifiedbitfieldencodingattr>UnspecifiedBitFieldEncodingAttr</h3><p>An attribute describing unspecified bit field encodings.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.unspecified_bit_field_encoding&lt;
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>See LWE_BitFieldEncoding for a description of bit field encodings.</p><p>This attribute describes an unspecified bit field encoding; this is where
the starting bit position of the cleartext bit field is unspecified, but its
width is fixed. A noise growth analysis should be performed to determine the
optimal amount of bits needed for noise and padding to specify the bit field
encodings starting bit position.</p><p>Example:</p><pre tabindex=0><code>#lwe_encoding = #lwe.unspecified_bit_field_encoding&lt;cleartext_bitwidth=3&gt;
%lwe_ciphertext = arith.constant &lt;[1,2,3,4]&gt; : tensor&lt;4xi32, #lwe_encoding&gt;
</code></pre><h4 id=parameters-12>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=inversecanonicalembeddingencodingattr>InverseCanonicalEmbeddingEncodingAttr</h3><p>An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.inverse_canonical_embedding_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>Let $n$ be the degree of the polynomials in the plaintext space. An
&ldquo;inverse canonical embedding encoding&rdquo; of a list of real or complex values
$v_1, \dots, v_{n/2}$ is (almost) the inverse of the following decoding
map.</p><p>Define a map $\tau_N$ that maps a polynomial $p \in \mathbb{Z}[x] / (x^N + 1)
\to \mathbb{C}^{N/2}$ by evaluating it at the following $N/2$ points,
where $\omega = e^{2 \pi i / 2N}$ is the primitive $2N$th root of unity:</p><p>[
\omega, \omega^3, \omega^5, \dots, \omega^{N-1}
]</p><p>Then the complete decoding operation is $\textup{Decode}(p) =
(1/\Delta)\tau_N(p)$, where $\Delta$ is a scaling parameter and $\tau_N$ is
the truncated canonical embedding above. The encoding operation is the
inverse of the decoding operation, with some caveats explained below.</p><p>The map $\tau_N$ is derived from the so-called <em>canonical embedding</em>
$\tau$, though in the standard canonical embedding, we evaluate at all odd
powers of the root of unity, $\omega, \omega^3, \dots, \omega^{2N-1}$. For
polynomials in the slightly larger space $\mathbb{R}[x] / (x^N + 1)$, the
image of the canonical embedding is the subspace $H \subset \mathbb{C}^N$
defined by tuples $(z_1, \dots, z_N)$ such that $\overline{z_i} =
\overline{z_{N-i+1}}$. Note that this property holds because polynomial
evaluation commutes with complex conjugates, and the second half of the
roots of unity evaluate are complex conjugates of the first half. The
converse, that any such tuple with complex conjugate symmetry has an
inverse under $\tau$ with all real coefficients, makes $\tau$ is a
bijection onto $H$. $\tau$ and its inverse are explicitly computable as
discrete Fourier Transforms.</p><p>Because of the symmetry in canonical embedding for real polynomials, inputs
to this encoding can be represented as a list of $N/2$ complex points, with
the extra symmetric structure left implicit. $\tau_N$ and its inverse can
also be explicitly computed without need to expand the vectors to length
$N$.</p><p>The rounding step is required to invert the decoding because, while
cleartexts must be (implicitly) in the subspace $H$, they need not be the
output of $\tau_N$ for an <em>integer</em> polynomial. The rounding step ensures
we can use integer polynomial plaintexts for the FHE operations. There are
multiple rounding mechanisms, and this attribute does not specify which is
used, because in theory two ciphertexts that have used different roundings
are still compatible, though they may have different noise growth patterns.</p><p>The scaling parameter $\Delta$ is specified by the <code>cleartext_start</code> and
<code>cleartext_bitwidth</code> parameters, which are applied coefficient-wise using
the same semantics as the <code>bit_field_encoding</code>.</p><p>This attribute can be used in multiple ways:</p><ul><li>On a <code>poly.poly</code>, it asserts that the polynomial has been transformed
from a coefficient list using the canonical embedding.</li><li>On a tensor of <code>poly.poly</code>, it asserts that the tensor is an RLWE
ciphertext for some RLWE scheme that supports the approximate embedding
encoding.</li></ul><p>A typical flow for the CKKS scheme using this encoding would be to apply an
inverse FFT operation to invert the canonical embedding to be a polynomial
with real coefficients, then encrypt scale the resulting polynomial&rsquo;s
coefficients according to the scaling parameters, then round to get integer
coefficients.</p><p>Example:</p><pre tabindex=0><code>#generator = #poly.polynomial&lt;1 + x**1024&gt;
#ring = #poly.ring&lt;cmod=65536, ideal=#generator&gt;
#lwe_encoding = #lwe.polynomial_evaluation_encoding&lt;cleartext_start=30, cleartext_bitwidth=3&gt;

%evals = arith.constant &lt;[1, 2, 4, 5]&gt; : tensor&lt;4xi16&gt;
%poly1 = poly.intt %evals : tensor&lt;4xi16, #ring&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%poly2 = poly.intt %evals : tensor&lt;4xi16, #ring&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&lt;2x!poly.poly&lt;#ring, #eval_encoding&gt;&gt;
</code></pre><p>See <code>bit_field_encoding</code> for the definition of the <code>cleartext_start</code> and
<code>cleartext_bitwidth</code> fields.</p><h4 id=parameters-13>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=polynomialcoefficientencodingattr>PolynomialCoefficientEncodingAttr</h3><p>An attribute describing encoded RLWE plaintexts via coefficients.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.polynomial_coefficient_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>A coefficient encoding of a list of integers asserts that the coefficients
of the polynomials contain the cleartexts, with the same semantics as
<code>bit_field_encoding</code> for per-coefficient encodings.</p><p>The presence of this attribute as the <code>encoding</code> attribute of a tensor of
<code>poly.poly</code> indicates that the tensor is an RLWE ciphertext for some RLWE
scheme that supports the coefficient encoding.</p><p>See <code>bit_field_encoding</code> for the definition of the <code>cleartext_start</code> and
<code>cleartext_bitwidth</code> fields.</p><p>Example:</p><pre tabindex=0><code>#generator = #poly.polynomial&lt;1 + x**1024&gt;
#ring = #poly.ring&lt;cmod=65536, ideal=#generator&gt;
#coeff_encoding = #lwe.polynomial_coefficient_encoding&lt;cleartext_start=15, cleartext_bitwidth=4&gt;

%poly1 = poly.from_tensor %coeffs1 : tensor&lt;10xi16&gt; -&gt; !poly.poly&lt;#ring&gt;
%poly2 = poly.from_tensor %coeffs2 : tensor&lt;10xi16&gt; -&gt; !poly.poly&lt;#ring&gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&lt;2x!poly.poly&lt;#ring&gt;, #coeff_encoding&gt;
</code></pre><h4 id=parameters-14>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=polynomialevaluationencodingattr>PolynomialEvaluationEncodingAttr</h3><p>An attribute describing encoded RLWE plaintexts via evaluations at fixed points.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.polynomial_evaluation_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>A &ldquo;evaluation encoding&rdquo; of a list of integers $(v_1, \dots, v_n)$ asserts
that $f(x_1 ) = v_1, \dots, f(x_n) = v_n$ for some implicit, but fixed and
distinct choice of inputs $x_i$. The encoded values are also scaled by a
scale factor, having the same semantics as <code>bit_field_encoding</code>, but
applied entry-wise (to either the coefficient or evaluation representation).</p><p>This attribute can be used in multiple ways:</p><ul><li>On a <code>poly.poly</code>, it asserts that the polynomial has been transformed
from an evaluation tensor.</li><li>On a tensor of <code>poly.poly</code>, it asserts that the tensor is an RLWE
ciphertext for some RLWE scheme that supports the evaluation encoding.</li></ul><p>A typical workflow for the BFV/BGV schemes using this encoding would be
to apply a INTT operation to the input list of cleartexts to convert from
evaluation form to coefficient form, then encrypt the resulting polynomial
in coefficient form, then apply NTT back to the evaluation form for faster
multiplication of ciphertexts.</p><p>The points chosen are fixed to be the powers of a primitive root of unity
of the coefficient ring of the plaintext space, which allows one to use
NTT/INTT to tansform quickly between the coefficient and evaluation forms.</p><p>Example:</p><pre tabindex=0><code>#generator = #poly.polynomial&lt;1 + x**1024&gt;
// note that the cmod should be chosen so as to ensure a primitive root of
// unity exists in the multiplicative group (Z / cmod Z)^*
#ring = #poly.ring&lt;cmod=65536, ideal=#generator&gt;
#lwe_encoding = #lwe.polynomial_evaluation_encoding&lt;cleartext_start=30, cleartext_bitwidth=3&gt;

%evals = arith.constant &lt;[1, 2, 4, 5]&gt; : tensor&lt;4xi16&gt;
%poly1 = poly.intt %evals : tensor&lt;4xi16, #ring&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%poly2 = poly.intt %evals : tensor&lt;4xi16, #ring&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&lt;2x!poly.poly&lt;#ring, #eval_encoding&gt;&gt;
</code></pre><p>See <code>bit_field_encoding</code> for the definition of the <code>cleartext_start</code> and
<code>cleartext_bitwidth</code> fields.</p><h4 id=parameters-15>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h2 id=lwe-types>LWE types</h2><h3 id=lweciphertexttype>LWECiphertextType</h3><p>A type for LWE ciphertexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_ciphertext&lt;
  ::mlir::Attribute,   # encoding
  LWEParamsAttr   # lwe_params
&gt;
</code></pre><p>A type for LWE ciphertexts.</p><p>This type keeps track of the plaintext integer encoding for the LWE
Ciphertext to ensure proper decoding after decryption. It also keeps track
of the ring where the LWE ciphertext is defined, which provides information
on the ciphertext shape and the ring operations used in LWE operations.</p><h4 id=parameters-16>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr><tr><td style=text-align:center>lwe_params</td><td style=text-align:center><code>LWEParamsAttr</code></td><td></td></tr></tbody></table><h3 id=lweplaintexttype>LWEPlaintextType</h3><p>A type for LWE plaintexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_plaintext&lt;
  ::mlir::Attribute   # encoding
&gt;
</code></pre><p>A type for LWE plaintexts.</p><p>This type keeps track of the plaintext integer encoding for the LWE
plaintext before it is encrypted.</p><h4 id=parameters-17>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h3 id=newlweciphertexttype>NewLWECiphertextType</h3><p>A ciphertext type</p><p>Syntax:</p><pre tabindex=0><code>!lwe.new_lwe_ciphertext&lt;
  ApplicationDataAttr,   # application_data
  PlaintextSpaceAttr,   # plaintext_space
  CiphertextSpaceAttr,   # ciphertext_space
  KeyAttr,   # key
  ModulusChainAttr   # modulus_chain
&gt;
</code></pre><p>An LWE ciphertext will always contain the application data, plaintext space,
ciphertext space, and key information.</p><p>A modulus chain is optionally specified for parameter choices in RLWE
schemes that use more than one of modulus. When no modulus chain is
specified, the ciphertext modulus is always the ciphertext ring&rsquo;s
coefficient modulus.</p><h4 id=parameters-18>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>application_data</td><td style=text-align:center><code>ApplicationDataAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintext_space</td><td style=text-align:center><code>PlaintextSpaceAttr</code></td><td></td></tr><tr><td style=text-align:center>ciphertext_space</td><td style=text-align:center><code>CiphertextSpaceAttr</code></td><td></td></tr><tr><td style=text-align:center>key</td><td style=text-align:center><code>KeyAttr</code></td><td></td></tr><tr><td style=text-align:center>modulus_chain</td><td style=text-align:center><code>ModulusChainAttr</code></td><td></td></tr></tbody></table><h3 id=newlweplaintexttype>NewLWEPlaintextType</h3><p>A plaintext type</p><p>Syntax:</p><pre tabindex=0><code>!lwe.new_lwe_plaintext&lt;
  ApplicationDataAttr,   # application_data
  PlaintextSpaceAttr   # plaintext_space
&gt;
</code></pre><h4 id=parameters-19>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>application_data</td><td style=text-align:center><code>ApplicationDataAttr</code></td><td></td></tr><tr><td style=text-align:center>plaintext_space</td><td style=text-align:center><code>PlaintextSpaceAttr</code></td><td></td></tr></tbody></table><h3 id=newlwepublickeytype>NewLWEPublicKeyType</h3><p>A public key for LWE</p><p>Syntax:</p><pre tabindex=0><code>!lwe.new_lwe_public_key&lt;
  KeyAttr,   # key
  ::mlir::heir::polynomial::RingAttr   # ring
&gt;
</code></pre><h4 id=parameters-20>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>key</td><td style=text-align:center><code>KeyAttr</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr></tbody></table><h3 id=newlwesecretkeytype>NewLWESecretKeyType</h3><p>A secret key for LWE</p><p>Syntax:</p><pre tabindex=0><code>!lwe.new_lwe_secret_key&lt;
  KeyAttr,   # key
  ::mlir::heir::polynomial::RingAttr   # ring
&gt;
</code></pre><h4 id=parameters-21>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>key</td><td style=text-align:center><code>KeyAttr</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr></tbody></table><h3 id=rlweciphertexttype>RLWECiphertextType</h3><p>A type for RLWE ciphertexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.rlwe_ciphertext&lt;
  ::mlir::Attribute,   # encoding
  RLWEParamsAttr,   # rlwe_params
  Type   # underlying_type
&gt;
</code></pre><h4 id=parameters-22>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr><tr><td style=text-align:center>rlwe_params</td><td style=text-align:center><code>RLWEParamsAttr</code></td><td></td></tr><tr><td style=text-align:center>underlying_type</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=rlweplaintexttype>RLWEPlaintextType</h3><p>A type for RLWE plaintexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.rlwe_plaintext&lt;
  ::mlir::Attribute,   # encoding
  ::mlir::heir::polynomial::RingAttr,   # ring
  Type   # underlying_type
&gt;
</code></pre><h4 id=parameters-23>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td></td></tr><tr><td style=text-align:center>underlying_type</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=rlwepublickeytype>RLWEPublicKeyType</h3><p>A public key for RLWE</p><p>Syntax:</p><pre tabindex=0><code>!lwe.rlwe_public_key&lt;
  RLWEParamsAttr   # rlwe_params
&gt;
</code></pre><h4 id=parameters-24>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>rlwe_params</td><td style=text-align:center><code>RLWEParamsAttr</code></td><td></td></tr></tbody></table><h3 id=rlwesecretkeytype>RLWESecretKeyType</h3><p>A secret key for RLWE</p><p>Syntax:</p><pre tabindex=0><code>!lwe.rlwe_secret_key&lt;
  RLWEParamsAttr   # rlwe_params
&gt;
</code></pre><h4 id=parameters-25>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>rlwe_params</td><td style=text-align:center><code>RLWEParamsAttr</code></td><td></td></tr></tbody></table><h2 id=lwe-ops>LWE ops</h2><h3 id=lweadd-heirlweaddop><code>lwe.add</code> (heir::lwe::AddOp)</h3><p><em>Add two LWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.add` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h3 id=lweencode-heirlweencodeop><code>lwe.encode</code> (heir::lwe::EncodeOp)</h3><p><em>Encode an integer to yield an LWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.encode` $plaintext attr-dict `:` qualified(type($plaintext)) `to` qualified(type($output))
</code></pre><p>Encode an integer to yield an LWE plaintext.</p><p>This op uses a an encoding attribute to encode the bits of the integer into
an LWE plaintext value that can then be encrypted.</p><p>Examples:</p><pre tabindex=0><code>%Y = lwe.encode %value {encoding = #enc}: i1 to !lwe.lwe_plaintext&lt;encoding = #enc&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>encoding</code></td><td>::mlir::Attribute</td><td>An attribute describing encoded LWE plaintexts using bit fields. or An attribute describing unspecified bit field encodings.</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE plaintexts</td></tr></tbody></table><h3 id=lwemul_scalar-heirlwemulscalarop><code>lwe.mul_scalar</code> (heir::lwe::MulScalarOp)</h3><p><em>Multiply an LWE ciphertext by a scalar</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.mul_scalar` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ciphertext</code></td><td>ciphertext-like</td></tr><tr><td style=text-align:center><code>scalar</code></td><td>integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=lweradd-heirlweraddop><code>lwe.radd</code> (heir::lwe::RAddOp)</h3><p><em>Add two RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.radd` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=lwerlwe_decode-heirlwerlwedecodeop><code>lwe.rlwe_decode</code> (heir::lwe::RLWEDecodeOp)</h3><p><em>Decode an RLWE plaintext to an underlying type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_decode` $input attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>encoding</code></td><td>::mlir::Attribute</td><td>An attribute describing encoded RLWE plaintexts via coefficients. or An attribute describing encoded RLWE plaintexts via evaluations at fixed points. or An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.</td></tr><tr><td><code>ring</code></td><td>::mlir::heir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=lwerlwe_decrypt-heirlwerlwedecryptop><code>lwe.rlwe_decrypt</code> (heir::lwe::RLWEDecryptOp)</h3><p><em>Decrypt an RLWE ciphertext to a RLWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_decrypt` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Decrypt an RLWE ciphertext to yield a RLWE plaintext</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>secret_key</code></td><td>A secret key for RLWE</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h3 id=lwerlwe_encode-heirlwerlweencodeop><code>lwe.rlwe_encode</code> (heir::lwe::RLWEEncodeOp)</h3><p><em>Encode an integer to yield an RLWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_encode` $input attr-dict `:` qualified(type($input)) `-&gt;` qualified(type($output))
</code></pre><p>Encode an integer to yield an RLWE plaintext.</p><p>This op uses a an encoding attribute to encode the bits of the integer into
an RLWE plaintext value that can then be encrypted. CKKS cleartext inputs may
be floating points, and a scaling factor described by the encoding will be
applied.</p><p>Examples:</p><pre tabindex=0><code>%Y = lwe.rlwe_encode %value {encoding = #enc, ring = #ring}: i1 to !lwe.rlwe_plaintext&lt;encoding = #enc, ring = #ring&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>encoding</code></td><td>::mlir::Attribute</td><td>An attribute describing encoded RLWE plaintexts via coefficients. or An attribute describing encoded RLWE plaintexts via evaluations at fixed points. or An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.</td></tr><tr><td><code>ring</code></td><td>::mlir::heir::polynomial::RingAttr</td><td>an attribute specifying a polynomial ring</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless-integer-like or floating-point-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE plaintexts</td></tr></tbody></table><h3 id=lwerlwe_encrypt-heirlwerlweencryptop><code>lwe.rlwe_encrypt</code> (heir::lwe::RLWEEncryptOp)</h3><p><em>Encrypt an RLWE plaintext to a RLWE ciphertext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rlwe_encrypt` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Encrypt an RLWE plaintext to yield a RLWE ciphertext.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE plaintexts</td></tr><tr><td style=text-align:center><code>key</code></td><td>A secret key for RLWE or A public key for RLWE</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=lwermul-heirlwermulop><code>lwe.rmul</code> (heir::lwe::RMulOp)</h3><p><em>Multiplies two RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rmul` operands attr-dict `:`  functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>InferTypeOpAdaptor</code>, <code>SameTypeOperands</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=lwernegate-heirlwernegateop><code>lwe.rnegate</code> (heir::lwe::RNegateOp)</h3><p><em>Negate a RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rnegate` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>ciphertext-like</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ciphertext-like</td></tr></tbody></table><h3 id=lwersub-heirlwersubop><code>lwe.rsub</code> (heir::lwe::RSubOp)</h3><p><em>Subtract two RLWE ciphertexts</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.rsub` operands attr-dict `:` type($output)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for RLWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h3 id=lwetrivial_encrypt-heirlwetrivialencryptop><code>lwe.trivial_encrypt</code> (heir::lwe::TrivialEncryptOp)</h3><p><em>Create a trivial encryption of a plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.trivial_encrypt` operands attr-dict `:`  qualified(type(operands)) `to` qualified(type(results))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>params</code></td><td>::mlir::heir::lwe::LWEParamsAttr</td><td></td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for LWE plaintexts</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h3 id=lwereinterpret_underlying_type-heirlwereinterpretunderlyingtypeop><code>lwe.reinterpret_underlying_type</code> (heir::lwe::ReinterpretUnderlyingTypeOp)</h3><p><em>A placeholder cast from one ciphertext type to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.reinterpret_underlying_type` $input attr-dict `:` qualified(type($input)) `to` qualified(type($output))
</code></pre><p>The <code>cast</code> op is thus used to translate <code>underlying_type</code> between
ciphertexts in particular situations , such as when lowering to an API that
does not keep track of types for you.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for RLWE ciphertexts</td></tr></tbody></table></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/google/heir aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2024 The HEIR Authors All Rights Reserved</span>
<span class=ms-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.027d75d71824837bee74c12a7806c5fe51249c1ca7accc27553a251a75cdb3a4.js integrity="sha256-An111xgkg3vudMEqeAbF/lEknBynrMwnVTolGnXNs6Q=" crossorigin=anonymous></script>
<script defer src=/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>