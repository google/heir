<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.113.0"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Comb | HEIR</title><meta name=description content="&amp;lsquo;comb&amp;rsquo; Dialect Types and operations for comb dialect
This dialect defines the comb dialect, which is intended to be a generic representation of combinational logic outside of a particular use-case.
Operations comb.add (heir::comb::AddOp) Syntax:
operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result)) Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands
Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)
Effects: MemoryEffects::Effect{}
Attributes: AttributeMLIR TypeDescription twoState::mlir::UnitAttrunit attribute Operands: Operand Description inputs variadic of signless integer Results: Result Description result signless integer comb."><meta property="og:title" content="Comb"><meta property="og:description" content="&lsquo;comb&rsquo; Dialect Types and operations for comb dialect
This dialect defines the comb dialect, which is intended to be a generic representation of combinational logic outside of a particular use-case.
Operations comb.add (heir::comb::AddOp) Syntax:
operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result)) Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands
Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)
Effects: MemoryEffects::Effect{}
Attributes: AttributeMLIR TypeDescription twoState::mlir::UnitAttrunit attribute Operands: Operand Description inputs variadic of signless integer Results: Result Description result signless integer comb."><meta property="og:type" content="article"><meta property="og:url" content="https://heir.dev/docs/dialects/comb/"><meta property="article:section" content="docs"><meta itemprop=name content="Comb"><meta itemprop=description content="&lsquo;comb&rsquo; Dialect Types and operations for comb dialect
This dialect defines the comb dialect, which is intended to be a generic representation of combinational logic outside of a particular use-case.
Operations comb.add (heir::comb::AddOp) Syntax:
operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result)) Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands
Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)
Effects: MemoryEffects::Effect{}
Attributes: AttributeMLIR TypeDescription twoState::mlir::UnitAttrunit attribute Operands: Operand Description inputs variadic of signless integer Results: Result Description result signless integer comb."><meta itemprop=wordCount content="6007"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Comb"><meta name=twitter:description content="&lsquo;comb&rsquo; Dialect Types and operations for comb dialect
This dialect defines the comb dialect, which is intended to be a generic representation of combinational logic outside of a particular use-case.
Operations comb.add (heir::comb::AddOp) Syntax:
operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result)) Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands
Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)
Effects: MemoryEffects::Effect{}
Attributes: AttributeMLIR TypeDescription twoState::mlir::UnitAttrunit attribute Operands: Operand Description inputs variadic of signless integer Results: Result Description result signless integer comb."><link rel=preload href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css as=style><link href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=td-page><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="32" height="32" fill="#fff" fill-opacity=".01"/><path d="M18.6889 10.124l7.7916 5.0511 2.6263-1.6684-2.6146-1.6779-7.8033-4.96754 2.8526 1.84162L18.6889 10.124z" fill="#efcf6f"/><path d="M29.1185 6.86125 18.6979.13981 16.06 1.79876 26.4922 8.52025l2.6263-1.659z" fill="#efcf6f"/><path d="M8.2405 6.74134 5.60033 5.07291 3.05751 6.79935 5.67334 8.49344 8.2405 6.74134z" fill="#ee958a"/><path d="M10.8697 8.49344 8.2405 10.124v3.3995l5.2049-3.3348-2.5757-1.69526z" fill="#ee958a"/><path d="M5.67334 8.49344 3.05751 6.79935 3.03318 23.4932l2.64016 1.6897V8.49344z" fill="#a32e24"/><path d="M29.1185 6.86126 26.4922 8.52025V11.8288l2.6263-1.6401V6.86126z" fill="#d38041"/><path d="M21.5415 8.70288 18.6889 6.86126V10.124l2.8526-1.42112z" fill="#d38041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M8.2405 6.74134V10.124v3.3995l5.2049-3.3348V3.58723l2.6145-1.7885L16.1123 11.8484V18.467l-2.6158 1.6181L13.4574 13.5235 10.849 15.1694 8.2405 16.8152v6.678L5.67334 25.1829V8.49344L8.2405 6.74134z" fill="#dd583b"/><path d="M13.4965 20.0851 13.4574 13.5235 10.849 15.1694 10.8077 18.467l2.6888 1.6181z" fill="#a32e24"/><path fill-rule="evenodd" clip-rule="evenodd" d="M13.4454 3.58723V10.1887L10.8697 8.49344 10.9293 1.79873l2.5161 1.7885z" fill="#a32e24"/><path d="M16.0599 1.79873 13.4454.13981 10.9293 1.79873l2.5161 1.7885 2.6145-1.7885z" fill="#ee958a"/><path d="M16.06 1.79876 16.0793 5.52165 16.1123 11.8484V18.467l2.5766-1.6518V13.4696 10.124 6.86126l7.8033 4.96754V8.52025L16.06 1.79876z" fill="#e5ad11"/><path d="M18.6889 16.8152 16.1123 18.467l10.3682 6.7159V21.8372l-7.7916-5.022z" fill="#e5ad11"/><path d="M26.4805 15.1751 18.6889 10.124v3.3456l2.7505 1.7641 5.0411 3.2333V15.1751z" fill="#e5ad11"/><path d="M29.1068 13.5067l-2.6263 1.6684V18.467l2.6263-1.6518V13.5067z" fill="#d48041"/><path d="M29.1185 20.0851l-2.638 1.7521v3.3457l2.6263-1.6897L29.1185 20.0851z" fill="#d48041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M26.4805 21.8372l-7.7916-5.022 2.7505-1.5815 5.0411 3.2333 2.638 1.6181-2.638 1.7521z" fill="#efcf6f"/><path d="M18.6889 13.4696v3.3456l2.7505-1.5815-2.7505-1.7641z" fill="#d48041"/><path d="M20.1621 26.5165l-4.2015-2.7017-4.2015-2.7016L11.7108 23.8491l6.3384 4.0776 2.1129 1.3512V26.5165z" fill="#395aad"/><path d="M7.49852 23.8491v2.6674l8.41958 5.4439V29.2779L7.49852 23.8491z" fill="#276e3a"/><path d="M9.57951 22.4781l-2.08099 1.371 8.41958 5.4288 2.1311-1.3512-6.3384-4.0776-2.13129-1.371z" fill="#add284"/><path d="M24.3747 26.5165V23.8491L22.174 22.8377l-2.0054.9665 2.1815 1.3793 2.0246 1.333z" fill="#395aad"/><path d="M18.0492 19.7061l2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#395aad"/><path fill-rule="evenodd" clip-rule="evenodd" d="M20.1621 18.4432l-2.0415-.596-2.1581.596-2.1017 1.3349-2.1017 1.3351 2.1012 1.3511 6.3018 4.0522 2.188-1.333-2.1815-1.3793 2.0054-.9665 2.2007 1.0114 2.0995-1.329-2.0811-1.4069L22.3501 21.1371l-.1752-1.4237L22.174 19.7061l-2.0119-1.2629zm-2.1129 1.2629 2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#9ec4e0"/><path d="M26.4742 22.5201l-2.0995 1.329v2.6674l2.1289-1.3305L26.4742 22.5201z" fill="#4285f4"/><path d="M20.1621 26.5165v2.7614l2.188-1.3512V25.1835l-2.188 1.333z" fill="#4285f4"/><path d="M15.9181 29.2779v2.6825l2.1311-1.3708V27.9267l-2.1311 1.3512z" fill="#4e9c68"/></svg></span><span class=navbar-brand__name>HEIR</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/><span>Home</span></a></li><li class=nav-item><a class="nav-link active" href=/docs/><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://github.com/google/heir/ target=_blank rel=noopener><span>GitHub</span></a></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ms-3 fas fa-bars" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="collapse td-sidebar-nav" id=td-section-nav><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m--li><a href=/ title="HEIR: Homomorphic Encryption Intermediate Representation" class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-><span>Home</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-docs-li><a href=/docs/ title=Documentation class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docs><span>Docs</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsgetting_started-li><a href=/docs/getting_started/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsgetting_started><span>Getting Started</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-docsdevelopment-li><a href=/docs/development/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsdevelopment><span>Development</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdevelopmentbazel-li><a href=/docs/development/bazel/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdevelopmentbazel><span>Bazel tips</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdevelopmentboilerplate-li><a href=/docs/development/boilerplate/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdevelopmentboilerplate><span>Boilerplate tools</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdevelopmentide-li><a href=/docs/development/ide/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdevelopmentide><span>IDE configuration</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docstutorials-li><a href=/docs/tutorials/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docstutorials><span>Tutorials and Talks</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsresearch_with_heir-li><a href=/docs/research_with_heir/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsresearch_with_heir><span>Research with HEIR</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-docsdesign-li><a href=/docs/design/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsdesign><span>Design</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesignmanagement-li><a href=/docs/design/management/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignmanagement><span>Ciphertext Management</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesigndo_transformation-li><a href=/docs/design/do_transformation/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesigndo_transformation><span>Data-oblivious Transformations</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesignnoise-li><a href=/docs/design/noise/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignnoise><span>Noise Analysis</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesignsecret-li><a href=/docs/design/secret/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignsecret><span>Secret</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesignsimd-li><a href=/docs/design/simd/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignsimd><span>SIMD Optimizations</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdesignrelinearization_ilp-li><a href=/docs/design/relinearization_ilp/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignrelinearization_ilp><span>Optimizing relinearization</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docspipelines-li><a href=/docs/pipelines/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docspipelines><span>Pipelines</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-docsdialects-li><a href=/docs/dialects/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsdialects><span>Dialects</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsbgv-li><a href=/docs/dialects/bgv/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsbgv><span>BGV</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectscggi-li><a href=/docs/dialects/cggi/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectscggi><span>CGGI</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsckks-li><a href=/docs/dialects/ckks/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsckks><span>CKKS</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-docsdialectscomb-li><a href=/docs/dialects/comb/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-docsdialectscomb><span class=td-sidebar-nav-active-item>Comb</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsjaxite-li><a href=/docs/dialects/jaxite/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsjaxite><span>Jaxite</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsjaxiteword-li><a href=/docs/dialects/jaxiteword/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsjaxiteword><span>JaxiteWord</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectslattigo-li><a href=/docs/dialects/lattigo/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectslattigo><span>Lattigo</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectslwe-li><a href=/docs/dialects/lwe/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectslwe><span>LWE</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsmathext-li><a href=/docs/dialects/mathext/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsmathext><span>MathExt</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsmgmt-li><a href=/docs/dialects/mgmt/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsmgmt><span>Mgmt</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsmodarith-li><a href=/docs/dialects/modarith/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsmodarith><span>ModArith</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsopenfhe-li><a href=/docs/dialects/openfhe/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsopenfhe><span>Openfhe</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectspolynomial-li><a href=/docs/dialects/polynomial/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectspolynomial><span>Polynomial</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsrandom-li><a href=/docs/dialects/random/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsrandom><span>Random</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectsrns-li><a href=/docs/dialects/rns/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsrns><span>RNS</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectssecret-li><a href=/docs/dialects/secret/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectssecret><span>Secret</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectstensorext-li><a href=/docs/dialects/tensorext/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectstensorext><span>TensorExt</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectstfherust-li><a href=/docs/dialects/tfherust/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectstfherust><span>TfheRust</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdialectstfherustbool-li><a href=/docs/dialects/tfherustbool/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectstfherustbool><span>TfheRustBool</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docspasses-li><a href=/docs/passes/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docspasses><span>Passes</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-community-li><a href=/community/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-community><span>Community</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-search-li><a href=/search/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-search><span>Search Results</span></a></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ms-2 pb-1 pt-2 mb-0"><a href=https://github.com/google/heir/edit/main/lib/Dialect/Comb/IR target=_blank><i class="fa-solid fa-pen-to-square fa-fw"></i> Edit this page</a>
<a id=print href=https://heir.dev/docs/dialects/_print/><i class="fa-solid fa-print fa-fw"></i> Print entire section</a></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#combadd-heircombaddop><code>comb.add</code> (heir::comb::AddOp)</a></li><li><a href=#comband-heircombandop><code>comb.and</code> (heir::comb::AndOp)</a></li><li><a href=#combconcat-heircombconcatop><code>comb.concat</code> (heir::comb::ConcatOp)</a></li><li><a href=#combextract-heircombextractop><code>comb.extract</code> (heir::comb::ExtractOp)</a></li><li><a href=#combicmp-heircombicmpop><code>comb.icmp</code> (heir::comb::ICmpOp)</a></li><li><a href=#combinv-heircombinvop><code>comb.inv</code> (heir::comb::InvOp)</a></li><li><a href=#comblut-heircomblutop><code>comb.lut</code> (heir::comb::LUTOp)</a></li><li><a href=#combmul-heircombmulop><code>comb.mul</code> (heir::comb::MulOp)</a></li><li><a href=#combmux-heircombmuxop><code>comb.mux</code> (heir::comb::MuxOp)</a></li><li><a href=#combnand-heircombnandop><code>comb.nand</code> (heir::comb::NandOp)</a></li><li><a href=#combnor-heircombnorop><code>comb.nor</code> (heir::comb::NorOp)</a></li><li><a href=#combor-heircomborop><code>comb.or</code> (heir::comb::OrOp)</a></li><li><a href=#combparity-heircombparityop><code>comb.parity</code> (heir::comb::ParityOp)</a></li><li><a href=#combreplicate-heircombreplicateop><code>comb.replicate</code> (heir::comb::ReplicateOp)</a></li><li><a href=#combtruth_table-heircombtruthtableop><code>comb.truth_table</code> (heir::comb::TruthTableOp)</a></li><li><a href=#combxnor-heircombxnorop><code>comb.xnor</code> (heir::comb::XNorOp)</a></li><li><a href=#combxor-heircombxorop><code>comb.xor</code> (heir::comb::XorOp)</a></li></ul></li><li><a href=#enums>Enums</a><ul><li><a href=#icmppredicate>ICmpPredicate</a></li></ul></li><li><a href=#comb-types>Comb types</a><ul><li><a href=#bfloat16type>BFloat16Type</a></li><li><a href=#complextype>ComplexType</a></li><li><a href=#float4e2m1fntype>Float4E2M1FNType</a></li><li><a href=#float6e2m3fntype>Float6E2M3FNType</a></li><li><a href=#float6e3m2fntype>Float6E3M2FNType</a></li><li><a href=#float8e3m4type>Float8E3M4Type</a></li><li><a href=#float8e4m3type>Float8E4M3Type</a></li><li><a href=#float8e4m3b11fnuztype>Float8E4M3B11FNUZType</a></li><li><a href=#float8e4m3fntype>Float8E4M3FNType</a></li><li><a href=#float8e4m3fnuztype>Float8E4M3FNUZType</a></li><li><a href=#float8e5m2type>Float8E5M2Type</a></li><li><a href=#float8e5m2fnuztype>Float8E5M2FNUZType</a></li><li><a href=#float8e8m0fnutype>Float8E8M0FNUType</a></li><li><a href=#float16type>Float16Type</a></li><li><a href=#float32type>Float32Type</a></li><li><a href=#float64type>Float64Type</a></li><li><a href=#float80type>Float80Type</a></li><li><a href=#float128type>Float128Type</a></li><li><a href=#floattf32type>FloatTF32Type</a></li><li><a href=#functiontype>FunctionType</a></li><li><a href=#graphtype>GraphType</a></li><li><a href=#indextype>IndexType</a></li><li><a href=#integertype>IntegerType</a></li><li><a href=#memreftype>MemRefType</a></li><li><a href=#nonetype>NoneType</a></li><li><a href=#opaquetype>OpaqueType</a></li><li><a href=#rankedtensortype>RankedTensorType</a></li><li><a href=#tupletype>TupleType</a></li><li><a href=#unrankedmemreftype>UnrankedMemRefType</a></li><li><a href=#unrankedtensortype>UnrankedTensorType</a></li><li><a href=#vectortype>VectorType</a></li></ul></li><li><a href=#comb-ops>Comb ops</a><ul><li><a href=#combadd-heircombaddop-1><code>comb.add</code> (heir::comb::AddOp)</a></li><li><a href=#comband-heircombandop-1><code>comb.and</code> (heir::comb::AndOp)</a></li><li><a href=#combconcat-heircombconcatop-1><code>comb.concat</code> (heir::comb::ConcatOp)</a></li><li><a href=#combextract-heircombextractop-1><code>comb.extract</code> (heir::comb::ExtractOp)</a></li><li><a href=#combicmp-heircombicmpop-1><code>comb.icmp</code> (heir::comb::ICmpOp)</a></li><li><a href=#combinv-heircombinvop-1><code>comb.inv</code> (heir::comb::InvOp)</a></li><li><a href=#comblut-heircomblutop-1><code>comb.lut</code> (heir::comb::LUTOp)</a></li><li><a href=#combmul-heircombmulop-1><code>comb.mul</code> (heir::comb::MulOp)</a></li><li><a href=#combmux-heircombmuxop-1><code>comb.mux</code> (heir::comb::MuxOp)</a></li><li><a href=#combnand-heircombnandop-1><code>comb.nand</code> (heir::comb::NandOp)</a></li><li><a href=#combnor-heircombnorop-1><code>comb.nor</code> (heir::comb::NorOp)</a></li><li><a href=#combor-heircomborop-1><code>comb.or</code> (heir::comb::OrOp)</a></li><li><a href=#combparity-heircombparityop-1><code>comb.parity</code> (heir::comb::ParityOp)</a></li><li><a href=#combreplicate-heircombreplicateop-1><code>comb.replicate</code> (heir::comb::ReplicateOp)</a></li><li><a href=#combtruth_table-heircombtruthtableop-1><code>comb.truth_table</code> (heir::comb::TruthTableOp)</a></li><li><a href=#combxnor-heircombxnorop-1><code>comb.xnor</code> (heir::comb::XNorOp)</a></li><li><a href=#combxor-heircombxorop-1><code>comb.xor</code> (heir::comb::XorOp)</a></li></ul></li><li><a href=#comb-additional-definitions>Comb additional definitions</a><ul><li><a href=#icmppredicate-1>ICmpPredicate</a></li></ul></li></ul></nav></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=https://heir.dev/docs/>Docs</a></li><li class=breadcrumb-item><a href=https://heir.dev/docs/dialects/>Dialects</a></li><li class="breadcrumb-item active" aria-current=page>Comb</li></ol></nav><div class=td-content><h1>Comb</h1><header class=article-meta></header><h1 id=comb-dialect>&lsquo;comb&rsquo; Dialect</h1><p><em>Types and operations for comb dialect</em></p><p>This dialect defines the <code>comb</code> dialect, which is intended to be a generic
representation of combinational logic outside of a particular use-case.</p><h2 id=operations>Operations</h2><h3 id=combadd-heircombaddop><code>comb.add</code> (heir::comb::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comband-heircombandop><code>comb.and</code> (heir::comb::AndOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combconcat-heircombconcatop><code>comb.concat</code> (heir::comb::ConcatOp)</h3><p><em>Concatenate a variadic list of operands together.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
</code></pre><p>See the comb rationale document for details on operand ordering.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combextract-heircombextractop><code>comb.extract</code> (heir::comb::ExtractOp)</h3><p><em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combicmp-heircombicmpop><code>comb.icmp</code> (heir::comb::ICmpOp)</h3><p><em>Compare two integer values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre tabindex=0><code>    %r = comb.icmp eq %a, %b : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::heir::comb::ICmpPredicateAttr</td><td>hw.icmp comparison predicate</td></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combinv-heircombinvop><code>comb.inv</code> (heir::comb::InvOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comblut-heircomblutop><code>comb.lut</code> (heir::comb::LUTOp)</h3><p><em>Return an integer based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.lut` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation is similar to <code>truth_table</code>, but it allows for an integer output instead of a boolean.
Requers an vector of integers as the lookup table, where each integer represents the output for a specific combination of inputs.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr><tr><td><code>lookupTable</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 8-bit signless integer</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8-bit signless integer</td></tr></tbody></table><h3 id=combmul-heircombmulop><code>comb.mul</code> (heir::comb::MulOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmux-heircombmuxop><code>comb.mux</code> (heir::comb::MuxOp)</h3><p><em>Return one or the other operand depending on a selector bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))
</code></pre><pre tabindex=0><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=combnand-heircombnandop><code>comb.nand</code> (heir::comb::NandOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combnor-heircombnorop><code>comb.nor</code> (heir::comb::NorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combor-heircomborop><code>comb.or</code> (heir::comb::OrOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combparity-heircombparityop><code>comb.parity</code> (heir::comb::ParityOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combreplicate-heircombreplicateop><code>comb.replicate</code> (heir::comb::ReplicateOp)</h3><p><em>Concatenate the operand a constant number of times</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combtruth_table-heircombtruthtableop><code>comb.truth_table</code> (heir::comb::TruthTableOp)</h3><p><em>Return a true/false based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.truth_table` $inputs `-&gt;` $lookupTable attr-dict
</code></pre><pre tabindex=0><code>  %a = ... : i1
  %b = ... : i1
  %0 = comb.truth_table %a, %b -&gt; 6 : ui4
</code></pre><p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -> LSB from left
to right and the offset into <code>lookupTable</code> is computed from them. The
integer containing the truth table value&rsquo;s LSB is the output for the input
&ldquo;all false&rdquo;, and the MSB is the output for the input &ldquo;all true&rdquo;.</p><p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &lsquo;x&rsquo; &ndash; it should be the well-known result.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookupTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combxnor-heircombxnorop><code>comb.xnor</code> (heir::comb::XNorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combxor-heircombxorop><code>comb.xor</code> (heir::comb::XorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h2 id=enums>Enums</h2><h3 id=icmppredicate>ICmpPredicate</h3><p><em>Hw.icmp comparison predicate</em></p><h4 id=cases>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>eq</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>ne</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>slt</td><td style=text-align:center><code>2</code></td><td>slt</td></tr><tr><td style=text-align:center>sle</td><td style=text-align:center><code>3</code></td><td>sle</td></tr><tr><td style=text-align:center>sgt</td><td style=text-align:center><code>4</code></td><td>sgt</td></tr><tr><td style=text-align:center>sge</td><td style=text-align:center><code>5</code></td><td>sge</td></tr><tr><td style=text-align:center>ult</td><td style=text-align:center><code>6</code></td><td>ult</td></tr><tr><td style=text-align:center>ule</td><td style=text-align:center><code>7</code></td><td>ule</td></tr><tr><td style=text-align:center>ugt</td><td style=text-align:center><code>8</code></td><td>ugt</td></tr><tr><td style=text-align:center>uge</td><td style=text-align:center><code>9</code></td><td>uge</td></tr><tr><td style=text-align:center>ceq</td><td style=text-align:center><code>10</code></td><td>ceq</td></tr><tr><td style=text-align:center>cne</td><td style=text-align:center><code>11</code></td><td>cne</td></tr><tr><td style=text-align:center>weq</td><td style=text-align:center><code>12</code></td><td>weq</td></tr><tr><td style=text-align:center>wne</td><td style=text-align:center><code>13</code></td><td>wne</td></tr></tbody></table><h2 id=comb-types>Comb types</h2><h3 id=bfloat16type>BFloat16Type</h3><p><em>Bfloat16 floating-point type</em></p><h3 id=complextype>ComplexType</h3><p><em>Complex number with a parameterized element type</em></p><p>Syntax:</p><pre tabindex=0><code>complex-type ::= `complex` `&lt;` type `&gt;`
</code></pre><p>The value of <code>complex</code> type represents a complex number with a parameterized
element type, which is composed of a real and imaginary value of that
element type. The element must be a floating point or integer scalar type.</p><h4 id=example>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>complex<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>complex<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=float4e2m1fntype>Float4E2M1FNType</h3><p><em>4-bit floating point with 2-bit exponent and 1-bit mantissa</em></p><p>An 4-bit floating point type with 1 sign bit, 2 bits exponent and 1 bit
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E2M1</li><li>exponent bias: 1</li><li>infinities: Not supported</li><li>NaNs: Not supported</li><li>denormals when exponent is 0</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float6e2m3fntype>Float6E2M3FNType</h3><p><em>6-bit floating point with 2-bit exponent and 3-bit mantissa</em></p><p>An 6-bit floating point type with 1 sign bit, 2 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E2M3</li><li>exponent bias: 1</li><li>infinities: Not supported</li><li>NaNs: Not supported</li><li>denormals when exponent is 0</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float6e3m2fntype>Float6E3M2FNType</h3><p><em>6-bit floating point with 3-bit exponent and 2-bit mantissa</em></p><p>An 6-bit floating point type with 1 sign bit, 3 bits exponent and 2 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E3M2</li><li>exponent bias: 3</li><li>infinities: Not supported</li><li>NaNs: Not supported</li><li>denormals when exponent is 0</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float8e3m4type>Float8E3M4Type</h3><p><em>8-bit floating point with 3 bits exponent and 4 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 3 bits exponent and 4 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E3M4</li><li>exponent bias: 3</li><li>infinities: supported with exponent set to all 1s and mantissa 0s</li><li>NaNs: supported with exponent bits set to all 1s and mantissa values of
{0,1}⁴ except S.111.0000</li><li>denormals when exponent is 0</li></ul><h3 id=float8e4m3type>Float8E4M3Type</h3><p><em>8-bit floating point with 3 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 7</li><li>infinities: supported with exponent set to all 1s and mantissa 0s</li><li>NaNs: supported with exponent bits set to all 1s and mantissa of
(001, 010, 011, 100, 101, 110, 111)</li><li>denormals when exponent is 0</li></ul><h3 id=float8e4m3b11fnuztype>Float8E4M3B11FNUZType</h3><p><em>8-bit floating point with 3 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values,
no negative zero, and only one NaN representation. This type has the
following characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 11</li><li>infinities: Not supported</li><li>NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s</li><li>denormals when exponent is 0</li></ul><p>Related to: <a href=https://dl.acm.org/doi/10.5555/3454287.3454728>https://dl.acm.org/doi/10.5555/3454287.3454728</a></p><h3 id=float8e4m3fntype>Float8E4M3FNType</h3><p><em>8-bit floating point with 3 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values
and only two NaN representations. This type has the following
characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 7</li><li>infinities: Not supported</li><li>NaNs: supported with exponent bits and mantissa bits set to all 1s</li><li>denormals when exponent is 0</li></ul><p>Described in: <a href=https://arxiv.org/abs/2209.05433>https://arxiv.org/abs/2209.05433</a></p><h3 id=float8e4m3fnuztype>Float8E4M3FNUZType</h3><p><em>8-bit floating point with 3 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values,
no negative zero, and only one NaN representation. This type has the
following characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 8</li><li>infinities: Not supported</li><li>NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s</li><li>denormals when exponent is 0</li></ul><p>Described in: <a href=https://arxiv.org/abs/2209.05433>https://arxiv.org/abs/2209.05433</a></p><h3 id=float8e5m2type>Float8E5M2Type</h3><p><em>8-bit floating point with 2 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 5 bits exponent and 2 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E5M2</li><li>exponent bias: 15</li><li>infinities: supported with exponent set to all 1s and mantissa 0s</li><li>NaNs: supported with exponent bits set to all 1s and mantissa of
(01, 10, or 11)</li><li>denormals when exponent is 0</li></ul><p>Described in: <a href=https://arxiv.org/abs/2209.05433>https://arxiv.org/abs/2209.05433</a></p><h3 id=float8e5m2fnuztype>Float8E5M2FNUZType</h3><p><em>8-bit floating point with 2 bit mantissa</em></p><p>An 8-bit floating point type with 1 sign bit, 5 bits exponent and 2 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values,
no negative zero, and only one NaN representation. This type has the
following characteristics:</p><ul><li>bit encoding: S1E5M2</li><li>exponent bias: 16</li><li>infinities: Not supported</li><li>NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s</li><li>denormals when exponent is 0</li></ul><p>Described in: <a href=https://arxiv.org/abs/2206.02915>https://arxiv.org/abs/2206.02915</a></p><h3 id=float8e8m0fnutype>Float8E8M0FNUType</h3><p><em>8-bit floating point with 8-bit exponent, no mantissa or sign</em></p><p>An 8-bit floating point type with no sign bit, 8 bits exponent and no
mantissa. This is not a standard type as defined by IEEE-754; it is intended
to be used for representing scaling factors, so it cannot represent zeros
and negative numbers. The values it can represent are powers of two in the
range [-127,127] and NaN.</p><ul><li>bit encoding: S0E8M0</li><li>exponent bias: 127</li><li>infinities: Not supported</li><li>NaNs: Supported with all bits set to 1</li><li>denormals: Not supported</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float16type>Float16Type</h3><p><em>16-bit floating-point type</em></p><h3 id=float32type>Float32Type</h3><p><em>32-bit floating-point type</em></p><h3 id=float64type>Float64Type</h3><p><em>64-bit floating-point type</em></p><h3 id=float80type>Float80Type</h3><p><em>80-bit floating-point type</em></p><h3 id=float128type>Float128Type</h3><p><em>128-bit floating-point type</em></p><h3 id=floattf32type>FloatTF32Type</h3><p><em>TF32 floating-point type</em></p><h3 id=functiontype>FunctionType</h3><p><em>Map from a list of inputs to a list of results</em></p><p>Syntax:</p><pre tabindex=0><code>// Function types may have multiple results.
function-result-type ::= type-list-parens | non-function-type
function-type ::= type-list-parens `-&gt;` function-result-type
</code></pre><p>The function type can be thought of as a function signature. It consists of
a list of formal parameter types and a list of formal result types.</p><h4 id=example-1>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@add_one</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i64</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>inputs</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr><tr><td style=text-align:center>results</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=graphtype>GraphType</h3><p><em>Map from a list of inputs to a list of results</em></p><p>Syntax:</p><pre tabindex=0><code>// Function types may have multiple results.
function-result-type ::= type-list-parens | non-function-type
function-type ::= type-list-parens `-&gt;` function-result-type
</code></pre><p>The function type can be thought of as a function signature. It consists of
a list of formal parameter types and a list of formal result types.</p><h4 id=example-2>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@add_one</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i64</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>inputs</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr><tr><td style=text-align:center>results</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=indextype>IndexType</h3><p><em>Integer-like type with unknown platform-dependent bit width</em></p><p>Syntax:</p><pre tabindex=0><code>// Target word-sized integer.
index-type ::= `index`
</code></pre><p>The index type is a signless integer whose size is equal to the natural
machine word of the target ( <a href=../../Rationale/Rationale/#integer-signedness-semantics>rationale</a> )
and is used by the affine constructs in MLIR.</p><p><strong>Rationale:</strong> integers of platform-specific bit widths are practical to
express sizes, dimensionalities and subscripts.</p><h3 id=integertype>IntegerType</h3><p><em>Integer type with arbitrary precision up to a fixed limit</em></p><p>Syntax:</p><pre tabindex=0><code>// Sized integers like i1, i4, i8, i16, i32.
signed-integer-type ::= `si` [1-9][0-9]*
unsigned-integer-type ::= `ui` [1-9][0-9]*
signless-integer-type ::= `i` [1-9][0-9]*
integer-type ::= signed-integer-type |
                 unsigned-integer-type |
                 signless-integer-type
</code></pre><p>Integer types have a designated bit width and may optionally have signedness
semantics.</p><p><strong>Rationale:</strong> low precision integers (like <code>i2</code>, <code>i4</code> etc) are useful for
low-precision inference chips, and arbitrary precision integers are useful
for hardware synthesis (where a 13 bit multiplier is a lot cheaper/smaller
than a 16 bit one).</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>width</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>signedness</td><td style=text-align:center><code>SignednessSemantics</code></td><td></td></tr></tbody></table><h3 id=memreftype>MemRefType</h3><p><em>Shaped reference to a region of memory</em></p><p>Syntax:</p><pre tabindex=0><code>layout-specification ::= attribute-value
memory-space ::= attribute-value
memref-type ::= `memref` `&lt;` dimension-list-ranked type
                (`,` layout-specification)? (`,` memory-space)? `&gt;`
</code></pre><p>A <code>memref</code> type is a reference to a region of memory (similar to a buffer
pointer, but more powerful). The buffer pointed to by a memref can be
allocated, aliased and deallocated. A memref can be used to read and write
data from/to the memory region which it references. Memref types use the
same shape specifier as tensor types. Note that <code>memref&lt;f32></code>,
<code>memref&lt;0 x f32></code>, <code>memref&lt;1 x 0 x f32></code>, and <code>memref&lt;0 x 1 x f32></code> are all
different types.</p><p>A <code>memref</code> is allowed to have an unknown rank (e.g. <code>memref&lt;*xf32></code>). The
purpose of unranked memrefs is to allow external library functions to
receive memref arguments of any rank without versioning the functions based
on the rank. Other uses of this type are disallowed or will have undefined
behavior.</p><p>Are accepted as elements:</p><ul><li>built-in integer types;</li><li>built-in index type;</li><li>built-in floating point types;</li><li>built-in vector types with elements of the above types;</li><li>another memref type;</li><li>any other type implementing <code>MemRefElementTypeInterface</code>.</li></ul><h5 id=layout>Layout</h5><p>A memref may optionally have a layout that indicates how indices are
transformed from the multi-dimensional form into a linear address. The
layout must avoid internal aliasing, i.e., two distinct tuples of
<em>in-bounds</em> indices must be pointing to different elements in memory. The
layout is an attribute that implements <code>MemRefLayoutAttrInterface</code>. The
bulitin dialect offers two kinds of layouts: strided and affine map, each
of which is available as an attribute. Other attributes may be used to
represent the layout as long as they can be converted to a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a> and implement the required
interface. Users of memref are expected to fallback to the affine
representation when handling unknown memref layouts. Multi-dimensional
affine forms are interpreted in <em>row-major</em> fashion.</p><p>In absence of an explicit layout, a memref is considered to have a
multi-dimensional identity affine map layout. Identity layout maps do not
contribute to the MemRef type identification and are discarded on
construction. That is, a type with an explicit identity map is
<code>memref&lt;?x?xf32, (i,j)->(i,j)></code> is strictly the same as the one without a
layout, <code>memref&lt;?x?xf32></code>.</p><h5 id=affine-map-layout>Affine Map Layout</h5><p>The layout may be represented directly as an affine map from the index space
to the storage space. For example, the following figure shows an index map
which maps a 2-dimensional index from a 2x2 index space to a 3x3 index
space, using symbols <code>S0</code> and <code>S1</code> as offsets.</p><p><img src=/includes/img/index-map.svg alt="Index Map Example"></p><p>Semi-affine maps are sufficiently flexible to represent a wide variety of
dense storage layouts, including row- and column-major and tiled:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// MxN matrix stored in row major layout in memory:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#layout_map_row_major</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span>i<span style=color:#000;font-weight:700>,</span> j<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>i<span style=color:#000;font-weight:700>,</span> j<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// MxN matrix stored in column major layout in memory:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#layout_map_col_major</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span>i<span style=color:#000;font-weight:700>,</span> j<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>j<span style=color:#000;font-weight:700>,</span> i<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// MxN matrix stored in a 2-d blocked/tiled layout with 64x64 tiles.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#layout_tiled</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span>i<span style=color:#000;font-weight:700>,</span> j<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>i floordiv <span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>,</span> j floordiv <span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>,</span> i mod <span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>,</span> j mod <span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><h5 id=strided-layout>Strided Layout</h5><p>Memref layout can be expressed using strides to encode the distance, in
number of elements, in (linear) memory between successive entries along a
particular dimension. For example, a row-major strided layout for
<code>memref&lt;2x3x4xf32></code> is <code>strided&lt;[12, 4, 1]></code>, where the last dimension is
contiguous as indicated by the unit stride and the remaining strides are
products of the sizes of faster-variying dimensions. Strided layout can also
express non-contiguity, e.g., <code>memref&lt;2x3, strided&lt;[6, 2]>></code> only accesses
even elements of the dense consecutive storage along the innermost
dimension.</p><p>The strided layout supports an optional <em>offset</em> that indicates the
distance, in the number of elements, between the beginning of the memref
and the first accessed element. When omitted, the offset is considered to
be zero. That is, <code>memref&lt;2, strided&lt;[2], offset: 0>></code> and
<code>memref&lt;2, strided&lt;[2]>></code> are strictly the same type.</p><p>Both offsets and strides may be <em>dynamic</em>, that is, unknown at compile time.
This is represented by using a question mark (<code>?</code>) instead of the value in
the textual form of the IR.</p><p>The strided layout converts into the following canonical one-dimensional
affine form through explicit linearization:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>...</span> dN<span style=color:#000;font-weight:700>)[</span>offset<span style=color:#000;font-weight:700>,</span> stride0<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>...</span> strideN<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>(</span>offset <span style=color:#a40000>+</span> d0 <span style=color:#000;font-weight:700>*</span> stride0 <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>...</span> dN <span style=color:#000;font-weight:700>*</span> strideN<span style=color:#000;font-weight:700>)&gt;</span>
</span></span></code></pre></div><p>Therefore, it is never subject to the implicit row-major layout
interpretation.</p><h5 id=codegen-of-unranked-memref>Codegen of Unranked Memref</h5><p>Using unranked memref in codegen besides the case mentioned above is highly
discouraged. Codegen is concerned with generating loop nests and specialized
instructions for high-performance, unranked memref is concerned with hiding
the rank and thus, the number of enclosing loops required to iterate over
the data. However, if there is a need to code-gen unranked memref, one
possible path is to cast into a static ranked type based on the dynamic
rank. Another possible path is to emit a single while loop conditioned on a
linear index and perform delinearization of the linear index to a dynamic
array containing the (unranked) indices. While this is possible, it is
expected to not be a good idea to perform this during codegen as the cost
of the translations is expected to be prohibitive and optimizations at this
level are not expected to be worthwhile. If expressiveness is the main
concern, irrespective of performance, passing unranked memrefs to an
external C++ library and implementing rank-agnostic logic there is expected
to be significantly simpler.</p><p>Unranked memrefs may provide expressiveness gains in the future and help
bridge the gap with unranked tensors. Unranked memrefs will not be expected
to be exposed to codegen but one may query the rank of an unranked memref
(a special op will be needed for this purpose) and perform a switch and cast
to a ranked memref as a prerequisite to codegen.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// With static ranks, we need a function for each possible argument type
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%A</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%B</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>call <span style=color:#000>@helper_2D</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%A</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;)-&gt;()</span>
</span></span><span style=display:flex><span>call <span style=color:#000>@helper_3D</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%B</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;)-&gt;()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// With unknown rank, the functions can be unified under one unranked type
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%A</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%B</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Remove rank info
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%A_u</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>memref</span>_cast <span style=color:#000>%A</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%B_u</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>memref</span>_cast <span style=color:#000>%B</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// call same function with dynamic ranks
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>call <span style=color:#000>@helper</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%A_u</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;)-&gt;()</span>
</span></span><span style=display:flex><span>call <span style=color:#000>@helper</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%B_u</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;)-&gt;()</span>
</span></span></code></pre></div><p>The core syntax and representation of a layout specification is a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a>. Additionally,
syntactic sugar is supported to make certain layout specifications more
intuitive to read. For the moment, a <code>memref</code> supports parsing a strided
form which is converted to a semi-affine map automatically.</p><p>The memory space of a memref is specified by a target-specific attribute.
It might be an integer value, string, dictionary or custom dialect attribute.
The empty memory space (attribute is None) is target specific.</p><p>The notionally dynamic value of a memref value includes the address of the
buffer allocated, as well as the symbols referred to by the shape, layout
map, and index maps.</p><p>Examples of memref static type</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Identity index/layout map
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#identity</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Column major layout.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#col_major</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>,</span> d2<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d2<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>,</span> d0<span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2-d tiled layout with tiles of size 128 x 256.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#tiled_2d_128x256</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0 div <span style=color:#0000cf;font-weight:700>128</span><span style=color:#000;font-weight:700>,</span> d1 div <span style=color:#0000cf;font-weight:700>256</span><span style=color:#000;font-weight:700>,</span> d0 mod <span style=color:#0000cf;font-weight:700>128</span><span style=color:#000;font-weight:700>,</span> d1 mod <span style=color:#0000cf;font-weight:700>256</span><span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A tiled data layout with non-constant tile sizes.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#tiled_dynamic</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)[</span>s0<span style=color:#000;font-weight:700>,</span> s1<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0 floordiv s0<span style=color:#000;font-weight:700>,</span> d1 floordiv s1<span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>                             d0 mod s0<span style=color:#000;font-weight:700>,</span> d1 mod s1<span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A layout that yields a padding on two at either end of the minor dimension.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#padded</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0<span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>(</span>d1 <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span> floordiv <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>(</span>d1 <span style=color:#a40000>+</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)</span> mod <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// The dimension list &#34;16x32&#34; defines the following 2D index space:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//   { (i, j) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 32 }
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x32x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#identity</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// The dimension list &#34;16x4x?&#34; defines the following 3D index space:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//   { (i, j, k) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 4, 0 &lt;= k &lt; N }
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// where N is a symbol which represents the runtime value of the size of
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// the third dimension.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// %N here binds to the size of the third dimension.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%A</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>(</span><span style=color:#000>%N</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x4x?x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#col_major</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2-d dynamic shaped memref that also has a dynamically sized tiled
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// layout. The memref index space is of size %M x %N, while %B1 and %B2
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// bind to the symbols s0, s1 respectively of the layout map #tiled_dynamic.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Data tiles of size %B1 x %B2 in the logical space will be stored
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// contiguously in memory. The allocation size will be
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// (%M ceildiv %B1) * %B1 * (%N ceildiv %B2) * %B2 f32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%T</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>(</span><span style=color:#000>%M</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%N</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>[</span><span style=color:#000>%B1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%B2</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>?x?x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#tiled_dynamic</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A memref that has a two-element padding at either end. The allocation
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// size will fit 16 * 64 float elements of data.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%P</span> <span style=color:#000;font-weight:700>=</span> alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x64x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#padded</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Affine map with symbol &#39;s0&#39; used as offset for the first dimension.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>#imapS</span> <span style=color:#000;font-weight:700>=</span> affine_map<span style=color:#000;font-weight:700>&lt;(</span>d0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>[</span>s0<span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span>d0 <span style=color:#a40000>+</span> s0<span style=color:#000;font-weight:700>,</span> d1<span style=color:#000;font-weight:700>)&gt;</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Allocate memref and bind the following symbols:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// &#39;%n&#39; is bound to the dynamic second dimension of the memref type.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// &#39;%o&#39; is bound to the symbol &#39;s0&#39; in the affine map of the memref type.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>%n</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000>%o</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000>%A</span> <span style=color:#000;font-weight:700>=</span> alloc <span style=color:#000;font-weight:700>(</span><span style=color:#000>%n</span><span style=color:#000;font-weight:700>)[</span><span style=color:#000>%o</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x?x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#imapS</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>layout</td><td style=text-align:center><code>MemRefLayoutAttrInterface</code></td><td></td></tr><tr><td style=text-align:center>memorySpace</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=nonetype>NoneType</h3><p><em>A unit type</em></p><p>Syntax:</p><pre tabindex=0><code>none-type ::= `none`
</code></pre><p>NoneType is a unit type, i.e. a type with exactly one possible value, where
its value does not have a defined dynamic representation.</p><h4 id=example-3>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@none_type</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%none_val</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#4e9a06>&#34;foo.unknown_op&#34;</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>-&gt;</span> none
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h3 id=opaquetype>OpaqueType</h3><p><em>Type of a non-registered dialect</em></p><p>Syntax:</p><pre tabindex=0><code>opaque-type ::= `opaque` `&lt;` type `&gt;`
</code></pre><p>Opaque types represent types of non-registered dialects. These are types
represented in their raw string form, and can only usefully be tested for
type equality.</p><h4 id=example-4>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>opaque<span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;llvm&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;struct&lt;(i32, float)&gt;&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>opaque<span style=color:#000;font-weight:700>&lt;</span><span style=color:#4e9a06>&#34;pdl&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;value&#34;</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>dialectNamespace</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>typeData</td><td style=text-align:center><code>::llvm::StringRef</code></td><td></td></tr></tbody></table><h3 id=rankedtensortype>RankedTensorType</h3><p><em>Multi-dimensional array with a fixed number of dimensions</em></p><p>Syntax:</p><pre tabindex=0><code>tensor-type ::= `tensor` `&lt;` dimension-list type (`,` encoding)? `&gt;`
dimension-list ::= (dimension `x`)*
dimension ::= `?` | decimal-literal
encoding ::= attribute-value
</code></pre><p>Values with tensor type represents aggregate N-dimensional data values, and
have a known element type and a fixed rank with a list of dimensions. Each
dimension may be a static non-negative decimal constant or be dynamically
determined (indicated by <code>?</code>).</p><p>The runtime representation of the MLIR tensor type is intentionally
abstracted - you cannot control layout or get a pointer to the data. For
low level buffer access, MLIR has a <a href=#memreftype><code>memref</code> type</a>. This
abstracted runtime representation holds both the tensor data values as well
as information about the (potentially dynamic) shape of the tensor. The
<a href=MemRef.md/#memrefdim-mlirmemrefdimop><code>dim</code> operation</a> returns the size of a
dimension from a value of tensor type.</p><p>The <code>encoding</code> attribute provides additional information on the tensor.
An empty attribute denotes a straightforward tensor without any specific
structure. But particular properties, like sparsity or other specific
characteristics of the data of the tensor can be encoded through this
attribute. The semantics are defined by a type and attribute interface
and must be respected by all passes that operate on tensor types.
TODO: provide this interface, and document it further.</p><p>Note: hexadecimal integer literals are not allowed in tensor type
declarations to avoid confusion between <code>0xf32</code> and <code>0 x f32</code>. Zero sizes
are allowed in tensors and treated as other sizes, e.g.,
<code>tensor&lt;0 x 1 x i32></code> and <code>tensor&lt;1 x 0 x i32></code> are different types. Since
zero sizes are not allowed in some other types, such tensors should be
optimized away before lowering tensors to vectors.</p><h4 id=example-5>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Known rank but unknown dimensions.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Partially known dimensions.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#0000cf;font-weight:700>13 x</span> <span style=color:#0000cf;font-weight:700>? x</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Full static shape.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>17 x</span> <span style=color:#0000cf;font-weight:700>4 x</span> <span style=color:#0000cf;font-weight:700>13 x</span> <span style=color:#0000cf;font-weight:700>4 x</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Tensor with rank zero. Represents a scalar.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Zero-element dimensions are allowed.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>x</span> <span style=color:#0000cf;font-weight:700>42 x</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Zero-element tensor of f32 type (hexadecimal literals not allowed here).
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>0xf32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Tensor with an encoding attribute (where #ENCODING is a named alias).
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>?x?x</span><span style=color:#204a87;font-weight:700>f64</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>#ENCODING</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=tupletype>TupleType</h3><p><em>Fixed-sized collection of other types</em></p><p>Syntax:</p><pre tabindex=0><code>tuple-type ::= `tuple` `&lt;` (type ( `,` type)*)? `&gt;`
</code></pre><p>The value of <code>tuple</code> type represents a fixed-size collection of elements,
where each element may be of a different type.</p><p><strong>Rationale:</strong> Though this type is first class in the type system, MLIR
provides no standard operations for operating on <code>tuple</code> types
(<a href=../../Rationale/Rationale/#tuple-types>rationale</a>).</p><h4 id=example-6>Example:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Empty tuple.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>tuple<span style=color:#000;font-weight:700>&lt;&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Single element
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>tuple<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Many elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>tuple<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i1</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>i5</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>types</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=unrankedmemreftype>UnrankedMemRefType</h3><p><em>Shaped reference, with unknown rank, to a region of memory</em></p><p>Syntax:</p><pre tabindex=0><code>unranked-memref-type ::= `memref` `&lt;*x` type (`,` memory-space)? `&gt;`
memory-space ::= attribute-value
</code></pre><p>A <code>memref</code> type with an unknown rank (e.g. <code>memref&lt;*xf32></code>). The purpose of
unranked memrefs is to allow external library functions to receive memref
arguments of any rank without versioning the functions based on the rank.
Other uses of this type are disallowed or will have undefined behavior.</p><p>See <a href=#memreftype>MemRefType</a> for more information on
memref types.</p><h4 id=examples>Examples:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// An unranked memref with a memory space of 10.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;*</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>memorySpace</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=unrankedtensortype>UnrankedTensorType</h3><p><em>Multi-dimensional array with unknown dimensions</em></p><p>Syntax:</p><pre tabindex=0><code>tensor-type ::= `tensor` `&lt;` `*` `x` type `&gt;`
</code></pre><p>An unranked tensor is a type of tensor in which the set of dimensions have
unknown rank. See <a href=#rankedtensortype>RankedTensorType</a>
for more information on tensor types.</p><h4 id=examples-1>Examples:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;*</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=vectortype>VectorType</h3><p><em>Multi-dimensional SIMD vector type</em></p><p>Syntax:</p><pre tabindex=0><code>vector-type ::= `vector` `&lt;` vector-dim-list vector-element-type `&gt;`
vector-element-type ::= float-type | integer-type | index-type
vector-dim-list := (static-dim-list `x`)?
static-dim-list ::= static-dim (`x` static-dim)*
static-dim ::= (decimal-literal | `[` decimal-literal `]`)
</code></pre><p>The vector type represents a SIMD style vector used by target-specific
operation sets like AVX or SVE. While the most common use is for 1D
vectors (e.g. vector&lt;16 x f32>) we also support multidimensional registers
on targets that support them (like TPUs). The dimensions of a vector type
can be fixed-length, scalable, or a combination of the two. The scalable
dimensions in a vector are indicated between square brackets ([ ]).</p><p>Vector shapes must be positive decimal integers. 0D vectors are allowed by
omitting the dimension: <code>vector&lt;f32></code>.</p><p>Note: hexadecimal integer literals are not allowed in vector type
declarations, <code>vector&lt;0x42xi32></code> is invalid because it is interpreted as a
2D vector with shape <code>(0, 42)</code> and zero shapes are not allowed.</p><h4 id=examples-2>Examples:</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2D fixed-length vector of 3x42 i32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>3x42x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 1D scalable-length vector that contains a multiple of 4 f32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;[</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>]</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2D scalable-length vector that contains a multiple of 2x8 f32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;[</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>]x[</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>]</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 2D mixed fixed/scalable vector that contains 4 scalable vectors of 4 f32 elements.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>4x</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>]</span>xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// A 3D mixed fixed/scalable vector in which only the inner dimension is
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// scalable.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>vector</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>2x</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>]</span>x8xf32<span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td>VectorElementTypeInterface instance</td></tr><tr><td style=text-align:center>scalableDims</td><td style=text-align:center><code>::llvm::ArrayRef&lt;bool></code></td><td></td></tr></tbody></table><h2 id=comb-ops>Comb ops</h2><h3 id=combadd-heircombaddop-1><code>comb.add</code> (heir::comb::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comband-heircombandop-1><code>comb.and</code> (heir::comb::AndOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combconcat-heircombconcatop-1><code>comb.concat</code> (heir::comb::ConcatOp)</h3><p><em>Concatenate a variadic list of operands together.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
</code></pre><p>See the comb rationale document for details on operand ordering.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combextract-heircombextractop-1><code>comb.extract</code> (heir::comb::ExtractOp)</h3><p><em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combicmp-heircombicmpop-1><code>comb.icmp</code> (heir::comb::ICmpOp)</h3><p><em>Compare two integer values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre tabindex=0><code>    %r = comb.icmp eq %a, %b : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-18>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::heir::comb::ICmpPredicateAttr</td><td>hw.icmp comparison predicate</td></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combinv-heircombinvop-1><code>comb.inv</code> (heir::comb::InvOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.inv` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-19>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comblut-heircomblutop-1><code>comb.lut</code> (heir::comb::LUTOp)</h3><p><em>Return an integer based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.lut` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This operation is similar to <code>truth_table</code>, but it allows for an integer output instead of a boolean.
Requers an vector of integers as the lookup table, where each integer represents the output for a specific combination of inputs.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-20>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>coefficients</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr><tr><td><code>lookupTable</code></td><td>::mlir::DenseI8ArrayAttr</td><td>i8 dense array attribute</td></tr></table><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 8-bit signless integer</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8-bit signless integer</td></tr></tbody></table><h3 id=combmul-heircombmulop-1><code>comb.mul</code> (heir::comb::MulOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmux-heircombmuxop-1><code>comb.mux</code> (heir::comb::MuxOp)</h3><p><em>Return one or the other operand depending on a selector bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))
</code></pre><pre tabindex=0><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=combnand-heircombnandop-1><code>comb.nand</code> (heir::comb::NandOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nand` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-23>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combnor-heircombnorop-1><code>comb.nor</code> (heir::comb::NorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.nor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-24>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combor-heircomborop-1><code>comb.or</code> (heir::comb::OrOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-25>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-28>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combparity-heircombparityop-1><code>comb.parity</code> (heir::comb::ParityOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-26>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combreplicate-heircombreplicateop-1><code>comb.replicate</code> (heir::comb::ReplicateOp)</h3><p><em>Concatenate the operand a constant number of times</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combtruth_table-heircombtruthtableop-1><code>comb.truth_table</code> (heir::comb::TruthTableOp)</h3><p><em>Return a true/false based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.truth_table` $inputs `-&gt;` $lookupTable attr-dict
</code></pre><pre tabindex=0><code>  %a = ... : i1
  %b = ... : i1
  %0 = comb.truth_table %a, %b -&gt; 6 : ui4
</code></pre><p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -> LSB from left
to right and the offset into <code>lookupTable</code> is computed from them. The
integer containing the truth table value&rsquo;s LSB is the output for the input
&ldquo;all false&rdquo;, and the MSB is the output for the input &ldquo;all true&rdquo;.</p><p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &lsquo;x&rsquo; &ndash; it should be the well-known result.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>LUTOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-27>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookupTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combxnor-heircombxnorop-1><code>comb.xnor</code> (heir::comb::XNorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xnor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-28>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-32>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-32>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combxor-heircombxorop-1><code>comb.xor</code> (heir::comb::XorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-29>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-33>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-33>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h2 id=comb-additional-definitions>Comb additional definitions</h2><h3 id=icmppredicate-1>ICmpPredicate</h3><p><em>Hw.icmp comparison predicate</em></p><h4 id=cases-1>Cases:</h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>eq</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>ne</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>slt</td><td style=text-align:center><code>2</code></td><td>slt</td></tr><tr><td style=text-align:center>sle</td><td style=text-align:center><code>3</code></td><td>sle</td></tr><tr><td style=text-align:center>sgt</td><td style=text-align:center><code>4</code></td><td>sgt</td></tr><tr><td style=text-align:center>sge</td><td style=text-align:center><code>5</code></td><td>sge</td></tr><tr><td style=text-align:center>ult</td><td style=text-align:center><code>6</code></td><td>ult</td></tr><tr><td style=text-align:center>ule</td><td style=text-align:center><code>7</code></td><td>ule</td></tr><tr><td style=text-align:center>ugt</td><td style=text-align:center><code>8</code></td><td>ugt</td></tr><tr><td style=text-align:center>uge</td><td style=text-align:center><code>9</code></td><td>uge</td></tr><tr><td style=text-align:center>ceq</td><td style=text-align:center><code>10</code></td><td>ceq</td></tr><tr><td style=text-align:center>cne</td><td style=text-align:center><code>11</code></td><td>cne</td></tr><tr><td style=text-align:center>weq</td><td style=text-align:center><code>12</code></td><td>weq</td></tr><tr><td style=text-align:center>wne</td><td style=text-align:center><code>13</code></td><td>wne</td></tr></tbody></table></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/google/heir aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2025 The HEIR Authors All Rights Reserved</span>
<span class=ms-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.027d75d71824837bee74c12a7806c5fe51249c1ca7accc27553a251a75cdb3a4.js integrity="sha256-An111xgkg3vudMEqeAbF/lEknBynrMwnVTolGnXNs6Q=" crossorigin=anonymous></script>
<script defer src=/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>