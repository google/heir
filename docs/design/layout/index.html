<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.113.0"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Ciphertext Packing System | HEIR</title><meta name=description content="This document describes HEIR&amp;rsquo;s ciphertext packing system, including:
A notation and internal representation of a ciphertext packing, which we call a layout. An abstraction layer to associate SSA values with layouts and manipulate and analyze them before a program is converted to concrete FHE operations. A variety of layouts and kernels from the FHE literature. A layout and kernel optimizer based on the Fhelipe compiler. A layout conversion implementation of the Vos-Vos-Erkin graph coloring algorithm."><meta property="og:title" content="Ciphertext Packing System"><meta property="og:description" content="This document describes HEIR&rsquo;s ciphertext packing system, including:
A notation and internal representation of a ciphertext packing, which we call a layout. An abstraction layer to associate SSA values with layouts and manipulate and analyze them before a program is converted to concrete FHE operations. A variety of layouts and kernels from the FHE literature. A layout and kernel optimizer based on the Fhelipe compiler. A layout conversion implementation of the Vos-Vos-Erkin graph coloring algorithm."><meta property="og:type" content="article"><meta property="og:url" content="https://heir.dev/docs/design/layout/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-10-17T13:33:52-07:00"><meta itemprop=name content="Ciphertext Packing System"><meta itemprop=description content="This document describes HEIR&rsquo;s ciphertext packing system, including:
A notation and internal representation of a ciphertext packing, which we call a layout. An abstraction layer to associate SSA values with layouts and manipulate and analyze them before a program is converted to concrete FHE operations. A variety of layouts and kernels from the FHE literature. A layout and kernel optimizer based on the Fhelipe compiler. A layout conversion implementation of the Vos-Vos-Erkin graph coloring algorithm."><meta itemprop=dateModified content="2025-10-17T13:33:52-07:00"><meta itemprop=wordCount content="4009"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Ciphertext Packing System"><meta name=twitter:description content="This document describes HEIR&rsquo;s ciphertext packing system, including:
A notation and internal representation of a ciphertext packing, which we call a layout. An abstraction layer to associate SSA values with layouts and manipulate and analyze them before a program is converted to concrete FHE operations. A variety of layouts and kernels from the FHE literature. A layout and kernel optimizer based on the Fhelipe compiler. A layout conversion implementation of the Vos-Vos-Erkin graph coloring algorithm."><link rel=preload href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css as=style><link href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=td-page><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="32" height="32" fill="#fff" fill-opacity=".01"/><path d="M18.6889 10.124l7.7916 5.0511 2.6263-1.6684-2.6146-1.6779-7.8033-4.96754 2.8526 1.84162L18.6889 10.124z" fill="#efcf6f"/><path d="M29.1185 6.86125 18.6979.13981 16.06 1.79876 26.4922 8.52025l2.6263-1.659z" fill="#efcf6f"/><path d="M8.2405 6.74134 5.60033 5.07291 3.05751 6.79935 5.67334 8.49344 8.2405 6.74134z" fill="#ee958a"/><path d="M10.8697 8.49344 8.2405 10.124v3.3995l5.2049-3.3348-2.5757-1.69526z" fill="#ee958a"/><path d="M5.67334 8.49344 3.05751 6.79935 3.03318 23.4932l2.64016 1.6897V8.49344z" fill="#a32e24"/><path d="M29.1185 6.86126 26.4922 8.52025V11.8288l2.6263-1.6401V6.86126z" fill="#d38041"/><path d="M21.5415 8.70288 18.6889 6.86126V10.124l2.8526-1.42112z" fill="#d38041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M8.2405 6.74134V10.124v3.3995l5.2049-3.3348V3.58723l2.6145-1.7885L16.1123 11.8484V18.467l-2.6158 1.6181L13.4574 13.5235 10.849 15.1694 8.2405 16.8152v6.678L5.67334 25.1829V8.49344L8.2405 6.74134z" fill="#dd583b"/><path d="M13.4965 20.0851 13.4574 13.5235 10.849 15.1694 10.8077 18.467l2.6888 1.6181z" fill="#a32e24"/><path fill-rule="evenodd" clip-rule="evenodd" d="M13.4454 3.58723V10.1887L10.8697 8.49344 10.9293 1.79873l2.5161 1.7885z" fill="#a32e24"/><path d="M16.0599 1.79873 13.4454.13981 10.9293 1.79873l2.5161 1.7885 2.6145-1.7885z" fill="#ee958a"/><path d="M16.06 1.79876 16.0793 5.52165 16.1123 11.8484V18.467l2.5766-1.6518V13.4696 10.124 6.86126l7.8033 4.96754V8.52025L16.06 1.79876z" fill="#e5ad11"/><path d="M18.6889 16.8152 16.1123 18.467l10.3682 6.7159V21.8372l-7.7916-5.022z" fill="#e5ad11"/><path d="M26.4805 15.1751 18.6889 10.124v3.3456l2.7505 1.7641 5.0411 3.2333V15.1751z" fill="#e5ad11"/><path d="M29.1068 13.5067l-2.6263 1.6684V18.467l2.6263-1.6518V13.5067z" fill="#d48041"/><path d="M29.1185 20.0851l-2.638 1.7521v3.3457l2.6263-1.6897L29.1185 20.0851z" fill="#d48041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M26.4805 21.8372l-7.7916-5.022 2.7505-1.5815 5.0411 3.2333 2.638 1.6181-2.638 1.7521z" fill="#efcf6f"/><path d="M18.6889 13.4696v3.3456l2.7505-1.5815-2.7505-1.7641z" fill="#d48041"/><path d="M20.1621 26.5165l-4.2015-2.7017-4.2015-2.7016L11.7108 23.8491l6.3384 4.0776 2.1129 1.3512V26.5165z" fill="#395aad"/><path d="M7.49852 23.8491v2.6674l8.41958 5.4439V29.2779L7.49852 23.8491z" fill="#276e3a"/><path d="M9.57951 22.4781l-2.08099 1.371 8.41958 5.4288 2.1311-1.3512-6.3384-4.0776-2.13129-1.371z" fill="#add284"/><path d="M24.3747 26.5165V23.8491L22.174 22.8377l-2.0054.9665 2.1815 1.3793 2.0246 1.333z" fill="#395aad"/><path d="M18.0492 19.7061l2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#395aad"/><path fill-rule="evenodd" clip-rule="evenodd" d="M20.1621 18.4432l-2.0415-.596-2.1581.596-2.1017 1.3349-2.1017 1.3351 2.1012 1.3511 6.3018 4.0522 2.188-1.333-2.1815-1.3793 2.0054-.9665 2.2007 1.0114 2.0995-1.329-2.0811-1.4069L22.3501 21.1371l-.1752-1.4237L22.174 19.7061l-2.0119-1.2629zm-2.1129 1.2629 2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#9ec4e0"/><path d="M26.4742 22.5201l-2.0995 1.329v2.6674l2.1289-1.3305L26.4742 22.5201z" fill="#4285f4"/><path d="M20.1621 26.5165v2.7614l2.188-1.3512V25.1835l-2.188 1.333z" fill="#4285f4"/><path d="M15.9181 29.2779v2.6825l2.1311-1.3708V27.9267l-2.1311 1.3512z" fill="#4e9c68"/></svg></span><span class=navbar-brand__name>HEIR</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/><span>Home</span></a></li><li class=nav-item><a class="nav-link active" href=/docs/><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://github.com/google/heir/ target=_blank rel=noopener><span>GitHub</span></a></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ms-3 fas fa-bars" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="collapse td-sidebar-nav" id=td-section-nav><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m--li><a href=/ title="HEIR: Homomorphic Encryption Intermediate Representation" class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-><span>Home</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-docs-li><a href=/docs/ title=Documentation class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docs><span>Docs</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsgetting_started-li><a href=/docs/getting_started/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsgetting_started><span>Getting Started</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-docsdevelopment-li><a href=/docs/development/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsdevelopment><span>Development</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdevelopmentbazel-li><a href=/docs/development/bazel/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdevelopmentbazel><span>Bazel tips</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdevelopmentboilerplate-li><a href=/docs/development/boilerplate/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdevelopmentboilerplate><span>Boilerplate tools</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdevelopmentide-li><a href=/docs/development/ide/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdevelopmentide><span>IDE configuration</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docstutorials-li><a href=/docs/tutorials/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docstutorials><span>Tutorials and Talks</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsresearch_with_heir-li><a href=/docs/research_with_heir/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsresearch_with_heir><span>Research with HEIR</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-docsdesign-li><a href=/docs/design/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsdesign><span>Design</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdesignmanagement-li><a href=/docs/design/management/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignmanagement><span>Ciphertext Management</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-docsdesignlayout-li><a href=/docs/design/layout/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-docsdesignlayout><span class=td-sidebar-nav-active-item>Ciphertext Packing System</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdesigndo_transformation-li><a href=/docs/design/do_transformation/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesigndo_transformation><span>Data-oblivious Transformations</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdesignnoise-li><a href=/docs/design/noise/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignnoise><span>Noise Analysis</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdesignsecret-li><a href=/docs/design/secret/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignsecret><span>Secret</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdesignsimd-li><a href=/docs/design/simd/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignsimd><span>SIMD Optimizations</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsdesignrelinearization_ilp-li><a href=/docs/design/relinearization_ilp/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdesignrelinearization_ilp><span>Optimizing relinearization</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docspipelines-li><a href=/docs/pipelines/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docspipelines><span>Pipelines</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-docsdialects-li><a href=/docs/dialects/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsdialects><span>Dialects</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsbgv-li><a href=/docs/dialects/bgv/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsbgv><span>BGV</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectscggi-li><a href=/docs/dialects/cggi/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectscggi><span>CGGI</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsckks-li><a href=/docs/dialects/ckks/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsckks><span>CKKS</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectscomb-li><a href=/docs/dialects/comb/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectscomb><span>Comb</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsjaxite-li><a href=/docs/dialects/jaxite/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsjaxite><span>Jaxite</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsjaxiteword-li><a href=/docs/dialects/jaxiteword/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsjaxiteword><span>JaxiteWord</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectslattigo-li><a href=/docs/dialects/lattigo/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectslattigo><span>Lattigo</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectslwe-li><a href=/docs/dialects/lwe/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectslwe><span>LWE</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsmathext-li><a href=/docs/dialects/mathext/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsmathext><span>MathExt</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsmgmt-li><a href=/docs/dialects/mgmt/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsmgmt><span>Mgmt</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsmodarith-li><a href=/docs/dialects/modarith/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsmodarith><span>ModArith</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsopenfhe-li><a href=/docs/dialects/openfhe/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsopenfhe><span>Openfhe</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectspolynomial-li><a href=/docs/dialects/polynomial/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectspolynomial><span>Polynomial</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsrandom-li><a href=/docs/dialects/random/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsrandom><span>Random</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectsrns-li><a href=/docs/dialects/rns/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectsrns><span>RNS</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectssecret-li><a href=/docs/dialects/secret/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectssecret><span>Secret</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectstensorext-li><a href=/docs/dialects/tensorext/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectstensorext><span>TensorExt</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectstfherust-li><a href=/docs/dialects/tfherust/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectstfherust><span>TfheRust</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-docsdialectstfherustbool-li><a href=/docs/dialects/tfherustbool/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsdialectstfherustbool><span>TfheRustBool</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docspasses-li><a href=/docs/passes/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docspasses><span>Passes</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-community-li><a href=/community/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-community><span>Community</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-search-li><a href=/search/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-search><span>Search Results</span></a></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ms-2 pb-1 pt-2 mb-0"><a id=print href=https://heir.dev/docs/design/_print/><i class="fa-solid fa-print fa-fw"></i> Print entire section</a></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#layout-representation>Layout representation</a><ul><li><a href=#quasi-affine-formulas-and-presburger-relations>Quasi-affine formulas and Presburger relations</a></li><li><a href=#layout-attributes>Layout attributes</a></li></ul></li><li><a href=#data-semantic-and-ciphertext-semantic-tensors>Data-semantic and ciphertext-semantic tensors</a></li><li><a href=#heirs-fhelipe-inspired-layout-optimizer>HEIR&rsquo;s Fhelipe-inspired layout optimizer</a><ul><li><a href=#pipeline-overview>Pipeline overview</a></li><li><a href=#layout-propagation><code>layout-propagation</code></a></li><li><a href=#layout-optimization><code>layout-optimization</code></a></li><li><a href=#convert-to-ciphertext-semantics><code>convert-to-ciphertext-semantics</code></a></li><li><a href=#implement-rotate-and-reduce><code>implement-rotate-and-reduce</code></a></li><li><a href=#add-client-interface><code>add-client-interface</code></a></li></ul></li><li><a href=#reusable-components-for-working-with-layouts>Reusable components for working with layouts</a><ul><li><a href=#lowering-data-semantic-ops-with-fhe-kernels>Lowering data-semantic ops with FHE kernels</a></li><li><a href=#testing-kernels-and-layouts>Testing kernels and layouts</a></li><li><a href=#manipulating-layouts>Manipulating layouts</a></li></ul></li><li><a href=#a-case-study-the-orion-convolution-kernel>A case study: the Orion convolution kernel</a></li><li><a href=#faq>FAQ</a><ul><li><a href=#can-users-define-kernels-without-modifying-the-compiler>Can users define kernels without modifying the compiler?</a></li></ul></li></ul></nav></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=https://heir.dev/docs/>Docs</a></li><li class=breadcrumb-item><a href=https://heir.dev/docs/design/>Design</a></li><li class="breadcrumb-item active" aria-current=page>Ciphertext Packing System</li></ol></nav><div class=td-content><h1>Ciphertext Packing System</h1><header class=article-meta></header><p>This document describes HEIR&rsquo;s ciphertext packing system, including:</p><ul><li>A notation and internal representation of a ciphertext packing, which we call
a <em>layout</em>.</li><li>An abstraction layer to associate SSA values with layouts and manipulate and
analyze them before a program is converted to concrete FHE operations.</li><li>A variety of layouts and kernels from the FHE literature.</li><li>A layout and kernel optimizer based on the
<a href=https://github.com/fhelipe-compiler/fhelipe>Fhelipe compiler</a>.</li><li>A layout conversion implementation of the
<a href=https://link.springer.com/chapter/10.1007/978-3-031-17140-6_20>Vos-Vos-Erkin graph coloring algorithm</a>.</li></ul><p>For background on what ciphertext packing is and its role in homomorphic
encryption, see
<a href=https://www.jeremykun.com/2024/09/06/packing-matrix-vector-multiplication-in-fhe/>this introductory blog post</a>.
The short version of that blog post is that the SIMD-style HE computational
model requires implementing linear-algebraic operations in terms of elementwise
additions, multiplications, and cyclic rotations of large-dimensional vectors
(with some exceptions like the
<a href=https://eprint.iacr.org/2025/448>Park-Gentry matrix-multiplication kernel</a>).</p><p>Practical programs require many such operations, and the task of the compiler is
to jointly choose ciphertext packings and operation kernels so as to minimize
overall program latency. In this document we will call the joint process of
optimizing layouts and kernels by the name &ldquo;layout optimization.&rdquo; In FHE
programs, runtime primarily comes from the quantity of rotation and bootstrap
operations, the latter of which is in turn approximated by multiplicative depth.
Metrics like memory requirements may also be constrained, but for most of this
document latency is the primary concern.</p><p>HEIR&rsquo;s design goal is to be an extensible HE compiler framework, we aim to
support a variety of layout optimizers and multiple layout representations. As
such, we separate the design of the layout representation from the details of
the layout optimizer, and implement lowerings for certain ops that can be reused
across optimizers.</p><p>This document will begin by describing the layout representation, move on to the
common, reusable components for working with that representation, and then
finally describe one layout optimizer implemented in HEIR based on Fhelipe.</p><h2 id=layout-representation>Layout representation</h2><p>A <em>layout</em> is a description of how cleartext data is organized within a list of
ciphertexts. In general, a layout is a partial function mapping from the index
set of a list of ciphertext <em>slots</em> to the index set of a cleartext tensor. The
function describes which cleartext data value is stored at which ciphertext
slot.</p><p>A layout is <em>partial</em> because not all ciphertext slots need to be used, and the
function uses ciphertext slots as the domain and cleartext indices as the
codomain because cleartext values may be replicated among multiple slots, but a
slot can store at most one cleartext value.</p><p>HEIR restricts the above definition of a layout as follows:</p><ul><li>The partial function must be expressible as a <em>Presburger relation</em>, which
will be defined in detail below.</li><li>Unmapped ciphertext slots always contain zero.[^zero]</li></ul><p>We claim that this subset of possible layouts is a superset of all layouts that
have been used in the FHE literature to date. For example, both the layout
notation of Fhelipe and the TileTensors of HeLayers are defined in terms of
specific parameterized quasi-affine formulas.</p><p>Next we define a Presburger relation, then move on to examples.</p><h3 id=quasi-affine-formulas-and-presburger-relations>Quasi-affine formulas and Presburger relations</h3><p><strong>Definition:</strong> A <em>quasi-affine</em> formula is a multivariate formula built from
the following operations:</p><ul><li>Integer literals</li><li>Integer-valued variables</li><li>addition and subtraction</li><li>multiplication by an integer constant</li><li>floor- and ceiling-rounded division by a nonzero integer constant</li><li>modulus by a nonzero integer constant</li></ul><p>Using the BNF grammar from the
<a href=https://mlir.llvm.org/docs/Dialects/Affine/#affine-expressions>MLIR website</a>,
we can also define it as</p><pre tabindex=0><code>affine-expr ::= `(` affine-expr `)`
              | affine-expr `+` affine-expr
              | affine-expr `-` affine-expr
              | `-`? integer-literal `*` affine-expr
              | affine-expr `ceildiv` integer-literal
              | affine-expr `floordiv` integer-literal
              | affine-expr `mod` integer-literal
              | `-`affine-expr
              | bare-id
              | `-`? integer-literal
</code></pre><p><strong>Definition:</strong> Let $d, r \in \mathbb{Z}_{\geq 0}$ represent a number of
domain and range dimensions, respectively. A <em>Presburger relation</em> is a binary
relation over $\mathbb{Z}^{d} \times \mathbb{Z}^{r}$ that can be expressed as
the solution to a set of equality and inequality constraints defined using
quasi-affine formulas.</p><p>We will use the Integer Set Library (ISL) notation to describe Presburger
relations. For an introduction to the ISL notation and library, see
<a href=https://jeremykun.com/2025/10/07/isl-a-primer/>this article</a>. For a
comprehensive reference, see
<a href=https://libisl.sourceforge.io/manual.pdf>the ISL manual</a>.</p><p><strong>Example 1:</strong> Given a data vector of type <code>tensor&lt;8xi32></code> and a ciphertext with
32 slots, a layout that repeats the tensor cyclically is given as:</p><pre tabindex=0><code>{
    [d] -&gt; [ct, slot] :
    0 &lt;= d &lt; 8
    and ct = 0
    and 0 &lt;= slot &lt; 32
    and (d - slot) mod 8 = 0
}
</code></pre><p>From Example 1, we note that in HEIR the domain of a layout always aligns with
the shape of the domain tensor, and the range of a layout is always a 2D tensor
whose first dimension denotes the ciphertext index and whose second index is the
slot within that ciphertext.</p><p><strong>Example 2:</strong> Given a data matrix of type <code>tensor&lt;8x8xi32></code> and 8 ciphertexts
with 32 slots each, the following layout implements the standard Halevi-Shoup
diagonal layout.</p><pre tabindex=0><code>{
    [row, col] -&gt; [ct, slot] :
    0 &lt;= row &lt; 8
    and 0 &lt;= col &lt; 8
    and 0 &lt;= ct &lt; 8
    and 0 &lt;= slot &lt; 32
    and (row - col + ct) mod 8 = 0
    and (row - slot) mod 32 = 0
}
</code></pre><p>Note, this layout implements a diagonal packing, and further replicates each
diagonal cyclically within a ciphertext.</p><h3 id=layout-attributes>Layout attributes</h3><p>Layouts are represented in HEIR via the <code>tensor_ext.layout</code> attribute. Its
argument includes a string using the ISL notation above. For example</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#tensor_layout</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.layout</span><span style=color:#000;font-weight:700>&lt;</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;{ [i0] -&gt; [ct, slot] : (slot - i0) mod 8 = 0 and ct = 0 and 1023 &gt;= slot &gt;= 0 and 7 &gt;= i0 &gt;= 0 }&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Generally, layout attributes are associated with an SSA value by being attached
to the op that owns the SSA value. In MLIR, which op owns the value has two
cases:</p><ul><li>For an op result, the layout attribute is stored on the op.</li><li>For a block argument, the layout attribute is stored on the op owning the
block, using the <code>OperandAndResultAttrInterface</code> to give a consistent API for
accessing the attribute.</li></ul><p>These two differences are handled properly by a helper library,
<code>lib/Utils/AttributeUtils.h</code>, which exposes setters and getters for layout
attributes. As of 2025-10-01, the system does not provide a way to handle ops
with multiple regions or multi-block regions.</p><p>For example, <code>#layout_attr</code> is associated with the SSA value <code>%1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>tensor_ext.layout =</span> <span style=color:#000>#layout_attr</span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>512x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h2 id=data-semantic-and-ciphertext-semantic-tensors>Data-semantic and ciphertext-semantic tensors</h2><p>In HEIR, before lowering to scheme ops, we distinguish between types in two
regimes:</p><ul><li><em>Data-semantic tensors</em>, which are scalars and tensors that represent
cleartext data values, largely unchanged from the original input program.</li><li><em>Ciphertext-semantic tensors</em>, which are rank-2 tensors that represent packed
cleartext values in ciphertexts.</li></ul><p>The task of analyzing an IR to determine which layouts and kernels to use
happens in the data-semantic regime. In these passes, chosen layouts are
persisted between passes as attributes on ops (see
<a href=#layout-attributes>Layout attributes</a> above), and data types are unchanged.</p><p>In this regime, there are three special <code>tensor_ext</code> ops that are no-ops on
data-semantic type, but are designed to manipulate the layout attributes. These
ops are:</p><ul><li><code>tensor_ext.assign_layout</code>, which takes a data-semantic value and a layout
attribute, and produces the same data-semantic type. This is an &ldquo;entry point&rdquo;
into the layout system and lowers to a loop that packs the data according to
the layout.</li><li><code>tensor_ext.convert_layout</code>, which makes an explicit conversion between a
data-semantic value&rsquo;s current layout and a new layout. Typically this lowers
to a shift network.</li><li><code>tensor_ext.unpack</code>, which clears the layout attribute on a data-semantic
value, and serves as an exit point from the layout system. This lowers to a
loop which extracts the packed cleartext data back into user data.</li></ul><p>A layout optimizer is expected to insert <code>assign_layout</code> ops for any server-side
cleartexts that need to be packed at runtime.</p><p>In the ciphertext-semantic regime, all secret values are rank-2 tensors whose
first axis indexes ciphertexts and whose second axis indexes slots within
ciphertexts. These tensors are subject to the constraints of the SIMD FHE
computational model (elementwise adds, muls, and structured rotations), though
the type system does not enforce this until <code>secret-to-&lt;scheme></code> lowerings,
which would fail if encountering an op that cannot be implemented in FHE.</p><p>We preserve the use of the <code>tensor</code> type here, rather than create new types, so
that we can reuse MLIR infrastructure. For example, if we were to use a new
tensor-like type for ciphertext-semantic tensors, we would not be able to use
<code>arith.addi</code> anymore, and would have to reimplement folding and canonicalization
patterns from MLIR in HEIR. In the future we hope MLIR will relax these
constraints via interfaces and traits, and at that point we could consider a
specialized type.</p><p>Before going on, we note that the layout specification language is agnostic to
how the &ldquo;slots&rdquo; are encoded in the underlying FHE scheme. In particular, slots
could correspond to evaluation points of an RNS polynomial, i.e., to &ldquo;NTT form&rdquo;
slots. But they could also correspond to the coefficients of an RNS polynomial
in coefficient form. As of 2025-10-01, HEIR&rsquo;s Fhelipe-inspired pipeline
materializes slots as NTT-form slots in all cases, but is not required by the
layout system. The only part of the layout system that depends on NTT-form is
the implementation of operation kernels in terms of rotation operations, as
coefficient-form ciphertexts do not have a rotation operation available. Future
layout optimizers may take into account conversions between NTT and coefficient
form as part of a layout conversion step.</p><h2 id=heirs-fhelipe-inspired-layout-optimizer>HEIR&rsquo;s Fhelipe-inspired layout optimizer</h2><h3 id=pipeline-overview>Pipeline overview</h3><p>The <code>mlir-to-&lt;scheme></code> pipeline involves the following passes that manipulate
layouts:</p><ul><li><code>layout-propagation</code></li><li><code>layout-optimization</code></li><li><code>convert-to-ciphertext-semantics</code></li><li><code>implement-rotate-and-reduce</code></li><li><code>add-client-interface</code></li></ul><p>The two passes that are closest to Fhelipe&rsquo;s design are <code>layout-propagation</code> and
<code>layout-optimization</code>. The former sets up initial default layouts for all values
and default kernels for all ops that need them, and propagates them forward,
inserting layout conversion ops as needed to resolve layout mismatches. The
latter does a backwards pass, jointly choosing more optimal kernels and
attempting to hoist layout conversions earlier in the IR. If layout conversions
are hoisted all the way to function arguments then they are &ldquo;free&rdquo; because they
can be merged into client preprocessing.</p><p>Next we will outline the responsibility of each pass in detail. The
documentation page for each of these passes is linked in each section, and
contains doctests as examples that are kept in sync with the implementation of
the pass.</p><h3 id=layout-propagation><code>layout-propagation</code></h3><p>The <a href=/docs/passes/#-layout-propagation><code>layout-propagation</code></a> pass runs a
forward pass through the IR to assign default layouts to each SSA value that
needs one, and a default kernel to each operation that needs one.</p><p>For each secret-typed function argument, no layout can be inferred, so a default
layout is assigned. The default layout for scalars is to repeat the scalar in
every slot of a single ciphertext. The default layout for tensors is a row-major
layout into as many ciphertexts as are needed to fit the tensor.</p><p>Then layouts are propagated forward through the IR. For each op, a default
kernel is chosen, and if the layouts of the operands are already set and agree,
the result layout is inferred according to the kernel.</p><p>If the layouts are not compatible with the default kernel, a <code>convert_layout</code> op
is inserted to force compatibility. If one or more operands has a layout that is
not set (which can happen if the operand is a cleartext value known to the
server), then a compatible layout is chosen and an <code>assign_layout</code> op is
inserted to persist this information for later passes.</p><p>Because <code>layout-propagation</code> may have inserted some redundant conversions,
sequences of <code>assign_layout</code> followed by <code>convert_layout</code> are folded together
into combined <code>assign_layout</code> ops.</p><h3 id=layout-optimization><code>layout-optimization</code></h3><p>The <a href=/docs/passes/#-layout-optimization><code>layout-optimization</code></a> pass has two
main goals: to choose better kernels for ops, and to try to eliminate
<code>convert_layout</code> ops. It does this by running a backward pass through the IR. If
it encounters an op that is followed by a <code>convert_layout</code> op, it attempts to
hoist the <code>convert_layout</code> through the op to its arguments.</p><p>In doing this, it must consider:</p><ul><li>Changing the kernel of the op, and the cost of implementing the kernel. E.g.,
a new kernel may be better for the new layout of the operands.</li><li>Whether the new layout of op results still need to be converted, and the new
cost of these conversions. E.g., if the op result has multiple uses, or the op
result had multiple layout conversions, only one of which is hoisted.</li><li>The new cost of operand layout conversions. E.g., if a layout conversion is
hoisted to one operand, it may require other operands to be converted to
remain compatible.</li></ul><p>In all of the above, the &ldquo;cost&rdquo; includes an estimate of the latency of a kernel,
an estimate of the latency of a layout conversion, as well as the knowledge that
some layout conversions may be free or cheaper because of their context in the
IR.</p><blockquote><p><strong>NOTE:</strong> The cost of a kernel is currently considered free. This is mainly
because we don&rsquo;t have many different kernels for each op right now, so the
choice of kernel is not very interesting.</p><p>TODO(#2316): implement a cost model for kernels</p></blockquote><p>The cost of a layout conversion is estimated by simulating what the
<code>implement-shift-network</code> would do if it ran on a layout conversion. And
<code>layout-optimization</code> includes analyses that allow it to determine a folded cost
for layout conversions that occur after other layout conversions, as well as the
free cost of layout conversions that occur at function arguments, after
<code>assign_layout</code> ops, or separated from these by ops that do not modify a layout.</p><p>After the backward pass, any remaining <code>convert_layout</code> ops at the top of a
function are hoisted into function arguments and folded into existing layout
attributes.</p><h3 id=convert-to-ciphertext-semantics><code>convert-to-ciphertext-semantics</code></h3><p>The
<a href=/docs/passes/#-convert-to-ciphertext-semantics><code>convert-to-ciphertext-semantics</code></a>
pass has two responsibilities that must happen at the same time:</p><ul><li>Converting all data-semantic values to ciphertext-semantic values with
corresponding types.</li><li>Implementing FHE kernels for all ops as chosen by earlier passes.</li></ul><p>After this pass is complete, the IR must be in the ciphertext-semantic regime
and all operations on secret-typed values must be constrained by the SIMD FHE
computational model.</p><p>In particular, this pass implements <code>assign_layout</code> as an explicit loop that
packs cleartext data into ciphertext slots according to the layout attribute. It
also implements <code>convert_layout</code> as a shift network, which is a sequence of
plaintext masks and rotations that can arbitrarily (albeit expensively) shuffle
data in slots. This step can be isolated via the
<a href=/docs/passes/#-implement-shift-network><code>implement-shift-network</code></a> pass, but
the functionality is inlined in this pass since it must happen at the same time
as type conversion.</p><p>When converting function arguments, any secret-typed argument is assigned a new
attribute called <code>tensor_ext.original_type</code>, which records the original
data-semantic type of the argument as well as the layout used for its packing.
This is used later by the <code>add-client-interface</code> pass to generate client-side
encryption and decryption helper functions.</p><h3 id=implement-rotate-and-reduce><code>implement-rotate-and-reduce</code></h3><p>Some kernels rely on a baby-step giant-step optimization, and defer the
implementation of that operation so that canonicalization patterns can optimize
them. Instead they emit a <code>tensor_ext.rotate_and_reduce</code> op. The
<a href=/docs/passes/#-implement-rotate-and-reduce><code>implement-rotate-and-reduce</code></a> pass
implements this op using baby-step giant-step, or other approaches that are
relevant to special cases.</p><h3 id=add-client-interface><code>add-client-interface</code></h3><p>The <a href=/docs/passes/#-add-client-interface><code>add-client-interface</code></a> pass inserts
additional functions that can be used by the client to encrypt and decrypt data
according to the layouts chosen by the layout optimizer.</p><p>It fetches the <code>original_type</code> attribute on function arguments, and generates an
encryption helper function for each secret argument, and a decryption helper
function for each secret return type.</p><p>These helper functions use <code>secret.conceal</code> and <code>secret.reveal</code> for
scheme-agnostic encryption and decryption, but eagerly implement the packing
logic as a loop, equivalently to how <code>assign_layout</code> is lowered in
<code>convert-to-ciphertext-semantics</code>, and adding an analogous lowering for
<code>tensor_ext.unpack</code>.</p><h2 id=reusable-components-for-working-with-layouts>Reusable components for working with layouts</h2><h3 id=lowering-data-semantic-ops-with-fhe-kernels>Lowering data-semantic ops with FHE kernels</h3><p>Any layout optimizer will eventually need to convert data-semantic values to
ciphertext-semantic tensors. In doing this, all kernels need to be implemented
in one pass at the same time that the types are converted.</p><p>The <code>convert-to-ciphertext-semantics</code> pass implements this conversion without
making any decisions about which layouts or kernels to use. In particular, for
ops that have multiple supported kernels, it picks the kernel to use based on
the <code>kernel</code> attribute on the op (cf. <code>secret::SecretDialect::kKernelAttrName</code>).</p><p>In this way, we decouple the decision of which layout and kernel to use (the
optimizer&rsquo;s job) from the implementation of that kernel (the lowering&rsquo;s job).
Ideally all layout optimizer pipelines can reuse this pass, which avoids the
common pitfalls associated with writing dialect conversion passes. New kernels,
similarly, can be primarily implemented as described in the next section.</p><p>Finally, if a new optimizer or layout notation is introduced into HEIR, it
should ultimately be converted to use the same <code>tensor_ext.layout</code> attribute so
that it can reuse the lowerings of ops like <code>tensor_ext.assign_layout</code> and
<code>tensor_ext.unpack</code>.</p><h3 id=testing-kernels-and-layouts>Testing kernels and layouts</h3><p>Writing kernels can be tricky, so HEIR provides a simplified framework for
implementing kernels which allows them to be unit-tested in isolation, while the
lowering to MLIR is handled automatically by a common library.</p><p>The implementation library is called <code>ArithmeticDag</code>. Some initial
implementations are in <code>lib/Kernel/KernelImplementation.h</code>, and example unit
tests are in <code>lib/Kernel/*Test.cpp</code>. Then a class called
<code>IRMaterializingVisitor</code> walks the DAG and generates MLIR code.</p><p>Similarly, <code>lib/Utils/Layout/Evaluate.h</code> provides helper functions to
materialize layouts on test data-semantic tensors, which can be combined with
<code>ArithmeticDag</code> to unit-test a layout and kernel combination without ever
touching MLIR.</p><h3 id=manipulating-layouts>Manipulating layouts</h3><p>The directory <code>lib/Utils/Layout</code> contains a variety of helper code for
manipulating layout relations, including:</p><ul><li>Constructing or testing for common kinds of layouts, such as row-major,
diagonal, and layouts related to particular machine learning ops like
convolution.</li><li>Generating explicit loops that iterate over the space of points in a layout,
which is used to generate packing and unpacking code.</li><li>Helpers for hoisting layout conversions through ops.</li></ul><p>These are implemented using two APIs: one is the Fast Presburger Library (FPL),
which is part of MLIR and includes useful operations like composing relations
and projecting out dimensions. The other is the Integer Set Library (ISL), which
is a more fully-featured library that supports code generation and advanced
analyses and simplification routines. As we represent layouts as ISL strings, we
include a two-way interoperability layer that converts between ISL and FPL
representations of the same Presburger relation.</p><h2 id=a-case-study-the-orion-convolution-kernel>A case study: the Orion convolution kernel</h2><p>The <a href=https://arxiv.org/abs/2311.03470>Orion compiler</a> presents a kernel for 2D
convolution that first converts the filter input into a Toeplitz matrix $A$, and
then applies a Halevi-Shoup diagonal packing and kernel on $A$ using the
encrypted image vector $v$ packed row-major into a single ciphertext.</p><p>We describe how this layout is constructed and represented in HEIR.</p><p>The first, analytical step, is to describe a Presburger relation mapping a
cleartext filter matrix to the Toeplitz matrix form as described in the Orion
paper. Essentially, this involves writing down the loop nest that implements a
convolution and, for each visited index,</p><p>Let $P$ be an integer padding value, fix stride 1, and define $i_{dr}, i_{dc}$
to be indices over the &ldquo;data row&rdquo; and &ldquo;data column&rdquo;, respectively, i.e., these
variables track the top-left index of the filter as it slides over the convolved
image in the data-semantic domain. For an image of height $H_d$ and width $W_d$,
and a filter of height $H_f$ and width $W_f$, we have</p><p>$$ -P \leq i_{dr} \leq H_d + P - W_f $$</p><p>and similarly for $i_{dc}$.</p><p>Then we have bounds for the iteration of entries of the filter itself, for a
fixed position of the filter over the image. If we consider these local
variables $i_{fr}$ and $i_{fc}$ for &ldquo;filter row&rdquo; and &ldquo;filter column&rdquo;,
respectively, we have</p><p>$$ 0 \leq i_{fr} &lt; H_f $$</p><p>and similarly for $i_{fc}$.</p><p>From these two indices we can compute the corresponding entry of the data matrix
that is being operated on as $i_{dr} + i_{fr}$ and $i_{dc} + i_{fc}$. If
that index is within the bounds of the image, then the filter entry at that
position is included in the Toeplitz matrix.</p><p>Finally, we need to compute the row and column of the Toeplitz matrix that each
filter entry maps to. This is the novel part of the Orion construction. Each row
of the Toeplitz matrix corresponds to one iteration over the filter (the filter
is fixed at some position of the filter over the image). And the column value is
a flattened index of the filter entry, plus offsets from both the padding and
the iteration of the filter over the image (each step the filter moves adds one
more to the offset).</p><p>The formula for the target row is</p><p>$$ m_{r} = (i_{dr} + P) F + i_{dc} + P $$</p><p>where $F$ is the total number of positions the filter assumes within each row,
i.e., $F = H_d + 2P - H_f + 1$.</p><p>And the target column is</p><p>$$ m_{c} = W_d i_{dr} + i_{dc} + W_d i_{fr} + i_{fc} $$</p><p>Note the use of <code>W_d</code> for both the offset from the filter&rsquo;s position over the
image, and the offset from the filter&rsquo;s own row.</p><p>Together this produces the following almost-Presburger relation:</p><pre tabindex=0><code>[Hd, Wd, Hf, Wf, P] -&gt; {
    [ifr, ifc] -&gt; [mr, mc] : exists idr, idc :

    // Bound the top-left index of the filter as it slides over the image
    -P &lt;= idr &lt;= Hd + P - Hf
    and -P &lt;= idc &lt;= Wd + P - Wf

    // Bound the index within the filter
    and 0 &lt;= ifr &lt; Hf
    and 0 &lt;= ifc &lt; Wf

    // Only map values when the filter index is in bounds
    and 0 &lt;= ifr + idr &lt; Hd
    and 0 &lt;= ifc + idc &lt; Wd

    // Map the materialized filter index to its position in the Toeplitz matrix
    and mr = (idr + P) * (Wd + 2P - Wf + 1) + idc + P
    and mc = (idr * Wd + idc) + Wd * ifr + ifc
}
</code></pre><p>This is &ldquo;almost&rdquo; a Presburger relation because, even though the symbol variables
<code>Hd</code>, <code>Wd</code>, <code>Hf</code>, <code>Wf</code>, and <code>P</code> are all integer constants, they cannot be
multiplied together in a Presburger formula. But if we replace them with
specific constants, such as</p><pre tabindex=0><code>Hd = 8
Wd = 8
Hf = 3
Wf = 3
P = 1
</code></pre><p>We get</p><pre tabindex=0><code>{
    [ifr, ifc] -&gt; [mr, mc] : exists idr, idc :
    -1 &lt;= idr &lt;= 6
    and -1 &lt;= idc &lt;= 6
    and 0 &lt;= ifr &lt; 3
    and 0 &lt;= ifc &lt; 3
    and 0 &lt;= ifr + idr &lt; 8
    and 0 &lt;= ifc + idc &lt; 8
    and mr = (idr + 1) * 8 + idc + 1
    and mc = idr * 8 + idc + ifc + ifr * 8
}
</code></pre><p>Which ISL simplifies to</p><pre tabindex=0><code>{
    [ifr, ifc] -&gt; [mr, mc = -9 + 8ifr + ifc + mr] :
    0 &lt;= ifr &lt;= 2
    and 0 &lt;= ifc &lt;= 2
    and mr &gt;= 0
    and 8 - 8ifr &lt;= mr &lt;= 71 - 8ifr
    and mr &lt;= 63
    and 8*floor((mr)/8) &gt;= -8 + ifc + mr
    and 8*floor((mr)/8) &lt; ifc + mr
}
</code></pre><p>Next, we can compose the above relation with the Halevi-Shoup diagonal layout
(using FPL&rsquo;s <code>IntegerRelation::compose</code>), to get a complete layout from filter
entries to ciphertext slots. Using ciphertexts with 1024 slots, we get:</p><pre tabindex=0><code>{
    [ifr, ifc] -&gt; [ct, slot] :
    (9 - 8ifr - ifc + ct) mod 64 = 0
    and 0 &lt;= ifr &lt;= 2
    and 0 &lt;= ifc &lt;= 2
    and 0 &lt;= ct &lt;= 63
    and 0 &lt;= slot &lt;= 1023
    and 8*floor((slot)/8) &gt;= -8 + ifc + slot
    and 8*floor((slot)/8) &lt; ifc + slot
    and 64*floor((slot)/64) &gt;= -72 + 8ifr + ifc + slot
    and 64*floor((slot)/64) &gt;= -71 + 8ifr + slot
    and 64*floor((slot)/64) &lt;= -8 + 8ifr + slot
    and 64*floor((slot)/64) &lt;= -9 + 8ifr + ifc + slot
}
</code></pre><h2 id=faq>FAQ</h2><h3 id=can-users-define-kernels-without-modifying-the-compiler>Can users define kernels without modifying the compiler?</h3><p><strong>No</strong> (as of 2025-10-01). However, a kernel DSL is <strong>in scope</strong> for HEIR. Reach
out if you&rsquo;d like to be involved in the design.</p><p>[^zero]: This may be relaxed in the future with additional static analyses
that can determine that some slots are never read.</p></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/google/heir aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2025 The HEIR Authors All Rights Reserved</span>
<span class=ms-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.027d75d71824837bee74c12a7806c5fe51249c1ca7accc27553a251a75cdb3a4.js integrity="sha256-An111xgkg3vudMEqeAbF/lEknBynrMwnVTolGnXNs6Q=" crossorigin=anonymous></script>
<script defer src=/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>