<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.113.0"><link rel=canonical type=text/html href=https://heir.dev/docs/design/><link rel=alternate type=application/rss+xml href=https://heir.dev/docs/design/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Design | HEIR</title><meta name=description content><meta property="og:title" content="Design"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://heir.dev/docs/design/"><meta itemprop=name content="Design"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="Design"><meta name=twitter:description content><link rel=preload href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css as=style><link href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=td-section><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="32" height="32" fill="#fff" fill-opacity=".01"/><path d="M18.6889 10.124l7.7916 5.0511 2.6263-1.6684-2.6146-1.6779-7.8033-4.96754 2.8526 1.84162L18.6889 10.124z" fill="#efcf6f"/><path d="M29.1185 6.86125 18.6979.13981 16.06 1.79876 26.4922 8.52025l2.6263-1.659z" fill="#efcf6f"/><path d="M8.2405 6.74134 5.60033 5.07291 3.05751 6.79935 5.67334 8.49344 8.2405 6.74134z" fill="#ee958a"/><path d="M10.8697 8.49344 8.2405 10.124v3.3995l5.2049-3.3348-2.5757-1.69526z" fill="#ee958a"/><path d="M5.67334 8.49344 3.05751 6.79935 3.03318 23.4932l2.64016 1.6897V8.49344z" fill="#a32e24"/><path d="M29.1185 6.86126 26.4922 8.52025V11.8288l2.6263-1.6401V6.86126z" fill="#d38041"/><path d="M21.5415 8.70288 18.6889 6.86126V10.124l2.8526-1.42112z" fill="#d38041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M8.2405 6.74134V10.124v3.3995l5.2049-3.3348V3.58723l2.6145-1.7885L16.1123 11.8484V18.467l-2.6158 1.6181L13.4574 13.5235 10.849 15.1694 8.2405 16.8152v6.678L5.67334 25.1829V8.49344L8.2405 6.74134z" fill="#dd583b"/><path d="M13.4965 20.0851 13.4574 13.5235 10.849 15.1694 10.8077 18.467l2.6888 1.6181z" fill="#a32e24"/><path fill-rule="evenodd" clip-rule="evenodd" d="M13.4454 3.58723V10.1887L10.8697 8.49344 10.9293 1.79873l2.5161 1.7885z" fill="#a32e24"/><path d="M16.0599 1.79873 13.4454.13981 10.9293 1.79873l2.5161 1.7885 2.6145-1.7885z" fill="#ee958a"/><path d="M16.06 1.79876 16.0793 5.52165 16.1123 11.8484V18.467l2.5766-1.6518V13.4696 10.124 6.86126l7.8033 4.96754V8.52025L16.06 1.79876z" fill="#e5ad11"/><path d="M18.6889 16.8152 16.1123 18.467l10.3682 6.7159V21.8372l-7.7916-5.022z" fill="#e5ad11"/><path d="M26.4805 15.1751 18.6889 10.124v3.3456l2.7505 1.7641 5.0411 3.2333V15.1751z" fill="#e5ad11"/><path d="M29.1068 13.5067l-2.6263 1.6684V18.467l2.6263-1.6518V13.5067z" fill="#d48041"/><path d="M29.1185 20.0851l-2.638 1.7521v3.3457l2.6263-1.6897L29.1185 20.0851z" fill="#d48041"/><path fill-rule="evenodd" clip-rule="evenodd" d="M26.4805 21.8372l-7.7916-5.022 2.7505-1.5815 5.0411 3.2333 2.638 1.6181-2.638 1.7521z" fill="#efcf6f"/><path d="M18.6889 13.4696v3.3456l2.7505-1.5815-2.7505-1.7641z" fill="#d48041"/><path d="M20.1621 26.5165l-4.2015-2.7017-4.2015-2.7016L11.7108 23.8491l6.3384 4.0776 2.1129 1.3512V26.5165z" fill="#395aad"/><path d="M7.49852 23.8491v2.6674l8.41958 5.4439V29.2779L7.49852 23.8491z" fill="#276e3a"/><path d="M9.57951 22.4781l-2.08099 1.371 8.41958 5.4288 2.1311-1.3512-6.3384-4.0776-2.13129-1.371z" fill="#add284"/><path d="M24.3747 26.5165V23.8491L22.174 22.8377l-2.0054.9665 2.1815 1.3793 2.0246 1.333z" fill="#395aad"/><path d="M18.0492 19.7061l2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#395aad"/><path fill-rule="evenodd" clip-rule="evenodd" d="M20.1621 18.4432l-2.0415-.596-2.1581.596-2.1017 1.3349-2.1017 1.3351 2.1012 1.3511 6.3018 4.0522 2.188-1.333-2.1815-1.3793 2.0054-.9665 2.2007 1.0114 2.0995-1.329-2.0811-1.4069L22.3501 21.1371l-.1752-1.4237L22.174 19.7061l-2.0119-1.2629zm-2.1129 1.2629 2.1194 1.431-2.048 1.3721-2.1698-1.3721 2.0984-1.431z" fill="#9ec4e0"/><path d="M26.4742 22.5201l-2.0995 1.329v2.6674l2.1289-1.3305L26.4742 22.5201z" fill="#4285f4"/><path d="M20.1621 26.5165v2.7614l2.188-1.3512V25.1835l-2.188 1.333z" fill="#4285f4"/><path d="M15.9181 29.2779v2.6825l2.1311-1.3708V27.9267l-2.1311 1.3512z" fill="#4e9c68"/></svg></span><span class=navbar-brand__name>HEIR</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/><span>Home</span></a></li><li class=nav-item><a class="nav-link active" href=/docs/><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://github.com/google/heir/ target=_blank rel=noopener><span>GitHub</span></a></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/design/>Return to the regular view of this page</a>.</p></div><h1 class=title>Design</h1><ul><li>1: <a href=#pg-b68f7af4e332a4d2b770c09ac2607bf8>Ciphertext Management</a></li><li>2: <a href=#pg-bddfea9d49299ca5edc4a07ea06fcc23>Data-oblivious Transformations</a></li><li>3: <a href=#pg-596c831179432fef68d03e056a55875c>Noise Analysis</a></li><li>4: <a href=#pg-76ae4da46c68c5cd44ad0ecf5d69993f>Secret</a></li><li>5: <a href=#pg-05018faa55dd802660a3ea38b8f7fb69>SIMD Optimizations</a></li><li>6: <a href=#pg-cd22aa05be277ba6c2e2f8f083706b51>Optimizing relinearization</a></li><li>7: <a href=#pg-8c7f770d0d2ffa01c9ca233de813ffec></a></li></ul><div class=content><p>HEIR is a compiler toolchain that allows the compilation of high-level programs
to equivalent programs that operate on encrypted data.</p><p>HEIR is built in the <a href=https://mlir.llvm.org/>MLIR</a> framework.</p><p>HEIR defines dialects at various layers of abstraction, from high-level
scheme-agnostic operations on secret types to low-level polynomial arithmetic.
The diagram below shows some of the core HEIR dialects, and the compilation flow
is generally from the top of the diagram downward.</p><img style=display:block;margin-left:75px;width:500px src=/images/dialect-diagram.png><p>The pages in this section describe the design of various subcomponents of HEIR.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-b68f7af4e332a4d2b770c09ac2607bf8>1 - Ciphertext Management</h1><p>On 2025-04-17, Hongren Zheng gave a talk overview of the ciphertext management
system in the HEIR working group meeting.
<a href="https://youtu.be/HHU6rCMxZRc?si=U_ePY5emqs6e4NoV&amp;t=1631">The video can be found here</a>
and <a href=/slides/mgmt-2025-04-17.pdf>the slides can be found here</a></p><h2 id=introduction>Introduction</h2><p>To lower from user specified computation to FHE scheme operations, a compiler
must insert <em>ciphertext management</em> operations to satisfy various requirements
of the FHE scheme, like modulus switching, relinearization, and bootstrapping.
In HEIR, such operations are modeled in a scheme-agnostic way in the <code>mgmt</code>
dialect.</p><p>Taking the arithmetic pipeline as example: a program specified in high-level
MLIR dialects like <code>arith</code> and <code>linalg</code> is first transformed to an IR with only
<code>arith.addi/addf</code>, <code>arith.muli/mulf</code>, and <code>tensor_ext.rotate</code> operations. We
call this form the <em>secret arithmetic</em> IR.</p><p>Then management passes insert <code>mgmt</code> ops to support future lowerings to scheme
dialects like <code>bgv</code> and <code>ckks</code>. As different schemes have different management
requirement, they should be inserted in different styles.</p><p>We discuss each scheme below to show the design in HEIR. For RLWE schemes, we
all assume RNS instantiation.</p><h2 id=bgv>BGV</h2><p>BGV is a leveled scheme where each level has a modulus $q_i$. The level is
numbered from $0$ to $L$ where $L$ is the input level and $0$ is the output
level. The core feature of BGV is that when the magnititude of the noise becomes
large (often caused by multiplication), a modulus switching operation from level
$i$ to level $i-1$ can be inserted to reduce the noise to a &ldquo;constant&rdquo; level. In
this way, BGV can support a circuit of multiplicative depth $L$.</p><h3 id=bgv-relinearization>BGV: Relinearization</h3><p>HEIR initially inserts relinearization ops immediately after each multiplication
to keep ciphertext dimension &ldquo;linear&rdquo;. A later relinearization optimization pass
relaxes this requirement, and uses an integer linear program to decide when to
relinearize. See <a href=/docs/design/relinearization_ilp/>Optimizing Relinearization</a>
for more details.</p><h3 id=bgv-modulus-switching>BGV: Modulus switching</h3><p>There are several techniques to insert modulus switching ops.</p><p>For the example circuit <code>input -> mult -> mult -> output</code>, the insertion result
could be one of</p><ol><li><p>After multiplication: <code>input -> (mult -> ms) -> (mult -> ms) -> output</code></p></li><li><p>Before multiplication: <code>input -> (mult) -> (ms -> mult) -> (ms -> output)</code></p></li><li><p>Before multiplication (including the first multiplication):
<code>input -> (ms -> mult) -> (ms -> mult) -> (ms -> output)</code></p></li></ol><p>The first strategy is from the BGV paper, the second and third strategies are
from OpenFHE, which correspond to the <code>FLEXIBLEAUTO</code> mode and <code>FLEXIBLEAUTOEXT</code>
mode, respectively.</p><p>The first strategy is conceptually simpler, yet other policies have the
advantage of smaller noise growth. In latter policies, by delaying the modulus
switch until just before multiplication, the noise from other operations between
multiplications (like rotation/relinearization) also benefit from the noise
reduction of a modulus switch.</p><p>Note that, as multiplication has two operands, the actual circuit for the latter
two policies is <code>mult(ms(ct0), ms(ct1))</code>, whereas in the first policy the
circuit is <code>ms(mult(ct0, ct1))</code>.</p><p>The third policy has one more switching op than the others, so it will need one
more modulus.</p><p>There are also other insertion strategy like inserting it dynamically based on
current noise (see HElib) or lazy modulus switching. Those are not implemented.</p><h3 id=bgv-scale-management>BGV: Scale management</h3><p>For the original BGV scheme, it is required to have $qi \equiv 1 \pmod{t}$
where $t$ is the plaintext modulus. However in practice such requirement will
make the choice of $q_i$ too constrained. In the GHS variant, this condition is
removed, with the price of scale management needed.</p><p>Modulus switching from level $i$ to level $i-1$ is essentially dividing (with
rounding) the ciphertext by $q_i$, hence dividing the noise and payload message
inside by $q_i$. The message $m$ can often be written as $[m]_t$, the coset
representative of <code>m</code> $\mathbb{Z}/t\mathbb{Z}$. Then by dividing of $q_i$
produces a result message $[m \cdot q_i^{-1}]_t$.</p><p>Note that when $qi \equiv 1 \pmod{t}$, the result message is the same as the
original message. However, in the GHS variant this does not always hold, so we
call the introduced factor of $[q^{-1}]_t$ the <em>scale</em> of the message. HEIR
needs to record and manage it during compilation. When decrypting the scale must
be removed to obtain the right message.</p><p>Note that, for messages $m_0$ and $m_1$ of different scale $a$ and $b$, we
cannot add them directly because $[a \cdot m_0 + b \cdot m_1]_t$ does not
always equal $[m_0 + m_1]_t$. Instead we need to adjust the scale of one
message to match the other, so $[b \cdot m_0 + b \cdot m_1]_t = [b \cdot
(m_0 + m_1)]_t$. Such adjustment could be done by multiplying $m_0$ with a
constant $[b \cdot a^{-1}]_t$. This adjustment is not for free, and
increases the ciphertext noise.</p><p>As one may expect, different modulus switching insertion strategies affect
message scale differently. For $m_0$ with scale $a$ and $m_1$ with scale $b$,
the result scale would be</p><ol><li><p>After multiplication: $[ab / qi]_t$.</p></li><li><p>Before multiplication: $[a / qi \cdot b / qi]_t = [ab / (qi^2)]_t$.</p></li></ol><p>This is messy enough. To ease the burden, we can impose additional requirement:
mandate a constant scale $\Delta_i$ for all ciphertext at level $i$. This is
called the <em>level-specific scaling factor</em>. With this in mind, addition within
one level can happen without caring about the scale.</p><ol><li><p>After multiplication: $\Delta_{i-1} = [\Delta_i^2 / qi]_t$</p></li><li><p>Before multiplication: $\Delta_{i-1} = [\Delta_i^2 / (qi^2)]_t$</p></li></ol><h3 id=bgv-cross-level-operation>BGV: Cross Level Operation</h3><p>With the level-specific scaling factor, one may wonder how to perform addition
and multiplication of ciphertexts on different levels. This can be done by
adjusting the level and scale of the ciphertext at the higher level.</p><p>The level can be easily adjusted by dropping the extra limbs, and scale can be
adjusted by multiplying a constant, but because multiplying a constant will
incur additional noise, the procedure becomes the following:</p><ol><li><p>Assume the level and scale of two ciphertexts are $l_1$ and $l_2$, $s_1$ and
$s_2$ respectively. WLOG assume $l_1 > l_2$.</p></li><li><p>Drop $l_1 - l_2 - 1$ limbs for the first ciphertext to make it at level $l_2
+ 1$, if those extra limbs exist.</p></li><li><p>Adjust scale from $s_1$ to $s_2 \cdot q_{l_2 + 1}$ by multiplying $[s_2
\cdot q_{l_2 + 1} / s1]_t$ for the first ciphertext.</p></li><li><p>Modulus switch from $l_2 + 1$ to $l_2$, producing scale $s_2$ for the first
ciphertext and its noise is controlled.</p></li></ol><h3 id=bgv-implementation-in-heir>BGV: Implementation in HEIR</h3><p>In HEIR the different modulus switching policy is controlled by the pass option
for <code>--secret-insert-mgmt-bgv</code>. The pass defaults to the &ldquo;Before Multiplication&rdquo;
policy. If user wants other policy, the <code>after-mul</code> or
<code>before-mul-include-first-mul</code> option may be used. The <code>mlir-to-bgv</code> pipeline
option <code>modulus-switch-before-first-mul</code> corresponds to the latter option.</p><p>The <code>secret-insert-mgmt</code> pass is also responsible for managing cross-level
operations. However, as the scheme parameters are not generated at this point,
the concrete scale could not be instantiated so some placeholder operations are
inserted.</p><p>After the modulus switching policy is applied, the <code>generate-param-bgv</code> pass
generates scheme parameters. Optionally, user could skip this pass by manually
providing scheme parameter as an attribute at module level.</p><p>Then <code>populate-scale-bgv</code> comes into play by using the scheme parameters to
instantiate concrete scale, and turn those placeholder operations into concrete
multiplication operation.</p><h2 id=ckks>CKKS</h2><p>CKKS is a leveled scheme where each level has a modulus $q_i$. The level is
numbered from $0$ to $L$ where $L$ is the input level and $0$ is the output
level. CKKS ciphertext contains a scaled message $\Delta m$ where $\Delta$
takes some value like $2^40$ or $2^80$. After multiplication of two messages,
the scaling factor $\Delta&rsquo;$ will become larger, hence some kind of management
policy is needed in case it blows up. Contrary to BGV where modulus switching is
used for noise management, in CKKS modulus switching from level $i$ to level
$i-1$ can divide the scaling factor $\Delta$ by the modulus $q_i$.</p><p>The management of CKKS is similar to BGV above in the sense that their strategy
are the similar and uses similar code base. However, BGV scale management is
internal and users are not required to concern about it, while CKKS scale
management is visible to user as it affects the precision. One notable
difference is that, for &ldquo;Before multiplication (including the first
multiplication)&rdquo; modulus switching policy, the user input should be encoded at
$\Delta^2$ or higher, as otherwise the first modulus switching (or rescaling in
CKKS term) will rescale $\Delta$ to $1$, rendering full precision loss.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bddfea9d49299ca5edc4a07ea06fcc23>2 - Data-oblivious Transformations</h1><p>A data-oblivious program is one that decouples data input from program
execution. Such programs exhibit control-flow and memory access patterns that
are independent of their input(s). This programming model, when applied to
encrypted data, is necessary for expressing FHE programs. There are 3 major
transformations applied to convert a conventional program into a data-oblivious
program:</p><h3 id=1-if-transformation>(1) If-Transformation</h3><p>If-operations conditioned on inputs create data-dependent control-flow in
programs. <code>scf.if</code> operations should at least define a &rsquo;then&rsquo; region (true path)
and always terminate with <code>scf.yield</code> even when <code>scf.if</code> doesn&rsquo;t produce a
result. To convert a data-dependent <code>scf.if</code> operation to an equivalent set of
data-oblivious operations in MLIR, we hoist all safely speculatable operations
in the <code>scf.if</code> operation and convert the <code>scf.yield</code> operation to an
<code>arith.select</code> operation. The following code snippet demonstrates an application
of this transformation.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Before applying If-transformation
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@my_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%input</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i1</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>})</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>  <span style=color:#8f5902;font-style:italic>// Violation: %input is used as a condition causing a data-dependent branch
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>%result</span> <span style=color:#000;font-weight:700>=</span><span style=color:#a40000>`</span><span style=color:#000>%input</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#000>%a</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%b</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>        scf<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%a</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>}</span> else <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        scf<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%b</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// After applying If-transformation
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@my_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%input</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>})</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(){</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%a</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%b</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%result</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>select <span style=color:#000>%input</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%a</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%b</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>We implement a <code>ConvertIfToSelect</code> pass that transforms operations with
secret-input conditions and with only Pure operations (i.e., operations that
have no memory side effect and are speculatable) in their body. <strong>This
transformation cannot be applied to operations when side effects are present in
only one of the two regions.</strong> Although possible, we currently do not support
transformations for operations where both regions have operations with matching
side effects. When side effects are present, the pass fails.</p><h3 id=2-loop-transformation>(2) Loop-Transformation</h3><p>Loop statements with input-dependent conditions (bounds) and number of
iterations introduce data-dependent branches that violate data-obliviousness. To
convert such loops into a data-oblivious version, we replace input-dependent
conditionals (bounds) with static input-independent parameters (e.g. defining a
constant upper bound), and early-exits with update operations where the value
returned from the loop is selectively updated using conditional predication. In
MLIR, loops are expressed using either <code>affine.for</code>, <code>scf.for</code> or <code>scf.while</code>
operations.</p><blockquote><p>[!NOTE] Early exiting from loops is not supported in <code>scf</code> and <code>affine</code>, so
early exits are not supported in this pipeline. Early exits are expected to be
added to MLIR upstream at some point in the future.</p></blockquote><ul><li><code>affine.for</code>: This operation lends itself well to expressing data oblivious
programs because it requires constant loop bounds, eliminating input-dependent
limits.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span> <span style=color:#000>%sum_0</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>0.0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>f32</span>
</span></span><span style=display:flex><span> <span style=color:#8f5902;font-style:italic>// The for-loop&#39;s bound is a fixed constant
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span> <span style=color:#000>%sum</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%i</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>10</span> step <span style=color:#0000cf;font-weight:700>2</span>
</span></span><span style=display:flex><span> iter_args<span style=color:#000;font-weight:700>(</span><span style=color:#000>%sum_iter</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>%sum_0</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>   <span style=color:#000>%t</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>load <span style=color:#000>%buffer</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%i</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1024x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#000>%sum_next</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addf <span style=color:#000>%sum_iter</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%input</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>f32</span>
</span></span><span style=display:flex><span>   affine<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%sum_next</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>f32</span>
</span></span><span style=display:flex><span> <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span> <span style=color:#000;font-weight:700>...</span>
</span></span></code></pre></div><ul><li><code>scf.for</code>: In contrast to affine.for, scf.for does allow input-dependent
conditionals which does not adhere to data-obliviousness constraints. A
solution to this could be to either have the programmer or the compiler
specify an input-independent upper bound so we can transform the loop to use
this upper bound and also carefully update values returned from the for-loop
using conditional predication. Our current solution to this is for the
programmer to add the lower bound and worst case upper bound in the static
affine loop&rsquo;s <code>attributes</code> list.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@my_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%value</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>},</span> <span style=color:#000>%inputIndex</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>})</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i32</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>  <span style=color:#8f5902;font-style:italic>// Violation: for-loop uses %inputIndex as upper bound which causes a secret-dependent control-flow
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>%result</span> <span style=color:#000;font-weight:700>=</span> scf<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%iv</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>%begin</span> to <span style=color:#000>%inputIndex</span> step <span style=color:#000>%step_value</span> iter_args<span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>%value</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i32</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%output</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    scf<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%output</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}{</span><span style=color:#f57900>lower =</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>upper =</span> <span style=color:#0000cf;font-weight:700>32</span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// After applying Loop-Transformation
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@my_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%value</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>},</span> <span style=color:#000>%inputIndex</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>})</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i32</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>  <span style=color:#8f5902;font-style:italic>// Build for-loop using lower and upper values from the `attributes` list
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>%result</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%iv</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to  step <span style=color:#0000cf;font-weight:700>32</span> iter_args<span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>%value</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i32</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%output</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%agr1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%cond</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>cmpi eq<span style=color:#000;font-weight:700>,</span> <span style=color:#000>%iv</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%inputIndex</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%newOutput</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>select <span style=color:#000>%cond</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%output</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span>
</span></span><span style=display:flex><span>    scf<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%newOutput</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><ul><li><code>scf.while</code>: This operation represents a generic while/do-while loop that
keeps iterating as long as a condition is met. An input-dependent while
condition introduces a data-dependent control flow that violates
data-oblivious constraints. For this transformation, the programmer needs to
add the <code>max_iter</code> attribute that describes the maximum number of iterations
the loop runs which we then use the value to build our static <code>affine.for</code>
loop.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Before applying Loop-Transformation
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@my_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%input</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>}){</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%zero</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%result</span> <span style=color:#000;font-weight:700>=</span> scf<span style=color:#000;font-weight:700>.</span>while <span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>%input</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i16</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%cond</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>cmpi slt<span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%zero</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// Violation: scf.while uses %cond whose value depends on %input
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    scf<span style=color:#000;font-weight:700>.</span>condition<span style=color:#000;font-weight:700>(</span><span style=color:#000>%cond</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> do <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%mul</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>    scf<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%mul</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> attributes <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>max_iter =</span> <span style=color:#0000cf;font-weight:700>16</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// After applying Loop-Transformation
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@my_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%input</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>}){</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%zero</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%begin</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>  <span style=color:#8f5902;font-style:italic>// Replace while-loop with a for-loop with a constant bound %MAX_ITER
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>%result</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%iv</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>%0</span> to <span style=color:#000>%16</span> step <span style=color:#000>%step_value</span> iter_args<span style=color:#000;font-weight:700>(</span><span style=color:#000>%iter_arg</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>%input</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>i16</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%cond</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>cmpi slt<span style=color:#000;font-weight:700>,</span> <span style=color:#000>%iter_arg</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%zero</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%mul</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%iter_arg</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%iter_arg</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%output</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>select <span style=color:#000>%cond</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%mul</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%iter_arg</span>
</span></span><span style=display:flex><span>    scf<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%output</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}{</span><span style=color:#f57900>max_iter =</span> <span style=color:#0000cf;font-weight:700>16</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h3 id=3-access-transformation>(3) Access-Transformation</h3><p>Input-dependent memory access cause data-dependent memory footprints. A naive
data-oblivious solution to this maybe doing read-write operations over the
entire data structure while only performing the desired save/update operation
for the index of interest. For simplicity, we only look at load/store operations
for tensors as they are well supported structures in high-level MLIR likely
emitted by most frontends. We drafted the following non-SIMD approach for this
transformation and defer SIMD optimizations to the <code>heir-simd-vectorizer</code> pass:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Before applying Access Transformation
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@my_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%input</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>},</span> <span style=color:#000>%inputIndex</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>})</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c_10</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#8f5902;font-style:italic>// Violation: tensor.extract loads value at %inputIndex
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>%extractedValue</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>extract <span style=color:#000>%input</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%inputIndex</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%newValue</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%extractedValue</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c_10</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#8f5902;font-style:italic>// Violation: tensor.insert stores value at %inputIndex
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>%inserted</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>insert <span style=color:#000>%newValue</span> into <span style=color:#000>%input</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%inputIndex</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// After applying Non-SIMD Access Transformation
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@my_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%input</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>},</span> <span style=color:#000>%inputIndex</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>})</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c_10</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>10</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%i_0</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%dummyValue</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000>%extractedValue</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%i</span><span style=color:#000;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>16</span> iter_args<span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg</span><span style=color:#000;font-weight:700>=</span> <span style=color:#000>%dummyValue</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 1. Check if %i matches %inputIndex
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>// 2. Extract value at %i
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>// 3. If %i matches %inputIndex, select %value extracted in (2), else select %dummyValue
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>// 4. Yield selected value
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>%cond</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>cmpi eq<span style=color:#000;font-weight:700>,</span> <span style=color:#000>%i</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%inputIndex</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%value</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>extract <span style=color:#000>%input</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%i</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%selected</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>select <span style=color:#000>%cond</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%value</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%dummyValue</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>    affine<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%selected</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000>%newValue</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%extractedValue</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c_10</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000>%inserted</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%i</span><span style=color:#000;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>16</span> iter_args<span style=color:#000;font-weight:700>(</span><span style=color:#000>%inputArg</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>%input</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// 1. Check if %i matches the %inputIndex
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>// 2. Insert %newValue and produce %newTensor
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>// 3. If %i matches %inputIndex, select %newTensor, else select input tensor
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>// 4. Yield final tensor
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>%cond</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>cmpi eq<span style=color:#000;font-weight:700>,</span> <span style=color:#000>%i</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%inputIndex</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%newTensor</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>insert <span style=color:#000>%value</span> into <span style=color:#000>%inputArg</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%i</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%finalTensor</span><span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>select <span style=color:#000>%cond</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%newTensor</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%inputArg</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    affine<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%finalTensor</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h3 id=more-notes-on-these-transformations>More notes on these transformations</h3><p>These 3 transformations have a cascading behavior where transformations can be
applied progressively to achieve a data-oblivious program. The order of the
transformations goes as follows:</p><ul><li><em>Access-Transformation</em> (change data-dependent tensor accesses (reads-writes)
to use <code>affine.for</code> and <code>scf.if</code> operations) -> <em>Loop-Transformation</em> (change
data-dependent loops to use constant bounds and condition the loop&rsquo;s yield
results with <code>scf.if</code> operation) -> <em>If-Transformation</em> (substitute
data-dependent conditionals with <code>arith.select</code> operation).</li><li>Besides that, when we apply non-SIMD Access-Transformation on multiple
data-dependent tensor read-write operations over the same tensor, we can
benefit from upstream affine transformations over the resulting multiple
affine loops produced by the Access-Transformation to fuse these loops.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-596c831179432fef68d03e056a55875c>3 - Noise Analysis</h1><p>Homomorphic Encryption (HE) schemes based on Learning-With-Errors (LWE) and
Ring-LWE naturally need to deal with <em>noises</em>. HE compilers, in particular, need
to understand the noise behavior to ensure correctness and security while
pursuing efficiency and optimizaiton.</p><p>The noise analysis in HEIR has the following central task: Given an HE circuit,
analyse the noise growth for each operation. HEIR then uses noise analysis for
parameter selection, but the details of that are beyond the scope of this
document.</p><p>Noise analysis and parameter generation are still under active researching and
HEIR does not have a one-size-fits-all solution for now. Noise analyses and
(especially) parameter generation in HEIR should be viewed as experimental.
<em>There is no guarantee that they are correct or secure</em> and the HEIR authors do
not take responsibility. Please consult experts before putting them into
production.</p><h2 id=two-flavors-of-noise-analysis>Two Flavors of Noise Analysis</h2><p>Each HE ciphertext contains <em>noise</em>. A noise analysis determines a <em>bound</em> on
the noise and tracks its evolution after each HE operation. The noise should not
exceed certain bounds imposed by HE schemes.</p><p>There are two flavors of noise analyses: worst-case and average-case. Worst-case
noise analyses always track the bound, while some average-case noise analyses
use intermediate quantity like the variance to track their evolution, and derive
a bound when needed.</p><p>Currently, worst-case methods are often too conservative, while average-case
methods often give underestimation.</p><h2 id=noise-analysis-framework>Noise Analysis Framework</h2><p>HEIR implements noise analysis based on the <code>DataFlowFramework</code> in MLIR.</p><p>In the <code>DataFlowFramework</code>, the main function of an <code>Analysis</code> is
<code>visitOperation</code>, where it determines the <code>AnalysisState</code> for each SSA <code>Value</code>.
Usually it computes a transfer function deriving the <code>AnalysisState</code> for each
operation result based on the states of the operation&rsquo;s operands.</p><p>As there are various HE schemes in HEIR, the detailed transfer function is
defined by a <code>NoiseModel</code> class, which parameterizes the <code>NoiseAnalysis</code>.</p><p>The <code>AnalysisState</code>, depending on whether we are using worst-case noise model or
average-case, could be interpreted as the bound or the variance.</p><p>A typical way to use noise analysis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&#34;mlir/include/mlir/Analysis/DataFlow/Utils.h&#34;  // from @llvm-project</span><span style=color:#8f5902;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000>DataFlowSolver</span> <span style=color:#000>solver</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000>dataflow</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>loadBaselineAnalyses</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>solver</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// load other dependent analyses
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// schemeParam and model determined by other methods
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>solver</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>load</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>NoiseAnalysis</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>NoiseModel</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>schemeParam</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>model</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// run the analysis on the op
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>solver</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>initializeAndRun</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>op</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><h2 id=implemented-noise-models>Implemented Noise Models</h2><p>See the <a href=/docs/passes>Passes</a> page for details. Example passes include
<code>generate-param-bgv</code> and <code>validate-noise</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-76ae4da46c68c5cd44ad0ecf5d69993f>4 - Secret</h1><p>The <a href=https://heir.dev/docs/dialects/secret/><code>secret</code> dialect</a> contains types
and operations to represent generic computations on secret data. It is intended
to be a high-level entry point for the HEIR compiler, agnostic of any particular
FHE scheme.</p><p>Most prior FHE compiler projects design their IR around a specific FHE scheme,
and provide dedicated IR types for the secret analogues of existing data types,
and/or dedicated operations on secret data types. For example, the Concrete
compiler has <code>!FHE.eint&lt;32></code> for an encrypted 32-bit integer, and <code>add_eint</code> and
similar ops. HECO has <code>!fhe.secret&lt;T></code> that models a generic secret type, but
similarly defines <code>fhe.add</code> and <code>fhe.multiply</code>, and other projects are similar.</p><p>The problem with this approach is that it is difficult to incorporate the apply
upstream canonicalization and optimization passes to these ops. For example, the
<code>arith</code> dialect in MLIR has
<a href=https://sourcegraph.com/github.com/llvm/llvm-project@0ab3f160c4bff1c7d57c046b95ab8c5035ae986f/-/blob/mlir/lib/Dialect/Arith/IR/ArithCanonicalization.td>canonicalization patterns</a>
that must be replicated to apply to FHE analogues. One of the goals of HEIR is
to reuse as much upstream infrastructure as possible, and so this led us to
design the <code>secret</code> dialect to have both generic types and generic computations.
Thus, the <code>secret</code> dialect has two main parts: a <code>secret&lt;T></code> type that wraps any
other MLIR type <code>T</code>, and a <code>secret.generic</code> op that lifts any computation on
cleartext to the &ldquo;corresponding&rdquo; computation on secret data types.</p><h2 id=overview-with-bgv-style-lowering-pipeline>Overview with BGV-style lowering pipeline</h2><p>Here is an example of a program that uses <code>secret</code> to lift a dot product
computation:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@dot_product</span><span style=color:#000;font-weight:700>(</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;,</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c0_i16</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#000>%arg3</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%arg4</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>8</span> iter_args<span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg5</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>%c0_i16</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      <span style=color:#000>%extracted</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>extract <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg4</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#000>%extracted_0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>extract <span style=color:#000>%arg3</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg4</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%extracted</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%extracted_0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>      <span style=color:#000>%3</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%arg5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>      affine<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%3</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>The operands to the <code>generic</code> op are the secret data types, and the op contains
a single region, whose block arguments are the corresponding cleartext data
values. Then the region is free to perform any computation, and the values
passed to <code>secret.yield</code> are lifted back to <code>secret</code> types. Note that
<code>secret.generic</code> is not isolated from its enclosing scope, so one may refer to
cleartext SSA values without adding them as generic operands and block
arguments.</p><p>Clearly <code>secret.generic</code> does not actually do anything. It is not decrypting
data. It is merely describing the operation that one wishes to apply to the
secret data in more familiar terms. It is a structural operation, primarily used
to demarcate which operations involve secret operands and have secret results,
and group them for later optimization. The benefit of this is that one can write
optimization passes on types and ops that are not aware of <code>secret</code>, and they
will naturally match on the bodies of <code>generic</code> ops.</p><p>For example, here is what the above dot product computation looks like after
applying the <code>-cse -canonicalize -heir-simd-vectorizer</code> passes, the
implementations of which do not depend on <code>secret</code> or <code>generic</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@dot_product</span><span style=color:#000;font-weight:700>(</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;,</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c2</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c4</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c7</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>7</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#000>%arg3</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg3</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span>_ext<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c4</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%3</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span>_ext<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%5</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%4</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%6</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span>_ext<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%7</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%6</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%extracted</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>extract <span style=color:#000>%7</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%c7</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%extracted</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>The canonicalization patterns for <code>secret.generic</code> apply a variety of
simplifications, such as:</p><ul><li>Removing any unused or non-secret arguments and return values.</li><li>Hoisting operations in the body of a <code>generic</code> that only depend on cleartext
values to the enclosing scope.</li><li>Removing any <code>generic</code> ops that use no secrets at all.</li></ul><p>These can be used together with the
<a href=https://heir.dev/docs/passes/secretpasses/#-secret-distribute-generic><code>secret-distribute-generic</code> pass</a>
to split an IR that contains a large <code>generic</code> op into <code>generic</code> ops that
contain a single op, which can then be lowered to a particular FHE scheme
dialect with dedicated ops. This makes lowering easier because it gives direct
access to the secret version of each type that is used as input to an individual
op.</p><p>As an example, a single-op secret might look like this (taken from the larger
example below. Note the use of a cleartext from the enclosing scope, and the
proximity of the secret type to the op to be lowered.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span>  <span style=color:#000>%c2</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%3</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span>_ext<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span></code></pre></div><p>For a larger example, applying <code>--secret-distribute-generic --canonicalize</code> to
the IR above:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@dot_product</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;,</span> <span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c2</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c4</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c7</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>7</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#000>%arg3</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg3</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span>_ext<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c4</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#000>%arg3</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg3</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%3</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span>_ext<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%3</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#000>%arg3</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg3</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%5</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%4</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span>_ext<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%6</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%4</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%5</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;,</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#000>%arg3</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg3</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%7</span> <span style=color:#000;font-weight:700>=</span> secret<span style=color:#000;font-weight:700>.</span>generic<span style=color:#000;font-weight:700>(</span><span style=color:#000>%6</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f57900>^bb0</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;):</span>
</span></span><span style=display:flex><span>    <span style=color:#000>%extracted</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>.</span>extract <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%c7</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    secret<span style=color:#000;font-weight:700>.</span>yield <span style=color:#000>%extracted</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%7</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>And then lowering it to <code>bgv</code> with <code>--secret-to-bgv="poly-mod-degree=8"</code> (the
pass option matches the tensor size, but it is an unrealistic FHE polynomial
degree used here just for demonstration purposes). Note type annotations on ops
are omitted for brevity.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#encoding</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.polynomial_evaluation_encoding</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cleartext_start =</span> <span style=color:#0000cf;font-weight:700>16</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>cleartext_bitwidth =</span> <span style=color:#0000cf;font-weight:700>16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>#params</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#lwe.rlwe_params</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>ring =</span> <span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>cmod=</span><span style=color:#0000cf;font-weight:700>463187969</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>ideal=</span><span style=color:#000>#_polynomial.polynomial</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1</span> <span style=color:#a40000>+</span> <span style=color:#000;font-weight:700>x**</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#000;font-weight:700>&gt;&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>ty1 =</span> <span style=color:#000;font-weight:700>!</span>lwe<span style=color:#000;font-weight:700>.</span>rlwe_ciphertext<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>encoding=</span><span style=color:#000>#encoding</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>rlwe_params=</span><span style=color:#000>#params</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>underlying_type=</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>!</span><span style=color:#f57900>ty2 =</span> <span style=color:#000;font-weight:700>!</span>lwe<span style=color:#000;font-weight:700>.</span>rlwe_ciphertext<span style=color:#000;font-weight:700>&lt;</span><span style=color:#f57900>encoding=</span><span style=color:#000>#encoding</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>rlwe_params=</span><span style=color:#000>#params</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>underlying_type=</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@dot_product</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>ty1<span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>!</span>ty1<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>!</span>ty2 <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c2</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c4</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c7</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>7</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>index</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> bgv<span style=color:#000;font-weight:700>.</span>mul <span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> bgv<span style=color:#000;font-weight:700>.</span>relinearize <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>from_basis =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#f57900>to_basis =</span> array<span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>&gt;}</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> bgv<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c4</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%3</span> <span style=color:#000;font-weight:700>=</span> bgv<span style=color:#000;font-weight:700>.</span>add <span style=color:#000>%1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%2</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> bgv<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c2</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%5</span> <span style=color:#000;font-weight:700>=</span> bgv<span style=color:#000;font-weight:700>.</span>add <span style=color:#000>%3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%4</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%6</span> <span style=color:#000;font-weight:700>=</span> bgv<span style=color:#000;font-weight:700>.</span>rotate <span style=color:#000>%5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%7</span> <span style=color:#000;font-weight:700>=</span> bgv<span style=color:#000;font-weight:700>.</span>add <span style=color:#000>%5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%6</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> bgv<span style=color:#000;font-weight:700>.</span>extract <span style=color:#000>%7</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c7</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%8</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=differences-for-cggi-style-pipeline>Differences for CGGI-style pipeline</h2><p>The <code>mlir-to-cggi</code> and related pipelines add a few additional steps. The main
goal here is to apply a hardware circuit optimizer to blocks of standard MLIR
code (inside <code>secret.generic</code> ops) which converts the computation to an
optimized boolean circuit with a desired set of gates. Only then is
<code>-secret-distribute-generic</code> applied to split the ops up and lower them to the
<code>cggi</code> dialect. In particular, because passing an IR through the circuit
optimizer requires unrolling all loops, one useful thing you might want to do is
to optimize only the <em>body</em> of a for loop nest.</p><p>To accomplish this, we have two additional mechanisms. One is the pass option
<code>ops-to-distribute</code> for <code>-secret-distribute-generic</code>, which allows the user to
specify a list of ops that <code>generic</code> should be split across, and all others left
alone. Specifying <code>affine.for</code> here will pass <code>generic</code> through the <code>affine.for</code>
loop, but leave its body intact. This can also be used with the <code>-unroll-factor</code>
option to the <code>-yosys-optimizer</code> pass to partially unroll a loop nest and pass
the partially-unrolled body through the circuit optimizer.</p><p>The other mechanism is the <code>secret.separator</code> op, which is a purely structural
op that demarcates the boundary of a subset of a block that should be jointly
optimized in the circuit optimizer.</p><p>For example, the following <code>tosa</code> ops lower to multiple linalg instructions, and
hence multiple for loops, that we want to pass to a circuit optimizer as a unit.
The <code>secret.separator</code> ops surrounding the op are preserved through the
lowering.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@main</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x1x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>})</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  secret<span style=color:#000;font-weight:700>.</span>separator
</span></span><span style=display:flex><span>  <span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#4e9a06>&#34;tosa.const&#34;</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>value =</span> dense<span style=color:#000;font-weight:700>&lt;[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>-5438</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>-5515</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>-1352</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>-1500</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>-4152</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>-84</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3396</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1981</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>-5581</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>-6964</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>3407</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>-7217</span><span style=color:#000;font-weight:700>]&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%5</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#4e9a06>&#34;tosa.const&#34;</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>value =</span> dense<span style=color:#000;font-weight:700>&lt;[[</span><span style=color:#0000cf;font-weight:700>-9</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>-54</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>57</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>71</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>104</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>115</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>98</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>99</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>64</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>-26</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>127</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>25</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>-82</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>68</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>95</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>86</span><span style=color:#000;font-weight:700>]]&gt;</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x1x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x1x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%6</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#4e9a06>&#34;tosa.matmul&#34;</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>a_zp =</span> <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>,</span> <span style=color:#f57900>b_zp =</span> <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x5x3x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x3x6x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;)</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x5x6x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  secret<span style=color:#000;font-weight:700>.</span>separator
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%6</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>After running <code>--mlir-to-cggi</code> and dumping the IR after the linalg ops are
lowered to loops, we can see the <code>secret.separator</code> ops enclose the lowered ops,
with the exception of some pure ops that are speculatively executed.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>@main</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x1x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>,</span> strided<span style=color:#000;font-weight:700>&lt;[</span><span style=color:#a40000>?</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>?</span><span style=color:#000;font-weight:700>],</span> offset<span style=color:#000;font-weight:700>:</span> <span style=color:#a40000>?</span><span style=color:#000;font-weight:700>&gt;&gt;</span> <span style=color:#000;font-weight:700>{</span>secret<span style=color:#000;font-weight:700>.</span>secret<span style=color:#000;font-weight:700>})</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%c</span><span style=color:#0000cf;font-weight:700>-128</span><span style=color:#f57900>_i32 =</span> arith<span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>constant</span> <span style=color:#0000cf;font-weight:700>-128</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>.</span>get_global <span style=color:#000>@__constant_16xi32</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>.</span>get_global <span style=color:#000>@__constant_16x1xi8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x1x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  secret<span style=color:#000;font-weight:700>.</span>separator
</span></span><span style=display:flex><span>  <span style=color:#000>%alloc</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>.</span>alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>alignment =</span> <span style=color:#0000cf;font-weight:700>64</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%arg2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>16</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>load <span style=color:#000>%1</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x1x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>      affine<span style=color:#000;font-weight:700>.</span>store <span style=color:#000>%2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%alloc</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000>%alloc_0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>.</span>alloc<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>alignment =</span> <span style=color:#0000cf;font-weight:700>64</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i64</span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%arg2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>16</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>load <span style=color:#000>%0</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>      affine<span style=color:#000;font-weight:700>.</span>store <span style=color:#000>%2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%alloc_0</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%arg1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%arg2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>16</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      affine<span style=color:#000;font-weight:700>.</span>for <span style=color:#000>%arg3</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span> to <span style=color:#0000cf;font-weight:700>1</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>load <span style=color:#000>%arg0</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg3</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x1x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>,</span> strided<span style=color:#000;font-weight:700>&lt;[</span><span style=color:#a40000>?</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>?</span><span style=color:#000;font-weight:700>],</span> offset<span style=color:#000;font-weight:700>:</span> <span style=color:#a40000>?</span><span style=color:#000;font-weight:700>&gt;&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>%3</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>load <span style=color:#000>%alloc</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> affine<span style=color:#000;font-weight:700>.</span>load <span style=color:#000>%alloc_0</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>%5</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>extsi <span style=color:#000>%2</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i8</span> to <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>        <span style=color:#000>%6</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>subi <span style=color:#000>%5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c</span><span style=color:#0000cf;font-weight:700>-128</span>_i32 <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>        <span style=color:#000>%7</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>extsi <span style=color:#000>%3</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i8</span> to <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>        <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>muli <span style=color:#000>%6</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%7</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>        <span style=color:#000>%9</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%4</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%8</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>i32</span>
</span></span><span style=display:flex><span>        affine<span style=color:#000;font-weight:700>.</span>store <span style=color:#000>%9</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%alloc_0</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%arg1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%arg2</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  secret<span style=color:#000;font-weight:700>.</span>separator
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>.</span>dealloc <span style=color:#000>%alloc</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i8</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>%alloc_0</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>memref</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>1x16x</span><span style=color:#204a87;font-weight:700>i32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>We decided to use the <code>separator</code> op over a few alternatives:</p><ul><li>Grouping by <code>secret.generic</code>: these <code>tosa</code> ops must be bufferized, but
<code>secret</code> types cannot participate in bufferization (see the Limitations
section).</li><li>Grouping by basic blocks: <code>secret.generic</code> is a single-block op with a yield
terminator, and grouping by blocks would require us to change this.</li><li>Grouping by regions: SSA values generated by a region are not visible to the
enclosing scope, so we would need to have the region-bearing op return values,
which is tedious to organize.</li><li>Attaching attributes to ops that should be grouped together: this would not be
preserved by upstream lowerings and optimization passes.</li></ul><h2 id=generic-operands><code>generic</code> operands</h2><p><code>secret.generic</code> takes any SSA values as legal operands. They may be <code>secret</code>
types or non-secret. Canonicalizing <code>secret.generic</code> removes non-secret operands
and leaves them to be referenced via the enclosing scope (<code>secret.generic</code> is
not <code>IsolatedFromAbove</code>).</p><p>This may be unintuitive, as one might expect that only secret types are valid
arguments to <code>secret.generic</code>, and that a verifier might assert non-secret args
are not present.</p><p>However, we allow non-secret operands because it provides a convenient scope
encapsulation mechanism, which is useful for the <code>--yosys-optimizer</code> pass that
runs a circuit optimizer on individual <code>secret.generic</code> ops and needs to have
access to all SSA values used as inputs. The following passes are related to
this functionality:</p><ul><li><code>secret-capture-generic-ambient-scope</code></li><li><code>secret-generic-absorb-constants</code></li><li><code>secret-extract-generic-body</code></li></ul><p>Due to the canonicalization rules for <code>secret.generic</code>, anyone using these
passes as an IR organization mechanism must be sure not to canonicalize before
accomplishing the intended task.</p><h2 id=limitations>Limitations</h2><h3 id=bufferization>Bufferization</h3><p>Secret types cannot participate in bufferization passes. In particular,
<code>-one-shot-bufferize</code> hard-codes the notion of tensor and memref types, and so
it cannot currently operate on <code>secret&lt;tensor&lt;...>></code> or <code>secret&lt;memref&lt;...>></code>
types, which prevents us from implementing a bufferization interface for
<code>secret.generic</code>. This was part of the motivation to introduce
<code>secret.separator</code>, because <code>tosa</code> ops like a fully connected neural network
layer lower to multiple linalg ops, and these ops need to be bufferized before
they can be lowered further. However, we want to keep the lowered ops grouped
together for circuit optimization (e.g., fusing transposes and constant weights
into the optimized layer), but because of this limitation, we can&rsquo;t simply wrap
the <code>tosa</code> ops in a <code>secret.generic</code> (bufferization would fail).</p></div><div class=td-content style=page-break-before:always><h1 id=pg-05018faa55dd802660a3ea38b8f7fb69>5 - SIMD Optimizations</h1><p>HEIR includes a SIMD (Single Instruction, Multiple Data) optimizer which is
designed to exploit the restricted SIMD parallelism most (Ring-LWE-based) FHE
schemes support (also commonly known as &ldquo;packing&rdquo; or &ldquo;batching&rdquo;). Specifically,
HEIR incorporates the &ldquo;automated batching&rdquo; optimizations (among many other
things) from the <a href=https://github.com/MarbleHE/HECO>HECO</a> compiler. The
following will assume basic familiarity with the FHE SIMD paradigm and the
high-level goals of the optimization, and we refer to the associated HECO
<a href=https://www.usenix.org/system/files/usenixsecurity23-viand.pdf>paper</a>,
<a href=https://www.usenix.org/system/files/sec23_slides_viand.pdf>slides</a>,
<a href="https://www.youtube.com/watch?v=SP3C6gLWIS4">talk</a> and additional resources on
the
<a href=https://www.usenix.org/conference/usenixsecurity23/presentation/viand>Usenix'23 website</a>
for an introduction to the topic. This documentation will mostly focus on
describing how the optimization is realized in HEIR (which differs somewhat from
the original implementation) and how the optimization is intended to be used in
an overall end-to-end compilation pipeline.</p><h2 id=representing-fhe-simd-operations>Representing FHE SIMD Operations</h2><p>Following the design principle of maintaining programs in standard MLIR dialects
as long as possible (cf. the design rationale behind the
<a href=https://heir.dev/docs/design/secret/>Secret Dialect</a>), HEIR uses the MLIR
<a href=https://mlir.llvm.org/docs/Dialects/TensorOps/><code>tensor</code> dialect</a> and
<a href=https://mlir.llvm.org/docs/Traits/#elementwisemappable>ElementwiseMappable</a>
operations from the MLIR
<a href=https://mlir.llvm.org/docs/Dialects/ArithOps/><code>arith</code> dialect</a> to represent HE
SIMD operations.</p><p>We do introduce the HEIR-specific
<a href=https://heir.dev/docs/dialects/tensorext/#tensor_extrotate-heirtensor_extrotateop><code>tensor_ext.rotate</code></a>
operation, which represents a cyclical left-rotation of a tensor. Note that, as
the current SIMD vectorizer only supports one-dimensional tensors, the semantics
of this operation on multi-dimensional tensors are not (currently) defined.</p><p>For example, the common &ldquo;rotate-and-reduce&rdquo; pattern which results in each
element containing the sum/product/etc of the original vector can be expressed
as:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%tensor</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>from_elements</span> <span style=color:#000>%i1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%i2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%i3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%i4</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%i5</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%i6</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%i7</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%i8</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tensor_ext</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>rotate</span> <span style=color:#000>%tensor</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c4</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#a40000>inde</span><span style=color:#204a87;font-weight:700>x</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>addi</span> <span style=color:#000>%tensor</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%0</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tensor_ext</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>rotate</span> <span style=color:#000>%1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c2</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#a40000>inde</span><span style=color:#204a87;font-weight:700>x</span>
</span></span><span style=display:flex><span><span style=color:#000>%3</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>addi</span> <span style=color:#000>%1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%2</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%4</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tensor_ext</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>rotate</span> <span style=color:#000>%3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#a40000>inde</span><span style=color:#204a87;font-weight:700>x</span>
</span></span><span style=display:flex><span><span style=color:#000>%5</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>addi</span> <span style=color:#000>%3</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%4</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>The <code>%cN</code> and <code>%iN</code>, which are defined as <code>%cN = arith.constant N : index</code> and
<code>%iN = arith.constant N : i16</code>, respectively, have been omitted for readability.</p><h2 id=intended-usage>Intended Usage</h2><p>The <code>-heir-simd-vectorizer</code> pipeline transforms a program consisting of loops
and index-based accesses into tensors (e.g., <code>tensor.extract</code> and
<code>tensor.insert</code>) into one consisting of SIMD operations (including rotations) on
entire tensors. While its implementation does not depend on any FHE-specific
details or even the Secret dialect, this transformation is likely only useful
when lowering a high-level program to an arithmetic-circuit-based FHE scheme
(e.g., B/FV, BGV, or CKKS). The <code>--mlir-to-bgv --scheme-to-openfhe</code> pipeline
demonstrates the intended flow: augmenting a high-level program with <code>secret</code>
annotations, then applying the SIMD optimization (and any other high-level
optimizations) before lowering to BGV operations and then exiting to OpenFHE.</p><blockquote><p><strong>Warning</strong> The current SIMD vectorizer pipeline supports only one-dimensional
tensors. As a workaround, one could reshape all multi-dimensional tensors into
one-dimensional tensors, but MLIR/HEIR currently do not provide a pass to
automate this process.</p></blockquote><p>Since the optimization is based on heuristics, the resulting program might not
be optimal or could even be worse than a trivial realization that does not use
ciphertext packing. However, well-structured programs generally lower to
reasonable batched solutions, even if they do not achieve optimal batching
layouts. For common operations such as matrix-vector or matrix-matrix
multiplications, state-of-the-art approaches require advanced packing schemes
that might map elements into the ciphertext vector in non-trivial ways (e.g.,
diagonal-major and/or replicated). The current SIMD vectorizer will never change
the arrangement of elements inside an input tensor and therefore cannot produce
the optimal approaches for these operations.</p><p>Note, that the SIMD batching optimization is different from, and significantly
more complex than, the Straight Line Vectorizer (<code>-straight-line-vectorize</code>
pass), which simply groups
<a href=https://mlir.llvm.org/docs/Traits/#elementwisemappable>ElementwiseMappable</a>
operations that agree in operation name and operand/result types into
vectorized/tensorized versions.</p><h2 id=implementation>Implementation</h2><p>Below, we give a brief overview over the implementation, with the goal of both
improving maintainability/extensibility of the SIMD vectorizer and allowing
advanced users to better understand why a certain program is transformed in the
way it is.</p><h3 id=components>Components</h3><p>The <code>-heir-simd-vectorizer</code> pipeline uses a combination of standard MLIR passes
(<a href=https://mlir.llvm.org/docs/Passes/#-canonicalize><code>-canonicalize</code></a>,
<a href=https://mlir.llvm.org/docs/Passes/#-cse><code>-cse</code></a>,
<a href=https://mlir.llvm.org/docs/Passes/#-sccp><code>-sccp</code></a>) and custom HEIR passes.
Some of these
(<a href=https://heir.dev/docs/passes/applyfolderspasses/#-apply-folders><code>-apply-folders</code></a>,
<a href=https://heir.dev/docs/passes/fullloopunrollpasses/#-full-loop-unroll><code>-full-loop-unroll</code></a>)
might have applications outside the SIMD optimization, while others
(<a href=https://heir.dev/docs/passes/tensorextpasses/#-insert-rotate><code>-insert-rotate</code></a>,
<a href=https://heir.dev/docs/passes/tensorextpasses/#-collapse-insertion-chains><code>-collapse-insertion-chains</code></a>
and
<a href=https://heir.dev/docs/passes/tensorextpasses/#-rotate-and-reduce><code>-rotate-and-reduce</code></a>)
are very specific to the FHE SIMD optimization. In addition, the passes make use
of the <code>RotationAnalysis</code> and <code>TargetSlotAnalysis</code> analyses.</p><h3 id=high-level-flow>High-Level Flow</h3><ul><li><p><strong>Loop Unrolling</strong> (<code>-full-loop-unroll</code>): The implementation currently begins
by unrolling all loops in the program to simplify the later passes. See
<a href=https://github.com/google/heir/issues/589>#589</a> for a discussion on how this
could be avoided.</p></li><li><p><strong>Canonicalization</strong> (<code>-apply-folders -canonicalize</code>): As the
rotation-specific passes are very strict about the structure of the IR they
operate on, we must first simplify away things such as tensors of constant
values. For performance reasons (c.f. comments in the
<code>heirSIMDVectorizerPipelineBuilder</code> function in <code>heir-opt.cpp</code>), this must be
done by first applying
<a href=https://mlir.llvm.org/docs/Canonicalization/#canonicalizing-with-the-fold-method>folds</a>
before applying the full
<a href=https://mlir.llvm.org/docs/Canonicalization/>canonicalization</a>.</p></li><li><p><strong>Main SIMD Rewrite</strong> (<code>-insert-rotate -cse -canonicalize -cse</code>): This pass
rewrites arithmetic operations over <code>tensor.extract</code>-ed operands into SIMD
operations over the entire tensor, rotating the (full-tensor) operands so that
the correct elements interact. For example, it will rewrite the following
snippet (which computes <code>t2[4] = t0[3] + t1[5]</code>)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>extract</span> <span style=color:#000>%t0</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%c3</span><span style=color:#000;font-weight:700>]</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>extract</span> <span style=color:#000>%t1</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%c5</span><span style=color:#000;font-weight:700>]</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>addi</span> <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span> <span style=color:#a40000>:</span> <span style=color:#204a87;font-weight:700>i16</span>
</span></span><span style=display:flex><span><span style=color:#000>%3</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>insert</span> <span style=color:#000>%2</span> <span style=color:#a40000>in</span><span style=color:#204a87;font-weight:700>to</span> <span style=color:#000>%t2</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%c4</span><span style=color:#000;font-weight:700>]</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>to</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tensor_ext</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>rotate</span> <span style=color:#000>%t0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c31</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#a40000>inde</span><span style=color:#204a87;font-weight:700>x</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tensor_ext</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>rotate</span> <span style=color:#000>%t1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%c1</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;,</span> <span style=color:#a40000>inde</span><span style=color:#204a87;font-weight:700>x</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>addi</span> <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>i.e., rotating <code>t0</code> down by one (31 = -1 (mod 32)) and <code>t1</code> up by one to bring
the elements at index 3 and 5, respectively, to the &ldquo;target&rdquo; index 4. The pass
uses the <code>TargetSlotAnalysis</code> to identify the appropriate target index (or
ciphertext &ldquo;slot&rdquo; in FHE-speak). See <a href=#insert-rotate-pass>Insert Rotate Pass</a>
below for more details. This pass is roughly equivalent to the <code>-batching</code>
pass in the original HECO implementation.</p><p>Doing this rewrite by itself does not represent an optimization, but if we
consider what happens to the corresponding code for other indices (e.g.,
<code>t2[5] = t0[4] + t1[6]</code>), we see that the pass transforms expressions with the
same relative index offsets into the exact same set of rotations/SIMD
operations, so the following
<a href=https://en.wikipedia.org/wiki/Common_subexpression_elimination>Common Subexpression Elimination (CSE)</a>
will remove redundant computations. We apply CSE twice, once directly (which
creates new opportunities for canonicalization and folding) and then again
after that canonicalization. See
<a href=#tensorext-canonicalization>TensorExt Canonicalization</a> for a description of
the rotation-specific canonocalization patterns).</p></li><li><p><strong>Cleanup of Redundant Insert/Extract</strong>
(<code>-collapse-insertion-chains -sccp -canonicalize -cse</code>): Because the
<code>-insert-rotate</code> pass maintains the consistency of the IR, it emits a
<code>tensor.extract</code> operation after the SIMD operation and uses that to replace
the original operation (which is valid, as both produce the desired scalar
result). As a consequence, the generated code for the snippet above is
actually trailed by a (redundant) extract/insert:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%extracted</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>extract</span> <span style=color:#000>%2</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%c4</span><span style=color:#000;font-weight:700>]</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>%inserted</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>.</span><span style=color:#a40000>insert</span> <span style=color:#000>%extracted</span> <span style=color:#a40000>in</span><span style=color:#204a87;font-weight:700>to</span> <span style=color:#000>%t2</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>%c4</span><span style=color:#000;font-weight:700>]</span> <span style=color:#a40000>:</span> <span style=color:#a40000>tens</span><span style=color:#204a87;font-weight:700>or</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>32</span><span style=color:#a40000>x</span><span style=color:#204a87;font-weight:700>i16</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>In real code, this might generate a long series of such extraction/insertion
operations, all extracting from the same (due to CSE) tensor and inserting
into the same output tensor. Therefore, the <code>-collapse-insertion-chains</code> pass
searches for such chains over entire tensors and collapses them. It supports
not just chains where the indices match perfectly, but any chain where the
relative offset is consistent across the tensor, issuing a rotation to realize
the offset (if the offset is zero, the canonicalization will remove the
redundant rotation). Note, that in HECO, insertion/extraction is handled
differently, as HECO features a <code>combine</code> operation modelling not just simple
insertions (<code>combine(%t0#j, %t1)</code>) but also more complex operations over
slices of tensors (<code>combine(%t0#[i,j], %t1)</code>). As a result, the equivalent
pass in HECO (<code>-combine-simplify</code>) instead joins different <code>combine</code>
operations, and a later fold removes <code>combines</code> that replace the entire target
tensor. See issue <a href=https://github.com/google/heir/issues/512>#512</a> for a
discussion on why the <code>combine</code> operation is a more powerful framework and
what would be necessary to port it to HEIR.</p></li><li><p><strong>Applying Rotate-and-Reduce Patterns</strong>
(<code>-rotate-and-reduce -sccp -canonicalize -cse</code>): The rotate and reduce pattern
(see <a href=#representing-fhe-simd-operations>Representing FHE SIMD Operations</a> for
an example) is an important aspect of accelerating SIMD-style operations in
FHE, but it does not follow automatically from the batching rewrites applied
so far. As a result, the <code>-rotate-and-reduce</code> pass needs to search for
sequences of arithmetic operations that correspond to the full folding of a
tensor, i.e., patterns such as <code>t[0]+(t[1]+(t[2]+t[3]+(...)))</code>, which
currently uses a backwards search through the IR, but could be achieved more
efficiently through a data flow analysis (c.f. issue
<a href=https://github.com/google/heir/issues/523>#532</a>). In HECO, rotate-and-reduce
is handled differently, by identifying sequences of compatible operations
prior to batching and rewriting them to &ldquo;n-ary&rdquo; operations. However, this
approach requires non-standard arithmetic operations and is therefore not
suitable for use in HEIR. However, there is likely still an opportunity to
make the patterns in HEIR more robust/general (e.g., support constant scalar
operands in the fold, or support non-full-tensor folds). See issue
<a href=https://github.com/google/heir/issues/522>#522</a> for ideas on how to make the
HEIR pattern more robust/more general.</p></li></ul><h3 id=insert-rotate-pass>Insert Rotate Pass</h3><p>TODO(#721): Write a detailed description of the rotation insertion pass and the
associated target slot analysis.</p><h3 id=tensorext-canonicalization>TensorExt Canonicalization</h3><p>The
<a href=https://heir.dev/docs/dialects/tensorext/>TensorExt (<code>tensor_ext</code>) Dialect</a>
includes a series of canonicalization rules that are essential to making
automatically generated rotation code efficient:</p><ul><li><p>Rotation by zero: <code>rotate %t, 0</code> folds away to <code>%t</code></p></li><li><p>Cyclical wraparound: <code>rotate %t, k</code> for $k > t.size$ can be simplified to
<code>rotate %t, (k mod t.size)</code></p></li><li><p>Sequential rotation: <code>%0 = rotate %t, k</code> followed by <code>%1 = rotate %0, l</code> is
simplified to <code>rotate %t (k+l)</code></p></li><li><p>Extraction: <code>%0 = rotate %t, k</code> followed by <code>%1 = tensor.extract %0[l]</code> is
simplified to <code>tensor.extract %t[k+l]</code></p></li><li><p>Binary Arithmetic Ops: where both operands to a binary <code>arith</code> operation are
rotations by the same amount, the rotation can be performed only once, on the
result. For Example,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%t1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>k</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%t2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>k</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>add</span> <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span>
</span></span></code></pre></div><p>can be simplified to</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>add</span> <span style=color:#000>%t1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%t2</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>k</span>
</span></span></code></pre></div></li><li><p><em>Sandwiched</em> Binary Arithmetic Ops: If a rotation follows a binary <code>arith</code>
operation which has rotation as its operands, the post-arith operation can be
moved forward. For example,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%t1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>x</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%t2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>y</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>add</span> <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span>
</span></span><span style=display:flex><span><span style=color:#000>%3</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>z</span>
</span></span></code></pre></div><p>can be simplified to</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%t1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>x</span> <span style=color:#a40000>+</span> <span style=color:#a40000>z</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%t2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>y</span> <span style=color:#a40000>+</span> <span style=color:#a40000>z</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>add</span> <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span>
</span></span></code></pre></div></li><li><p>Single-Use Arithmetic Ops: Finally, there is a pair of rules that do not
eliminate rotations, but move rotations up in the IR, which can help in
exposing further canonicalization and/or CSE opportunities. These only apply
to <code>arith</code> operations with a single use, as they might otherwise increase the
total number of rotations. For example,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%t1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>k</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>add</span> <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%t2</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>l</span>
</span></span></code></pre></div><p>can be equivalently rewritten as</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span><span style=color:#000>%0</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%t1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>(</span><span style=color:#a40000>k+l</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>rotate</span> <span style=color:#000>%t2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#a40000>l</span>
</span></span><span style=display:flex><span><span style=color:#000>%2</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#a40000>arith</span><span style=color:#000;font-weight:700>.</span><span style=color:#204a87;font-weight:700>add</span> <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span>
</span></span></code></pre></div><p>and a similar pattern exists for situations where the rotation is the rhs
operand of the arithmetic operation.</p></li></ul><p>Note that the index computations in the patterns above (e.g., <code>k+l</code>,
<code>k mod t.size</code> are realized via emitting <code>arith</code> operations. However, for
constant/compile-time-known indices, these will be subsequently constant-folded
away by the canonicalization pass.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cd22aa05be277ba6c2e2f8f083706b51>6 - Optimizing relinearization</h1><p>This document outlines the integer linear program model used in the
<a href=https://heir.dev/docs/passes/optimizerelinearizationpasses/#-optimize-relinearization><code>optimize-relinearization</code></a>
pass.</p><h2 id=background>Background</h2><p>In vector/arithmetic FHE, RLWE ciphertexts often have the form $\mathbf{c} =
(c_0, c_1)$, where the details of how $c_0$ and $c_1$ are computed depend on the
specific scheme. However, in most of these schemes, the process of decryption
can be thought of as taking a dot product between the vector $\mathbf{c}$ and a
vector $(1, s)$ containing the secret key $s$ (followed by rounding).</p><p>In such schemes, the homomorphic multiplication of two ciphertexts $\mathbf{c}
= (c_0, c_1)$ and $\mathbf{d} = (d_0, d_1)$ produces a ciphertext $\mathbf{f}
= (f_0, f_1, f_2)$. This triple can be decrypted by taking a dot product with
$(1, s, s^2)$.</p><p>With this in mind, each RLWE ciphertext $\mathbf{c}$ has an associated <em>key
basis</em>, which is the vector $\mathbf{s_c}$ whose dot product with $\mathbf{c}$
decrypts it.</p><p>Usually a larger key basis is undesirable. For one, operations in a higher key
basis are more expensive and have higher rates of noise growth. Repeated
multiplications exponentially increase the length of the key basis. So to avoid
this, an operation called <em>relinearization</em> was designed that converts a
ciphertext from a given key basis back to $(1, s)$. Doing this requires a set of
<em>relinearization keys</em> to be provided by the client and stored by the server.</p><p>In general, key bases can be arbitrary. Rotation of an RLWE ciphertext by a
shift of $k$, for example, first applies the automorphism $x \mapsto x^k$. This
converts the key basis from $(1, s)$ to $(1, s^k)$, and more generally maps $(1,
s, s^2, \dots, s^d) \mapsto (1, s^k, s^{2k}, \dots, s^{kd})$. Most FHE
implementations post-compose this automorphism with a key switching operation to
return to the linear basis $(1, s)$. Similarly, multiplication can be defined
for two key bases $(1, s^n)$ and $(1, s^m)$ (with $n &lt; m$) to produce a key
basis $(1, s^n, s^m, s^{n+m})$. By a combination of multiplications and
rotations (without ever relinearizing or key switching), ciphertexts with a
variety of strange key bases can be produced.</p><p>Most FHE implementations do not permit wild key bases because each key switch
and relinearization operation (for each choice of key basis) requires additional
secret key material to be stored by the server. Instead, they often enforce that
rotation has key-switching built in, and multiplication relinearizes by default.</p><p>That said, many FHE implementations do allow for the relinearization operation
to be deferred. A useful such situation is when a series of independent
multiplications are performed, and the results are added together. Addition can
operate in any key basis (though depending on the backend FHE implementation&rsquo;s
details, all inputs may require the same key basis, cf.
<a href=#optional-operand-agreement>Optional operand agreement</a>), and so the
relinearization op that follows each multiplication can be deferred until after
the additions are complete, at which point there is only one relinearization to
perform. This technique is usually called <em>lazy relinearization</em>. It has the
benefit of avoiding expensive relinearization operations, as well as reducing
noise growth, as relinearization adds noise to the ciphertext, which can further
reduce the need for bootstrapping.</p><p>In much of the literature, lazy relinearization is applied manually. See for
example
<a href=https://eprint.iacr.org/2019/223>Blatt-Gusev-Polyakov-Rohloff-Vaikuntanathan 2019</a>
and <a href=https://eprint.iacr.org/2020/1549>Lee-Lee-Kim-Kim-No-Kang 2020</a>. In some
compiler projects, such as the <a href=https://eprint.iacr.org/2021/1505>EVA compiler</a>
relinearization is applied automatically via a heuristic, either &ldquo;eagerly&rdquo;
(immediately after each multiplication op) or &ldquo;lazily,&rdquo; deferred as late as
possible.</p><h2 id=the-optimize-relinearization-pass>The <code>optimize-relinearization</code> pass</h2><p>In HEIR, relinearization placement is implemented via a mixed-integer linear
program (ILP). It is intended to be more general than a lazy relinearization
heuristic, and certain parameter settings of the ILP reproduce lazy
relinearization.</p><p>The <code>optimize-relinearization</code> pass starts by deleting all relinearization
operations from the IR, solves the ILP, and then inserts relinearization ops
according to the solution. This implies that the input IR to the ILP has no
relinearization ops in it already.</p><h2 id=model-specification>Model specification</h2><p>The ILP model fits into a family of models that is sometimes called
&ldquo;state-dynamics&rdquo; models, in that it has &ldquo;state&rdquo; variables that track a quantity
that flows through a system, as well as &ldquo;decision&rdquo; variables that control
decisions to change the state at particular points. A brief overview of state
dynamics models can be found
<a href=https://buttondown.com/j2kun/archive/modeling-state-in-linear-programs/>here</a></p><p>In this ILP, the &ldquo;state&rdquo; value is the degree of the key basis. I.e., rather than
track the entire key basis, we assume the key basis always has the form $(1, s,
s^2, \dots, s^k)$ and track the value $k$. The index tracking state is SSA
value, and the decision variables are whether to relinearize.</p><h3 id=variables>Variables</h3><p>Define the following variables:</p><ul><li>For each operation $o$, $R_o \in { 0, 1 }$ defines the decision to
relinearize the result of operation $o$. Relinearization is applied if and
only if $R_o = 1$.</li><li>For each SSA value $v$, $\textup{KB}_v$ is a continuous variable
representing the degree of the key basis of $v$. For example, if the key basis
of a ciphertext is $(1, s)$, then $\textup{KB}_v = 1$. If $v$ is the result
of an operation $o$, $\textup{KB}_v$ is the key basis of the result of $o$
<em>after</em> relinearization has been optionally applied to it, depending on the
value of the decision variable $R_o$.</li><li>For each SSA value $v$ that is an operation result, $\textup{KB}^{br}_v$ is
a continuous variable whose value represents the key basis degree of $v$
<em>before</em> relinearization is applied (<code>br</code> = &ldquo;before relin&rdquo;). These SSA values
are mainly for <em>after</em> the model is solved and relinearization operations need
to be inserted into the IR. Here, type conflicts require us to reconstruct the
key basis degree, and saving the values allows us to avoid recomputing the
values.</li></ul><p>Each of the key-basis variables is bounded from above by a parameter
<code>MAX_KEY_BASIS_DEGREE</code> that can be used to impose hard limits on the key basis
size, which may be required if generating code for a backend that does not
support operations over generalized key bases.</p><h3 id=objective>Objective</h3><p>The objective is to minimize the number of relinearization operations, i.e.,
$\min \sum_o R_o$.</p><p>TODO(#1018): update docs when objective is generalized.</p><h3 id=constraints>Constraints</h3><h4 id=simple-constraints>Simple constraints</h4><p>The simple constraints are as follows:</p><ul><li>Initial key basis degree: For each block argument, $\textup{KB}_v$ is fixed
to equal the <code>dimension</code> parameter on the RLWE ciphertext type.</li><li>Special linearized ops: <code>bgv.rotate</code> and <code>func.return</code> require linearized
inputs, i.e., $\textup{KB}_{v_i} = 1$ for all inputs $v_i$ to these
operations.</li><li>Before relinearization key basis: for each operation $o$ with operands $v_1,
\dots, v_k$, constrain $\textup{KB}^{br}_{\textup{result}(o)} =
f(\textup{KB}_{v_1}, \dots, \textup{KB}_{v_k})$, where $f$ is a
statically known linear function. For multiplication $f$ it addition, and for
all other ops it is the projection onto any input, since multiplication is the
only op that increases the degree, and all operands are constrained to have
equal degree.</li></ul><h4 id=optional-operand-agreement>Optional operand agreement</h4><p>There are two versions of the model, one where the an operation requires the
input key basis degrees of each operand to be equal, and one where differing key
basis degrees are allowed.</p><p>This is an option because the model was originally implemented under the
incorrect assumption that CPU backends like OpenFHE and Lattigo require the key
basis degree operands to be equal for ops like ciphertext addition. When we
discovered this was not the case, we generalized the model to support both
cases, in case other backends do have this requirement.</p><p>When operands must have the same key basis degree, then for each operation with
operand SSA values $v_1, \dots, v_k$, we add the constraint
$\textup{KB}_{v_1} = \dots = \textup{KB}_{v_k}$, i.e., all key basis inputs
must match.</p><p>When operands may have different key basis degrees, we instead add the
constraint that each operation result key basis degree (before relinearization)
is at least as large as the max of all operand key basis degrees. For all $i$,
$\textup{KB}_{\textup{result}(o)}^{br} \geq \textup{KB}_{v_i}$. Note that
we are relying on an implicit behavior of the model to ensure that, even if the
solver chooses key basis degree variables for these op results larger than the
max of the operand degrees, the resulting optimal solution is the same.</p><p>TODO(#1018): this will change to a more principled approach when the objective
is generalized</p><h4 id=impact-of-relinearization-choices-on-key-basis-degree>Impact of relinearization choices on key basis degree</h4><p>The remaining constraints control the dynamics of how the key basis degree
changes as relinearizations are inserted.</p><p>They can be thought of as implementing this (non-linear) constraint for each
operation $o$:</p><p>\[ \textup{KB}_{\textup{result}(o)} = \begin{cases}
\textup{KB}^{br}_{\textup{result(o)}} & \text{ if } R_o = 0 \\ 1 & \text{
if } R_o = 1 \end{cases} \]</p><p>Note that $\textup{KB}^{br}_{\textup{result}(o)}$ is constrained by one of
the simple constraints to be a linear expression containing key basis variables
for the operands of $o$. The conditional above cannot be implemented directly in
an ILP. Instead, one can implement it via four constraints that effectively
linearize (in the sense of making non-linear constraints linear) the multiplexer
formula</p><p>\[ \textup{KB}_{\textup{result}(o)} = (1 - R_o) \cdot
\textup{KB}^{br}_{\textup{result}(o)} + R_o \cdot 1 \]</p><p>(Note the above is not linear because in includes the product of two variables.)
The four constraints are:</p><p>\[ \begin{aligned} \textup{KB}_\textup{result}(o) &\geq \textup{ R}_o
\\
\textup{KB}_\textup{result}(o) &\leq 1 + C(1 – \textup{R}_o)
\\
\textup{KB}_\textup{result}(o) &\geq
\textup{KB}^{br}_{\textup{result}(o)} – C \textup{ R}_o
\\
\textup{KB}_\textup{result}(o) &\leq
\textup{KB}^{br}_{\textup{result}(o)} + C \textup{ R}_o \\
\end{aligned}
\]</p><p>Here $C$ is a constant that can be set to any value larger than
<code>MAX_KEY_BASIS_DEGREE</code>. We set it to 100.</p><p>Setting $R_o = 0$ makes constraints 1 and 2 trivially satisfied, while
constraints 3 and 4 enforce the equality $\textup{KB}_{\textup{result}(o)} =
\textup{KB}^{br}_{\textup{result}(o)}$. Likewise, setting $R_o = 1$ makes
constraints 3 and 4 trivially satisfied, while constraints 1 and 2 enforce the
equality $\textup{KB}_{\textup{result}(o)} = 1$.</p><h2 id=notes>Notes</h2><ul><li>ILP performance scales roughly with the number of integer variables. The
formulation above only requires the decision variable to be integer, and the
initialization and constraints effectively force the key basis variables to be
integer. As a result, the solve time of the above ILP should scale with the
number of ciphertext-handling ops in the program.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8c7f770d0d2ffa01c9ca233de813ffec>7 -</h1><hr><p>title: Ciphertext Packing System</p><h2 id=weight-9>weight: 9</h2><p>This document describes HEIR&rsquo;s ciphertext packing system, including:</p><ul><li>A notation and internal representation of a ciphertext packing, which we call
a <em>layout</em>.</li><li>An abstraction layer to associate SSA values with layouts and manipulate and
analyze them before a program is converted to concrete FHE operations.</li><li>A variety of layouts and kernels from the FHE literature.</li><li>A layout and kernel optimizer based on the
<a href=https://github.com/fhelipe-compiler/fhelipe>Fhelipe compiler</a>.</li><li>A layout conversion implementation of the
<a href=https://link.springer.com/chapter/10.1007/978-3-031-17140-6_20>Vos-Vos-Erkin graph coloring algorithm</a>.</li></ul><p>For background on what ciphertext packing is and its role in homomorphic
encryption, see
<a href=https://www.jeremykun.com/2024/09/06/packing-matrix-vector-multiplication-in-fhe/>this introductory blog post</a>.
The short version of that blog post is that the SIMD-style HE computational
model requires implementing linear-algebraic operations in terms of elementwise
additions, multiplications, and cyclic rotations of large-dimensional vectors
(with some exceptions like the
<a href=https://eprint.iacr.org/2025/448>Park-Gentry matrix-multiplication kernel</a>).</p><p>Practical programs require many such operations, and the task of the compiler is
to jointly choose ciphertext packings and operation kernels so as to minimize
overall program latency. In this document we will call the joint process of
optimizing layouts and kernels by the name &ldquo;layout optimization.&rdquo; In FHE
programs, runtime primarily comes from the quantity of rotation and bootstrap
operations, the latter of which is in turn approximated by multiplicative depth.
Metrics like memory requirements may also be constrained, but for most of this
document latency is the primary concern.</p><p>HEIR&rsquo;s design goal is to be an extensible HE compiler framework, we aim to
support a variety of layout optimizers and multiple layout representations. As
such, we separate the design of the layout representation from the details of
the layout optimizer, and implement lowerings for certain ops that can be reused
across optimizers.</p><p>This document will begin by describing the layout representation, move on to the
common, reusable components for working with that representation, and then
finally describe one layout optimizer implemented in HEIR based on Fhelipe.</p><h2 id=layout-representation>Layout representation</h2><p>A <em>layout</em> is a description of how cleartext data is organized within a list of
ciphertexts. In general, a layout is a partial function mapping from the index
set of a list of ciphertext <em>slots</em> to the index set of a cleartext tensor. The
function describes which cleartext data value is stored at which ciphertext
slot.</p><p>A layout is <em>partial</em> because not all ciphertext slots need to be used, and the
function uses ciphertext slots as the domain and cleartext indices as the
codomain because cleartext values may be replicated among multiple slots, but a
slot can store at most one cleartext value.</p><p>HEIR restricts the above definition of a layout as follows:</p><ul><li>The partial function must be expressible as a <em>Presburger relation</em>, which
will be defined in detail below.</li><li>Unmapped ciphertext slots always contain zero.[^zero]</li></ul><p>We claim that this subset of possible layouts is a superset of all layouts that
have been used in the FHE literature to date. For example, both the layout
notation of Fhelipe and the TileTensors of HeLayers are defined in terms of
specific parameterized quasi-affine formulas.</p><p>Next we define a Presburger relation, then move on to examples.</p><h3 id=quasi-affine-formulas-and-presburger-relations>Quasi-affine formulas and Presburger relations</h3><p><strong>Definition:</strong> A <em>quasi-affine</em> formula is a multivariate formula built from
the following operations:</p><ul><li>Integer literals</li><li>Integer-valued variables</li><li>addition and subtraction</li><li>multiplication by an integer constant</li><li>floor- and ceiling-rounded division by a nonzero integer constant</li><li>modulus by a nonzero integer constant</li></ul><p>Using the BNF grammar from the
<a href=https://mlir.llvm.org/docs/Dialects/Affine/#affine-expressions>MLIR website</a>,
we can also define it as</p><pre tabindex=0><code>affine-expr ::= `(` affine-expr `)`
              | affine-expr `+` affine-expr
              | affine-expr `-` affine-expr
              | `-`? integer-literal `*` affine-expr
              | affine-expr `ceildiv` integer-literal
              | affine-expr `floordiv` integer-literal
              | affine-expr `mod` integer-literal
              | `-`affine-expr
              | bare-id
              | `-`? integer-literal
</code></pre><p><strong>Definition:</strong> Let $d, r \in \mathbb{Z}_{\geq 0}$ represent a number of
domain and range dimensions, respectively. A <em>Presburger relation</em> is a binary
relation over $\mathbb{Z}^{d} \times \mathbb{Z}^{r}$ that can be expressed as
the solution to a set of equality and inequality constraints defined using
quasi-affine formulas.</p><p>We will use the Integer Set Library (ISL) notation to describe Presburger
relations. For an introduction to the ISL notation and library, see
<a href=https://jeremykun.com/2025/10/07/isl-a-primer/>this article</a>. For a
comprehensive reference, see
<a href=https://libisl.sourceforge.io/manual.pdf>the ISL manual</a>.</p><p><strong>Example 1:</strong> Given a data vector of type <code>tensor&lt;8xi32></code> and a ciphertext with
32 slots, a layout that repeats the tensor cyclically is given as:</p><pre tabindex=0><code>{
    [d] -&gt; [ct, slot] :
    0 &lt;= d &lt; 8
    and ct = 0
    and 0 &lt;= slot &lt; 32
    and (d - slot) mod 8 = 0
}
</code></pre><p>From Example 1, we note that in HEIR the domain of a layout always aligns with
the shape of the domain tensor, and the range of a layout is always a 2D tensor
whose first dimension denotes the ciphertext index and whose second index is the
slot within that ciphertext.</p><p><strong>Example 2:</strong> Given a data matrix of type <code>tensor&lt;8x8xi32></code> and 8 ciphertexts
with 32 slots each, the following layout implements the standard Halevi-Shoup
diagonal layout.</p><pre tabindex=0><code>{
    [row, col] -&gt; [ct, slot] :
    0 &lt;= row &lt; 8
    and 0 &lt;= col &lt; 8
    and 0 &lt;= ct &lt; 8
    and 0 &lt;= slot &lt; 32
    and (row - col + ct) mod 8 = 0
    and (row - slot) mod 32 = 0
}
</code></pre><p>Note, this layout implements a diagonal packing, and further replicates each
diagonal cyclically within a ciphertext.</p><h3 id=layout-attributes>Layout attributes</h3><p>Layouts are represented in HEIR via the <code>tensor_ext.layout</code> attribute. Its
argument includes a string using the ISL notation above. For example</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>#tensor_layout</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>#tensor_ext.layout</span><span style=color:#000;font-weight:700>&lt;</span>
</span></span><span style=display:flex><span>    <span style=color:#4e9a06>&#34;{ [i0] -&gt; [ct, slot] : (slot - i0) mod 8 = 0 and ct = 0 and 1023 &gt;= slot &gt;= 0 and 7 &gt;= i0 &gt;= 0 }&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><p>Generally, layout attributes are associated with an SSA value by being attached
to the op that owns the SSA value. In MLIR, which op owns the value has two
cases:</p><ul><li>For an op result, the layout attribute is stored on the op.</li><li>For a block argument, the layout attribute is stored on the op owning the
block, using the <code>OperandAndResultAttrInterface</code> to give a consistent API for
accessing the attribute.</li></ul><p>These two differences are handled properly by a helper library,
<code>lib/Utils/AttributeUtils.h</code>, which exposes setters and getters for layout
attributes. As of 2025-10-01, the system does not provide a way to handle ops
with multiple regions or multi-block regions.</p><p>For example, <code>#layout_attr</code> is associated with the SSA value <code>%1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mlir data-lang=mlir><span style=display:flex><span><span style=color:#000>%1</span> <span style=color:#000;font-weight:700>=</span> arith<span style=color:#000;font-weight:700>.</span>addi <span style=color:#000>%0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>%1</span> <span style=color:#000;font-weight:700>{</span><span style=color:#f57900>tensor_ext.layout =</span> <span style=color:#000>#layout_attr</span><span style=color:#000;font-weight:700>}</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>tensor</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#0000cf;font-weight:700>512x</span><span style=color:#204a87;font-weight:700>f32</span><span style=color:#000;font-weight:700>&gt;</span>
</span></span></code></pre></div><h2 id=data-semantic-and-ciphertext-semantic-tensors>Data-semantic and ciphertext-semantic tensors</h2><p>In HEIR, before lowering to scheme ops, we distinguish between types in two
regimes:</p><ul><li><em>Data-semantic tensors</em>, which are scalars and tensors that represent
cleartext data values, largely unchanged from the original input program.</li><li><em>Ciphertext-semantic tensors</em>, which are rank-2 tensors that represent packed
cleartext values in ciphertexts.</li></ul><p>The task of analyzing an IR to determine which layouts and kernels to use
happens in the data-semantic regime. In these passes, chosen layouts are
persisted between passes as attributes on ops (see
<a href=#layout-attributes>Layout attributes</a> above), and data types are unchanged.</p><p>In this regime, there are three special <code>tensor_ext</code> ops that are no-ops on
data-semantic type, but are designed to manipulate the layout attributes. These
ops are:</p><ul><li><code>tensor_ext.assign_layout</code>, which takes a data-semantic value and a layout
attribute, and produces the same data-semantic type. This is an &ldquo;entry point&rdquo;
into the layout system and lowers to a loop that packs the data according to
the layout.</li><li><code>tensor_ext.convert_layout</code>, which makes an explicit conversion between a
data-semantic value&rsquo;s current layout and a new layout. Typically this lowers
to a shift network.</li><li><code>tensor_ext.unpack</code>, which clears the layout attribute on a data-semantic
value, and serves as an exit point from the layout system. This lowers to a
loop which extracts the packed cleartext data back into user data.</li></ul><p>A layout optimizer is expected to insert <code>assign_layout</code> ops for any server-side
cleartexts that need to be packed at runtime.</p><p>In the ciphertext-semantic regime, all secret values are rank-2 tensors whose
first axis indexes ciphertexts and whose second axis indexes slots within
ciphertexts. These tensors are subject to the constraints of the SIMD FHE
computational model (elementwise adds, muls, and structured rotations), though
the type system does not enforce this until <code>secret-to-&lt;scheme></code> lowerings,
which would fail if encountering an op that cannot be implemented in FHE.</p><p>We preserve the use of the <code>tensor</code> type here, rather than create new types, so
that we can reuse MLIR infrastructure. For example, if we were to use a new
tensor-like type for ciphertext-semantic tensors, we would not be able to use
<code>arith.addi</code> anymore, and would have to reimplement folding and canonicalization
patterns from MLIR in HEIR. In the future we hope MLIR will relax these
constraints via interfaces and traits, and at that point we could consider a
specialized type.</p><p>Before going on, we note that the layout specification language is agnostic to
how the &ldquo;slots&rdquo; are encoded in the underlying FHE scheme. In particular, slots
could correspond to evaluation points of an RNS polynomial, i.e., to &ldquo;NTT form&rdquo;
slots. But they could also correspond to the coefficients of an RNS polynomial
in coefficient form. As of 2025-10-01, HEIR&rsquo;s Fhelipe-inspired pipeline
materializes slots as NTT-form slots in all cases, but is not required by the
layout system. The only part of the layout system that depends on NTT-form is
the implementation of operation kernels in terms of rotation operations, as
coefficient-form ciphertexts do not have a rotation operation available. Future
layout optimizers may take into account conversions between NTT and coefficient
form as part of a layout conversion step.</p><h2 id=heirs-fhelipe-inspired-layout-optimizer>HEIR&rsquo;s Fhelipe-inspired layout optimizer</h2><h3 id=pipeline-overview>Pipeline overview</h3><p>The <code>mlir-to-&lt;scheme></code> pipeline involves the following passes that manipulate
layouts:</p><ul><li><code>layout-propagation</code></li><li><code>layout-optimization</code></li><li><code>convert-to-ciphertext-semantics</code></li><li><code>implement-rotate-and-reduce</code></li><li><code>add-client-interface</code></li></ul><p>The two passes that are closest to Fhelipe&rsquo;s design are <code>layout-propagation</code> and
<code>layout-optimization</code>. The former sets up initial default layouts for all values
and default kernels for all ops that need them, and propagates them forward,
inserting layout conversion ops as needed to resolve layout mismatches. The
latter does a backwards pass, jointly choosing more optimal kernels and
attempting to hoist layout conversions earlier in the IR. If layout conversions
are hoisted all the way to function arguments then they are &ldquo;free&rdquo; because they
can be merged into client preprocessing.</p><p>Next we will outline the responsibility of each pass in detail. The
documentation page for each of these passes is linked in each section, and
contains doctests as examples that are kept in sync with the implementation of
the pass.</p><h3 id=layout-propagation><code>layout-propagation</code></h3><p>The <a href=/docs/passes/#-layout-propagation><code>layout-propagation</code></a> pass runs a
forward pass through the IR to assign default layouts to each SSA value that
needs one, and a default kernel to each operation that needs one.</p><p>For each secret-typed function argument, no layout can be inferred, so a default
layout is assigned. The default layout for scalars is to repeat the scalar in
every slot of a single ciphertext. The default layout for tensors is a row-major
layout into as many ciphertexts as are needed to fit the tensor.</p><p>Then layouts are propagated forward through the IR. For each op, a default
kernel is chosen, and if the layouts of the operands are already set and agree,
the result layout is inferred according to the kernel.</p><p>If the layouts are not compatible with the default kernel, a <code>convert_layout</code> op
is inserted to force compatibility. If one or more operands has a layout that is
not set (which can happen if the operand is a cleartext value known to the
server), then a compatible layout is chosen and an <code>assign_layout</code> op is
inserted to persist this information for later passes.</p><p>Because <code>layout-propagation</code> may have inserted some redundant conversions,
sequences of <code>assign_layout</code> followed by <code>convert_layout</code> are folded together
into combined <code>assign_layout</code> ops.</p><h3 id=layout-optimization><code>layout-optimization</code></h3><p>The <a href=/docs/passes/#-layout-optimization><code>layout-optimization</code></a> pass has two
main goals: to choose better kernels for ops, and to try to eliminate
<code>convert_layout</code> ops. It does this by running a backward pass through the IR. If
it encounters an op that is followed by a <code>convert_layout</code> op, it attempts to
hoist the <code>convert_layout</code> through the op to its arguments.</p><p>In doing this, it must consider:</p><ul><li>Changing the kernel of the op, and the cost of implementing the kernel. E.g.,
a new kernel may be better for the new layout of the operands.</li><li>Whether the new layout of op results still need to be converted, and the new
cost of these conversions. E.g., if the op result has multiple uses, or the op
result had multiple layout conversions, only one of which is hoisted.</li><li>The new cost of operand layout conversions. E.g., if a layout conversion is
hoisted to one operand, it may require other operands to be converted to
remain compatible.</li></ul><p>In all of the above, the &ldquo;cost&rdquo; includes an estimate of the latency of a kernel,
an estimate of the latency of a layout conversion, as well as the knowledge that
some layout conversions may be free or cheaper because of their context in the
IR.</p><blockquote><p><strong>NOTE:</strong> The cost of a kernel is currently considered free. This is mainly
because we don&rsquo;t have many different kernels for each op right now, so the
choice of kernel is not very interesting.</p><p>TODO(#2316): implement a cost model for kernels</p></blockquote><p>The cost of a layout conversion is estimated by simulating what the
<code>implement-shift-network</code> would do if it ran on a layout conversion. And
<code>layout-optimization</code> includes analyses that allow it to determine a folded cost
for layout conversions that occur after other layout conversions, as well as the
free cost of layout conversions that occur at function arguments, after
<code>assign_layout</code> ops, or separated from these by ops that do not modify a layout.</p><p>After the backward pass, any remaining <code>convert_layout</code> ops at the top of a
function are hoisted into function arguments and folded into existing layout
attributes.</p><h3 id=convert-to-ciphertext-semantics><code>convert-to-ciphertext-semantics</code></h3><p>The
<a href=/docs/passes/#-convert-to-ciphertext-semantics><code>convert-to-ciphertext-semantics</code></a>
pass has two responsibilities that must happen at the same time:</p><ul><li>Converting all data-semantic values to ciphertext-semantic values with
corresponding types.</li><li>Implementing FHE kernels for all ops as chosen by earlier passes.</li></ul><p>After this pass is complete, the IR must be in the ciphertext-semantic regime
and all operations on secret-typed values must be constrained by the SIMD FHE
computational model.</p><p>In particular, this pass implements <code>assign_layout</code> as an explicit loop that
packs cleartext data into ciphertext slots according to the layout attribute. It
also implements <code>convert_layout</code> as a shift network, which is a sequence of
plaintext masks and rotations that can arbitrarily (albeit expensively) shuffle
data in slots. This step can be isolated via the
<a href=/docs/passes/#-implement-shift-network><code>implement-shift-network</code></a> pass, but
the functionality is inlined in this pass since it must happen at the same time
as type conversion.</p><p>When converting function arguments, any secret-typed argument is assigned a new
attribute called <code>tensor_ext.original_type</code>, which records the original
data-semantic type of the argument as well as the layout used for its packing.
This is used later by the <code>add-client-interface</code> pass to generate client-side
encryption and decryption helper functions.</p><h3 id=implement-rotate-and-reduce><code>implement-rotate-and-reduce</code></h3><p>Some kernels rely on a baby-step giant-step optimization, and defer the
implementation of that operation so that canonicalization patterns can optimize
them. Instead they emit a <code>tensor_ext.rotate_and_reduce</code> op. The
<a href=/docs/passes/#-implement-rotate-and-reduce><code>implement-rotate-and-reduce</code></a> pass
implements this op using baby-step giant-step, or other approaches that are
relevant to special cases.</p><h3 id=add-client-interface><code>add-client-interface</code></h3><p>The <a href=/docs/passes/#-add-client-interface><code>add-client-interface</code></a> pass inserts
additional functions that can be used by the client to encrypt and decrypt data
according to the layouts chosen by the layout optimizer.</p><p>It fetches the <code>original_type</code> attribute on function arguments, and generates an
encryption helper function for each secret argument, and a decryption helper
function for each secret return type.</p><p>These helper functions use <code>secret.conceal</code> and <code>secret.reveal</code> for
scheme-agnostic encryption and decryption, but eagerly implement the packing
logic as a loop, equivalently to how <code>assign_layout</code> is lowered in
<code>convert-to-ciphertext-semantics</code>, and adding an analogous lowering for
<code>tensor_ext.unpack</code>.</p><h2 id=reusable-components-for-working-with-layouts>Reusable components for working with layouts</h2><h3 id=lowering-data-semantic-ops-with-fhe-kernels>Lowering data-semantic ops with FHE kernels</h3><p>Any layout optimizer will eventually need to convert data-semantic values to
ciphertext-semantic tensors. In doing this, all kernels need to be implemented
in one pass at the same time that the types are converted.</p><p>The <code>convert-to-ciphertext-semantics</code> pass implements this conversion without
making any decisions about which layouts or kernels to use. In particular, for
ops that have multiple supported kernels, it picks the kernel to use based on
the <code>kernel</code> attribute on the op (cf. <code>secret::SecretDialect::kKernelAttrName</code>).</p><p>In this way, we decouple the decision of which layout and kernel to use (the
optimizer&rsquo;s job) from the implementation of that kernel (the lowering&rsquo;s job).
Ideally all layout optimizer pipelines can reuse this pass, which avoids the
common pitfalls associated with writing dialect conversion passes. New kernels,
similarly, can be primarily implemented as described in the next section.</p><p>Finally, if a new optimizer or layout notation is introduced into HEIR, it
should ultimately be converted to use the same <code>tensor_ext.layout</code> attribute so
that it can reuse the lowerings of ops like <code>tensor_ext.assign_layout</code> and
<code>tensor_ext.unpack</code>.</p><h3 id=testing-kernels-and-layouts>Testing kernels and layouts</h3><p>Writing kernels can be tricky, so HEIR provides a simplified framework for
implementing kernels which allows them to be unit-tested in isolation, while the
lowering to MLIR is handled automatically by a common library.</p><p>The implementation library is called <code>ArithmeticDag</code>. Some initial
implementations are in <code>lib/Kernel/KernelImplementation.h</code>, and example unit
tests are in <code>lib/Kernel/*Test.cpp</code>. Then a class called
<code>IRMaterializingVisitor</code> walks the DAG and generates MLIR code.</p><p>Similarly, <code>lib/Utils/Layout/Evaluate.h</code> provides helper functions to
materialize layouts on test data-semantic tensors, which can be combined with
<code>ArithmeticDag</code> to unit-test a layout and kernel combination without ever
touching MLIR.</p><h3 id=manipulating-layouts>Manipulating layouts</h3><p>The directory <code>lib/Utils/Layout</code> contains a variety of helper code for
manipulating layout relations, including:</p><ul><li>Constructing or testing for common kinds of layouts, such as row-major,
diagonal, and layouts related to particular machine learning ops like
convolution.</li><li>Generating explicit loops that iterate over the space of points in a layout,
which is used to generate packing and unpacking code.</li><li>Helpers for hoisting layout conversions through ops.</li></ul><p>These are implemented using two APIs: one is the Fast Presburger Library (FPL),
which is part of MLIR and includes useful operations like composing relations
and projecting out dimensions. The other is the Integer Set Library (ISL), which
is a more fully-featured library that supports code generation and advanced
analyses and simplification routines. As we represent layouts as ISL strings, we
include a two-way interoperability layer that converts between ISL and FPL
representations of the same Presburger relation.</p><h2 id=a-case-study-the-orion-convolution-kernel>A case study: the Orion convolution kernel</h2><p>The <a href=https://arxiv.org/abs/2311.03470>Orion compiler</a> presents a kernel for 2D
convolution that first converts the filter input into a Toeplitz matrix $A$, and
then applies a Halevi-Shoup diagonal packing and kernel on $A$ using the
encrypted image vector $v$ packed row-major into a single ciphertext.</p><p>We describe how this layout is constructed and represented in HEIR.</p><p>The first, analytical step, is to describe a Presburger relation mapping a
cleartext filter matrix to the Toeplitz matrix form as described in the Orion
paper. Essentially, this involves writing down the loop nest that implements a
convolution and, for each visited index,</p><p>Let $P$ be an integer padding value, fix stride 1, and define $i_{dr}, i_{dc}$
to be indices over the &ldquo;data row&rdquo; and &ldquo;data column&rdquo;, respectively, i.e., these
variables track the top-left index of the filter as it slides over the convolved
image in the data-semantic domain. For an image of height $H_d$ and width $W_d$,
and a filter of height $H_f$ and width $W_f$, we have</p><p>$$ -P \leq i_{dr} \leq H_d + P - W_f $$</p><p>and similarly for $i_{dc}$.</p><p>Then we have bounds for the iteration of entries of the filter itself, for a
fixed position of the filter over the image. If we consider these local
variables $i_{fr}$ and $i_{fc}$ for &ldquo;filter row&rdquo; and &ldquo;filter column&rdquo;,
respectively, we have</p><p>$$ 0 \leq i_{fr} &lt; H_f $$</p><p>and similarly for $i_{fc}$.</p><p>From these two indices we can compute the corresponding entry of the data matrix
that is being operated on as $i_{dr} + i_{fr}$ and $i_{dc} + i_{fc}$. If
that index is within the bounds of the image, then the filter entry at that
position is included in the Toeplitz matrix.</p><p>Finally, we need to compute the row and column of the Toeplitz matrix that each
filter entry maps to. This is the novel part of the Orion construction. Each row
of the Toeplitz matrix corresponds to one iteration over the filter (the filter
is fixed at some position of the filter over the image). And the column value is
a flattened index of the filter entry, plus offsets from both the padding and
the iteration of the filter over the image (each step the filter moves adds one
more to the offset).</p><p>The formula for the target row is</p><p>$$ m_{r} = (i_{dr} + P) F + i_{dc} + P $$</p><p>where $F$ is the total number of positions the filter assumes within each row,
i.e., $F = H_d + 2P - H_f + 1$.</p><p>And the target column is</p><p>$$ m_{c} = W_d i_{dr} + i_{dc} + W_d i_{fr} + i_{fc} $$</p><p>Note the use of <code>W_d</code> for both the offset from the filter&rsquo;s position over the
image, and the offset from the filter&rsquo;s own row.</p><p>Together this produces the following almost-Presburger relation:</p><pre tabindex=0><code>[Hd, Wd, Hf, Wf, P] -&gt; {
    [ifr, ifc] -&gt; [mr, mc] : exists idr, idc :

    // Bound the top-left index of the filter as it slides over the image
    -P &lt;= idr &lt;= Hd + P - Hf
    and -P &lt;= idc &lt;= Wd + P - Wf

    // Bound the index within the filter
    and 0 &lt;= ifr &lt; Hf
    and 0 &lt;= ifc &lt; Wf

    // Only map values when the filter index is in bounds
    and 0 &lt;= ifr + idr &lt; Hd
    and 0 &lt;= ifc + idc &lt; Wd

    // Map the materialized filter index to its position in the Toeplitz matrix
    and mr = (idr + P) * (Wd + 2P - Wf + 1) + idc + P
    and mc = (idr * Wd + idc) + Wd * ifr + ifc
}
</code></pre><p>This is &ldquo;almost&rdquo; a Presburger relation because, even though the symbol variables
<code>Hd</code>, <code>Wd</code>, <code>Hf</code>, <code>Wf</code>, and <code>P</code> are all integer constants, they cannot be
multiplied together in a Presburger formula. But if we replace them with
specific constants, such as</p><pre tabindex=0><code>Hd = 8
Wd = 8
Hf = 3
Wf = 3
P = 1
</code></pre><p>We get</p><pre tabindex=0><code>{
    [ifr, ifc] -&gt; [mr, mc] : exists idr, idc :
    -1 &lt;= idr &lt;= 6
    and -1 &lt;= idc &lt;= 6
    and 0 &lt;= ifr &lt; 3
    and 0 &lt;= ifc &lt; 3
    and 0 &lt;= ifr + idr &lt; 8
    and 0 &lt;= ifc + idc &lt; 8
    and mr = (idr + 1) * 8 + idc + 1
    and mc = idr * 8 + idc + ifc + ifr * 8
}
</code></pre><p>Which ISL simplifies to</p><pre tabindex=0><code>{
    [ifr, ifc] -&gt; [mr, mc = -9 + 8ifr + ifc + mr] :
    0 &lt;= ifr &lt;= 2
    and 0 &lt;= ifc &lt;= 2
    and mr &gt;= 0
    and 8 - 8ifr &lt;= mr &lt;= 71 - 8ifr
    and mr &lt;= 63
    and 8*floor((mr)/8) &gt;= -8 + ifc + mr
    and 8*floor((mr)/8) &lt; ifc + mr
}
</code></pre><p>Next, we can compose the above relation with the Halevi-Shoup diagonal layout
(using FPL&rsquo;s <code>IntegerRelation::compose</code>), to get a complete layout from filter
entries to ciphertext slots. Using ciphertexts with 1024 slots, we get:</p><pre tabindex=0><code>{
    [ifr, ifc] -&gt; [ct, slot] :
    (9 - 8ifr - ifc + ct) mod 64 = 0
    and 0 &lt;= ifr &lt;= 2
    and 0 &lt;= ifc &lt;= 2
    and 0 &lt;= ct &lt;= 63
    and 0 &lt;= slot &lt;= 1023
    and 8*floor((slot)/8) &gt;= -8 + ifc + slot
    and 8*floor((slot)/8) &lt; ifc + slot
    and 64*floor((slot)/64) &gt;= -72 + 8ifr + ifc + slot
    and 64*floor((slot)/64) &gt;= -71 + 8ifr + slot
    and 64*floor((slot)/64) &lt;= -8 + 8ifr + slot
    and 64*floor((slot)/64) &lt;= -9 + 8ifr + ifc + slot
}
</code></pre><h2 id=faq>FAQ</h2><h3 id=can-users-define-kernels-without-modifying-the-compiler>Can users define kernels without modifying the compiler?</h3><p><strong>No</strong> (as of 2025-10-01). However, a kernel DSL is <strong>in scope</strong> for HEIR. Reach
out if you&rsquo;d like to be involved in the design.</p><p>[^zero]: This may be relaxed in the future with additional static analyses
that can determine that some slots are never read.</p></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/google/heir aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2025 The HEIR Authors All Rights Reserved</span>
<span class=ms-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.027d75d71824837bee74c12a7806c5fe51249c1ca7accc27553a251a75cdb3a4.js integrity="sha256-An111xgkg3vudMEqeAbF/lEknBynrMwnVTolGnXNs6Q=" crossorigin=anonymous></script>
<script defer src=/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>