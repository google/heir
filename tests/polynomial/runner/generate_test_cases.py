"""Generate mlir-cpu-runner tests for lowering polynomial.mul ops from a config."""

import argparse
import sys

import math
import sympy
import tomli

HEADER = """// WARNING: this file is autogenerated. Do not edit manually, instead see
// tests/polynomial/runner/generate_test_cases.py

//-------------------------------------------------------
// entry and check_prefix are re-set per test execution
// DEFINE: %{entry} =
// DEFINE: %{check_prefix} =

// DEFINE: %{compile} = heir-opt %s --heir-polynomial-to-llvm
// DEFINE: %{run} = mlir-cpu-runner -e %{entry} -entry-point-result=void --shared-libs="%mlir_lib_dir/libmlir_c_runner_utils%shlibext,%mlir_runner_utils"
// DEFINE: %{check} = FileCheck %s --check-prefix=%{check_prefix}
//-------------------------------------------------------

func.func private @printMemrefI32(memref<*xi32>) attributes { llvm.emit_c_interface }

"""


def test_setup(i: int):
  entry_def = '// REDEFINE: %{entry} = test_' + str(i)
  check_def = '// REDEFINE: %{check_prefix} = CHECK_TEST_' + str(i)
  run = '// RUN: %{compile} | %{run} | %{check}'
  return '\n'.join([entry_def, check_def, run])


# Params:
#  - ideal
#  - cmod
#  - p0
#  - p1
#  - test_number
#  - gen_tensor_op
#  - degree
#  - expected
#  - coefficient_list
TEST_TEMPLATE = """
#ideal_{{test_number}} = #polynomial.int_polynomial<{{ideal}}>
#ring_{{test_number}} = #polynomial.ring<coefficientType = i32, coefficientModulus={{cmod}} : {{cmod_type}}, polynomialModulus=#ideal_{{test_number}}>
!poly_ty_{{test_number}} = !polynomial.polynomial<ring=#ring_{{test_number}}>

func.func @test_{{test_number}}() {{{{
  %const0 = arith.constant 0 : index
  %0 = polynomial.constant int<{{p0}}> : !poly_ty_{{test_number}}
  %1 = polynomial.constant int<{{p1}}> : !poly_ty_{{test_number}}
  %2 = polynomial.mul %0, %1 : !poly_ty_{{test_number}}

{gen_tensor_op}
  %ref = bufferization.to_memref %tensor : memref<{{degree}}xi32>
  %U = memref.cast %ref : memref<{{degree}}xi32> to memref<*xi32>
  func.call @printMemrefI32(%U) : (memref<*xi32>) -> ()
  return
}}}}
// expected_result: {{expected}}
// CHECK_TEST_{{test_number}}: {{coefficient_list}}
"""

# We need to compare the final output in i32s because that's the only type
# supported by the mlir-cpu-runner. So we need to truncate or extend the bits.
# I have not looked into the possibility of adding more functions to the
# upstream mlir-cpu-runner.
GEN_TENSOR_OP_TEMPLATE_WITH_TRUNC = """
  %3 = polynomial.to_tensor %2 : !poly_ty_{{test_number}} -> tensor<{{degree}}x{{container_type}}>
  %tensor = arith.{trunc_ext_op} %3 : tensor<{{degree}}x{{container_type}}> to tensor<{{degree}}xi32>
"""
GEN_TENSOR_OP_TEMPLATE = """
  %tensor = polynomial.to_tensor %2 : !poly_ty_{test_number} -> tensor<{degree}x{container_type}>
"""


def make_test_template(container_bit_width: int):
  if container_bit_width != 32:
    trunc_ext_op = 'trunci' if container_bit_width > 32 else 'extsi'
    return TEST_TEMPLATE.format(
        gen_tensor_op=GEN_TENSOR_OP_TEMPLATE_WITH_TRUNC.format(
            trunc_ext_op=trunc_ext_op
        )
    )
  else:
    return TEST_TEMPLATE.format(gen_tensor_op=GEN_TENSOR_OP_TEMPLATE)


parser = argparse.ArgumentParser(
    description=(
        'Generate a list of mlir-cpu-runner integration tests for lowering'
        ' polynomial.mul ops'
    )
)
parser.add_argument(
    '--tests_toml_path',
    type=str,
    help='A filepath to a toml file containing a list of tests to generate.',
)
parser.add_argument(
    '--output_test_file',
    type=str,
    help='A filepath to the output file containing all the tests.',
)
parser.add_argument(
    '--output_test_stem',
    type=str,
    help=(
        'If specified, generate each test as its own file with this argument'
        ' as the path stem.'
    ),
)


def get_key_or_err(the_dict, key: str, error: str = None):
  error = error or f'[[test]] Missing key {key}, parsed dict={the_dict}'
  try:
    return the_dict[key]
  except KeyError:
    print(error)
    sys.exit(1)


def parse_polynomial(poly_str: str) -> list[tuple[int, int]]:
  """Parse a polynomial string into a list of coeff-degree pairs."""
  terms = [x.strip().split('x**') for x in poly_str.split('+')]
  term_dict = dict()
  for term in terms:
    term = [x.strip() for x in term]
    if term[0]:
      term_coeff = int(term[0])
    else:
      term_coeff = 1
    if len(term) == 1:
      term_dict[0] = term_coeff
    else:
      degree = int(term[1])
      term_dict[degree] = term_coeff

  return list((coeff, degree) for (degree, coeff) in term_dict.items())


def parse_to_sympy(poly_str: str, var: sympy.Symbol, cmod: int):
  terms = parse_polynomial(poly_str)
  poly = 0
  for coeff, degree in terms:
    poly += coeff * var**degree
  return poly.as_poly(domain=f'ZZ[{cmod}]')


def make_coset_regex(x, cmod):
  """Return a regex that matches x or x +/- cmod."""
  if x == 0:
      return '0'
  if x < 0:
    return '{{' + f'({x}|{cmod + x})' + '}}'
  return '{{' + f'({x}|{x - cmod})' + '}}'


def main(args: argparse.Namespace) -> None:
  if not args.tests_toml_path:
    print('No test config was passed via --tests_toml_path')
    sys.exit(1)

  if not args.output_test_file and not args.output_test_stem:
    print('Must pass one of --output_test_file or --output_test_stem')
    sys.exit(1)

  with open(args.tests_toml_path, 'rb') as infile:
    config = tomli.load(infile)

  tests = []
  try:
    tests = config['test']
  except KeyError:
    print('TOML file must contain one or more sections like [[test]]')
    sys.exit(1)
  test_count = len(tests)

  print(f'Generating {test_count} tests...')
  output_tests = []
  for i, test in enumerate(tests):
    (ideal, cmod, p0, p1, cmod_type, coefficient_type) = (
        get_key_or_err(test, s)
        for s in ['ideal', 'cmod', 'p0', 'p1', 'cmod_type', 'coefficient_type']
    )

    x = sympy.Symbol('x')
    parsed_ideal = parse_to_sympy(ideal, x, cmod)
    parsed_p0 = parse_to_sympy(p0, x, cmod)
    parsed_p1 = parse_to_sympy(p1, x, cmod)
    domain = parsed_p0.domain

    expected_remainder = sympy.rem(parsed_p0 * parsed_p1, parsed_ideal, x)
    print(
        f'{expected_remainder.domain} : ({p0}) * ({p1}) ='
        f' {expected_remainder.as_expr()} mod ({ideal})'
    )
    coeff_list_len = parsed_ideal.degree()
    expected_coeffs = list(reversed(expected_remainder.all_coeffs()))
    container_width = int(coefficient_type[1:])

    # For whatever reason, sympy won't preserve the domain of the coefficients
    # after `rem`, so I have to manually convert any fractional coefficients to
    # their modular inverse equivalents.
    for j, exp_coeff in enumerate(expected_coeffs):
      if exp_coeff.is_rational and not exp_coeff.is_integer:
        domain_p = domain.convert(exp_coeff.p)
        domain_q = domain.convert(sympy.mod_inverse(exp_coeff.q, cmod))
        result = (domain_p * domain_q) % cmod
        result = int(str(result))
      elif exp_coeff.is_integer:
        result = exp_coeff % cmod
      expected_coeffs[j] = result

    # Allow tests to produce either of two valid coset representatives: the
    # positive or negative one.
    # This is because I can't seem to nail down how remsi instructions produce
    # an output.
    expected_coeffs = [make_coset_regex(coeff, cmod) for coeff in expected_coeffs]
    coefficient_list_regex = ', '.join(expected_coeffs)

    if len(expected_coeffs) < coeff_list_len:
      expected_coeffs = expected_coeffs + [0] * (
          coeff_list_len - len(expected_coeffs)
      )

    output_tests.append(
        '\n'.join([
            test_setup(i),
            make_test_template(container_width).format(
                ideal=ideal,
                cmod=cmod,
                cmod_type=cmod_type,
                p0=p0,
                p1=p1,
                test_number=i,
                container_type=coefficient_type,
                degree=parsed_ideal.degree(),
                expected=expected_remainder,
                coefficient_list=coefficient_list_regex,
            ),
        ])
    )

  if args.output_test_stem:
    for i, test in enumerate(output_tests):
      with open(f'{args.output_test_stem}{i}.mlir', 'w') as outfile:
        outfile.write(HEADER)
        outfile.write(test)
  else:
    with open(args.output_test_file, 'w') as outfile:
      outfile.write(HEADER)
      outfile.write('\n'.join(output_tests))

  print('Done')


if __name__ == '__main__':
  main(parser.parse_args())
