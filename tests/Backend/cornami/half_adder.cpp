/*=================================================================
//
//  This file has been Automatically generated by SCIFRBool C++ Emitter
//
=================================================================*/

#include <concrete_engine.hpp>
#include <concrete_engine_boolean.hpp>

using cornami::fhe::ServerParameters;
using cornami::fhe::concrete::BootstrapKeyStandard;
using cornami::fhe::concrete::ConcreteEngine;
using cornami::fhe::concrete::KeySwitchKey;
using cornami::fhe::concrete::StreamLwe;

using cornami::fhe::concrete::BinaryBooleanOp;
using cornami::fhe::concrete::BooleanEncodingType;
using cornami::fhe::concrete::ConcreteEngineBoolean;

using SCIFRBoolCiphertext = std::vector<uint64_t>;
std::vector<SCIFRBoolCiphertext> half_adder(BootstrapKeyStandard<uint64_t> v0,
                                            KeySwitchKey<uint64_t> v1,
                                            ServerParameters v2,
                                            SCIFRBoolCiphertext v3,
                                            SCIFRBoolCiphertext v4) {
  BootstrapKeyStandard<uint64_t> bsk = v0;
  KeySwitchKey<uint64_t> ksk = v1;
  ServerParameters serverSetup = v2;
  ConcreteEngine<uint64_t>* pEngine =
      new ConcreteEngine<uint64_t>(bsk, ksk, serverSetup);
  ConcreteEngineBoolean<uint64_t> engineBoolean(
      pEngine, BooleanEncodingType::NegativeOneOne);
  pEngine = NULL;

  StreamLwe<uint64_t> strm0 = engineBoolean.newHostToFabricLweStream();
  StreamLwe<uint64_t> strm1 = engineBoolean.newHostToFabricLweStream();
  uint nLweSize = bsk.m_bskInfo.lweInfo.nLWESize;
  // =================== start of section 1 ===================

  engineBoolean.SetDefaultDirTopology("/tmp/viz/0");
  StreamLwe<uint64_t> strm2 = engineBoolean.newLweStream();
  engineBoolean.binaryBooleanConsumeAll(strm0, strm1, strm2,
                                        BinaryBooleanOp::Xor, 1);
  engineBoolean.m_engine->routeToHost(strm2);
  engineBoolean.m_engine->finalizeAndRun();
  engineBoolean.m_engine->put(strm0, &v3[0], nLweSize);
  engineBoolean.m_engine->put(strm1, &v4[0], nLweSize);
  SCIFRBoolCiphertext v7 = std::vector<uint64_t>(nLweSize, 0);
  engineBoolean.m_engine->get(strm2, &v7[0], nLweSize);
  engineBoolean.m_engine->EndRun();
  // =================== end of section 1 ===================

  // =================== start of section 2 ===================

  engineBoolean.resetTopology(true);
  engineBoolean.SetDefaultDirTopology("/tmp/viz/1");
  StreamLwe<uint64_t> strm3 = engineBoolean.newLweStream();
  StreamLwe<uint64_t> strm4 = engineBoolean.newLweStream();
  StreamLwe<uint64_t> strm5 = engineBoolean.newLweStream();
  engineBoolean.binaryBooleanConsumeAll(strm3, strm4, strm5,
                                        BinaryBooleanOp::And, 1);
  engineBoolean.m_engine->routeToHost(strm5);
  engineBoolean.m_engine->finalizeAndRun();
  engineBoolean.m_engine->put(strm0, &v3[0], nLweSize);
  engineBoolean.m_engine->put(strm1, &v4[0], nLweSize);
  SCIFRBoolCiphertext v13 = std::vector<uint64_t>(nLweSize, 0);
  engineBoolean.m_engine->get(strm5, &v13[0], nLweSize);
  engineBoolean.m_engine->EndRun();
  // =================== end of section 2 ===================

  std::vector<SCIFRBoolCiphertext> v19 = {v7, v13};
  return v19;
}
