#include <chrono>
#include <ctime>
#include <iostream>
#include <ostream>
#include <string>
#include <utility>
#include <vector>

#include "lib/Target/OpenFhePke/Interpreter.h"
#include "mlir/include/mlir/IR/BuiltinOps.h"           // from @llvm-project
#include "mlir/include/mlir/IR/MLIRContext.h"          // from @llvm-project
#include "mlir/include/mlir/IR/OwningOpRef.h"          // from @llvm-project
#include "mlir/include/mlir/Parser/Parser.h"           // from @llvm-project
#include "src/core/include/lattice/hal/lat-backend.h"  // from @openfhe
#include "src/pke/include/ciphertext-fwd.h"            // from @openfhe
#include "src/pke/include/constants-defs.h"            // from @openfhe
#include "src/pke/include/cryptocontext-fwd.h"         // from @openfhe
#include "src/pke/include/encoding/plaintext-fwd.h"    // from @openfhe
#include "src/pke/include/gen-cryptocontext.h"         // from @openfhe
#include "src/pke/include/key/evalkey-fwd.h"           // from @openfhe
#include "src/pke/include/key/privatekey-fwd.h"        // from @openfhe
#include "src/pke/include/key/publickey-fwd.h"         // from @openfhe
#include "src/pke/include/openfhe.h"                   // from @openfhe

namespace mlir {
namespace heir {
namespace openfhe {}  // namespace openfhe
}  // namespace heir
}  // namespace mlir

using namespace lbcrypto;
using CiphertextT = Ciphertext<DCRTPoly>;
using CCParamsT = CCParams<CryptoContextCKKSRNS>;
using CryptoContextT = CryptoContext<DCRTPoly>;
using EvalKeyT = EvalKey<DCRTPoly>;
using PlaintextT = Plaintext;
using PrivateKeyT = PrivateKey<DCRTPoly>;
using PublicKeyT = PublicKey<DCRTPoly>;
using FastRotPrecompT = std::shared_ptr<std::vector<DCRTPoly>>;

void reportTime(const std::string& operation,
                const std::chrono::high_resolution_clock::time_point& start,
                const std::chrono::high_resolution_clock::time_point& end) {
  auto duration = std::chrono::duration_cast<std::chrono::seconds>(end - start);
  std::cout << operation << " time: " << duration.count() << " seconds\n";
}

int main(int argc, char* argv[]) {
  // Generated by the bazel rule
  std::string generatedModuleFile = argv[1];

  // Manually generate and configure crypto context
  CCParams<CryptoContextCKKSRNS> parameters;
  SecretKeyDist secretKeyDist = SPARSE_TERNARY;
  parameters.SetSecretKeyDist(secretKeyDist);
  parameters.SetSecurityLevel(HEStd_NotSet);
  parameters.SetRingDim(1 << 17);
  parameters.SetScalingModSize(51);
  parameters.SetFirstModSize(51);
  std::vector<uint32_t> levelBudget = {2, 2};
  uint32_t levelsAvailableAfterBootstrap = 16;
  auto numSlots = 1 << 10;
  usint depth = levelsAvailableAfterBootstrap +
                FHECKKSRNS::GetBootstrapDepth(levelBudget, secretKeyDist);
  parameters.SetMultiplicativeDepth(depth);
  CryptoContext<DCRTPoly> cryptoContext = GenCryptoContext(parameters);
  cryptoContext->Enable(PKE);
  cryptoContext->Enable(KEYSWITCH);
  cryptoContext->Enable(LEVELEDSHE);
  cryptoContext->Enable(FHE);
  usint ringDim = cryptoContext->GetRingDimension();
  std::cout << "CKKS scheme is using ring dimension " << ringDim << std::endl
            << std::endl;
  std::vector<uint32_t> bsgsDim = {0, 0};
  cryptoContext->EvalBootstrapSetup(levelBudget, bsgsDim, numSlots);
  auto keyPair = cryptoContext->KeyGen();
  cryptoContext->EvalMultKeyGen(keyPair.secretKey);
  cryptoContext->EvalBootstrapKeyGen(keyPair.secretKey, numSlots);

  // Construct list of 0 to 100, 200, 400
  std::vector<int> rots{200, 400};
  // Use a for loop to add numbers from 0 to 100
  for (int i = 0; i <= 100; ++i) {
    rots.push_back(i);
  }
  cryptoContext->EvalRotateKeyGen(keyPair.secretKey, rots);

  // Run one inference
  const std::vector<double> x(32 * 32, 0.0f);
  PlaintextT ptxt = cryptoContext->MakeCKKSPackedPlaintext(x);
  std::cout << "Input x: " << ptxt << std::endl;
  auto c = cryptoContext->Encrypt(keyPair.publicKey, ptxt);


    // Load the MLIR module from a file
  mlir::MLIRContext context;
  mlir::heir::openfhe::initContext(context);
  mlir::OwningOpRef<mlir::ModuleOp> module =
      parseSourceFile<mlir::ModuleOp>(generatedModuleFile, &context);
  mlir::heir::openfhe::Interpreter interpreter(module.get());

  auto start = std::chrono::high_resolution_clock::now();
  mlir::heir::openfhe::TypedCppValue outputEncrypted = interpreter.interpret(
      "_hecate_MLP", {cryptoContext, mlir::heir::openfhe::TypedCppValue(c)})[0];
  auto end = std::chrono::high_resolution_clock::now();
  reportTime("_hecate_MLP", start, end);

  return 0;
}
