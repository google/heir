package linear_transform

import (
	"fmt"
	"github.com/tuneinsight/lattigo/v6/circuits/ckks/lintrans"
	"github.com/tuneinsight/lattigo/v6/core/rlwe"
	"github.com/tuneinsight/lattigo/v6/ring"
	"github.com/tuneinsight/lattigo/v6/schemes/ckks"
	"math"
	"testing"
)

func TestLinearTransform(t *testing.T) {
	// This test is a bit weird because we're skipping most of the pipeline
	// to just test the emitter for linear_transform which is needed in the
	// context of comparisons with the orion compiler. This requires us to
	// manually set up the crypto parameters and encode/encrypt stuff.

	// Input vector of all 1s
	num_slots := 4096
	input_clear := make([]float64, num_slots)
	for i := range input_clear {
		input_clear[i] = 1.0
	}

	// Matrix of weights. This represents two nonzero diagonals on an
	// otherwise all-zero matrix:
	//
	// 0    4096
	//         1  4097
	//               2  4098
	//                     ...
	//                        4094  8190
	// 8191                         4095
	//
	// In this way, the nonzero diagonals become
	// diagonal 0: range(0, 4096)
	// digaonal 1: range(4096, 8192)
	//
	// and the expected values are (noting lattigo does
	// left-multiplication of the cleartext matrix and the vector is all
	// 1s):
	//
	// [4096 + 0, 4097 + 1, ..., 8191 + 4095]
	diagonals := 2
	cols := num_slots
	// Matrix is flattened 2 x num_slots
	matrix := make([]float64, diagonals*cols)
	value := 0.0
	for r := 0; r < diagonals; r++ {
		for c := 0; c < cols; c++ {
			matrix[r*cols+c] = value
			value += 1
		}
	}

	expected_clear := make([]float64, num_slots)
	for i := range expected_clear {
		expected_clear[i] = float64(4096 + 2*i)
	}

	// These parameters should match linear_transform.mlir, though due to
	// the weird nature of this test, this is the source of truth for what
	// is used, not the mlir file.
	param, err := ckks.NewParametersFromLiteral(ckks.ParametersLiteral{
		LogN:            13,
		Q:               []uint64{536903681, 67043329, 66994177, 67239937, 66961409, 66813953},
		P:               []uint64{536952833, 536690689},
		LogDefaultScale: 26,
	})
	if err != nil {
		panic(err)
	}

	encoder := ckks.NewEncoder(param)
	kgen := rlwe.NewKeyGenerator(param)
	sk, pk := kgen.GenKeyPairNew()
	encryptor := rlwe.NewEncryptor(param, pk)
	decryptor := rlwe.NewDecryptor(param, sk)

	// This is copied from the generated code so we can get access to the
	// Lattigo-produced Galois key set to generate... ideally this is moved
	// to a shared client helper generated by HEIR, but the client
	// interface generation is before lowering to scheme, and Orion enters
	// post-lowering-to-scheme. For this test it's OK and, if nothing else,
	// a good reference.
	ct1_diags := make(lintrans.Diagonals[float64])
	for i := 0; i < 2; i++ {
		ct1_diags[i] = matrix[i*num_slots : (i+1)*num_slots]
	}
	ct1_params := lintrans.Parameters{
		DiagonalsIndexList:        ct1_diags.DiagonalsIndexList(),
		LevelQ:                    5,
		LevelP:                    param.MaxLevelP(),
		Scale:                     rlwe.NewScale(param.Q()[5]),
		LogDimensions:             ring.Dimensions{Rows: 0, Cols: 12}, // 1x4096
		LogBabyStepGiantStepRatio: 2,
	}
	ct1_lt := lintrans.NewTransformation(param, ct1_params)
	galEls := ct1_lt.GaloisElements(param)

	// Manually add Galois key for rotation index 2048
	rotIndex := 2048
	logN := 13
	galoisElement := uint64(1)
	for i := 0; i < rotIndex; i++ {
		galoisElement = (galoisElement * 5) % (1 << (logN + 1))
	}
	galEls = append(galEls, galoisElement)
	fmt.Printf("Final galEls: %v\n", galEls)

	evk := rlwe.NewMemEvaluationKeySet(nil, kgen.GenGaloisKeysNew(galEls, sk)...)
	evaluator := ckks.NewEvaluator(param, evk)

	pt := ckks.NewPlaintext(param, param.MaxLevel())
	pt.LogDimensions = ring.Dimensions{Rows: 0, Cols: 12} // 2^(0+12) = 4096 slots
	encoder.Encode(input_clear, pt)
	ct_input, err25 := encryptor.EncryptNew(pt)
	if err25 != nil {
		panic(err25)
	}

	result_ct := linear_transform(evaluator, param, encoder, ct_input, matrix)
	result_pt := decryptor.DecryptNew(result_ct)
	result_float64 := make([]float64, 4096)
	encoder.Decode(result_pt, result_float64)

	// We need such a large epsilon because scale 26 is not very precise,
	// increasing scale to 40 produces errors of about 1e-04.
	epsilon := 1.2
	for i := 0; i < num_slots; i++ {
		diff := math.Abs(result_float64[i] - expected_clear[i])
		if diff > epsilon {
			t.Errorf("Mismatch at index %d: got %f, expected %f (diff: %e)",
				i, result_float64[i], expected_clear[i], diff)

			// Fail fast to avoid spamming 4096 errors
			if i > 10 {
				t.Fatal("Too many errors, stopping verification.")
			}
		}
	}
}
