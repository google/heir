#include <string>
#include <utility>
#include <vector>

#include "gtest/gtest.h"  // from @googletest
#include "lib/Target/OpenFhePke/Interpreter.h"
#include "mlir/include/mlir/IR/BuiltinOps.h"   // from @llvm-project
#include "mlir/include/mlir/IR/MLIRContext.h"  // from @llvm-project
#include "mlir/include/mlir/IR/OwningOpRef.h"  // from @llvm-project
#include "mlir/include/mlir/Parser/Parser.h"   // from @llvm-project
#include "mlir/include/mlir/Support/LLVM.h"    // from @llvm-project
#include "src/pke/include/openfhe.h"           // from @openfhe

namespace mlir {
namespace heir {
namespace openfhe {

using namespace lbcrypto;
using CryptoContextT = CryptoContext<DCRTPoly>;

// Copybara manages this declaration via regex
const std::string WORKSPACE_BASE = "";

TEST(MatmulInterpreterTest, RunTest) {
  // Generated by the bazel rule
  std::string generatedModuleFile =
      WORKSPACE_BASE +
      "tests/Examples/openfhe/ckks/halevi_shoup_matvec/module.openfhe.mlir";

  // Load the MLIR module from a file
  MLIRContext context;
  initContext(context);
  OwningOpRef<ModuleOp> module =
      parseSourceFile<ModuleOp>(generatedModuleFile, &context);
  Interpreter interpreter(module.get());

  TypedCppValue ccInitial =
      interpreter.interpret("matvec__generate_crypto_context", {})[0];

  auto keyPair = std::get<CryptoContextT>(ccInitial.value)->KeyGen();
  auto publicKey = keyPair.publicKey;
  auto secretKey = keyPair.secretKey;
  std::vector<TypedCppValue> args = {ccInitial, TypedCppValue(secretKey)};
  TypedCppValue cc = std::move(
      interpreter.interpret("matvec__configure_crypto_context", args)[0]);

  std::vector<float> arg0Vals = {1.0, 0, 0, 0, 0, 0, 0, 0,
                                 0,   0, 0, 0, 0, 0, 0, 0};

  // This selects the first element of the matrix (0x5036cb3d =
  // 0.099224686622619628) and adds -0.45141533017158508
  float expected = -0.35219;

  TypedCppValue arg0Enc = interpreter.interpret(
      "matvec__encrypt__arg0",
      {cc, TypedCppValue(arg0Vals), TypedCppValue(publicKey)})[0];

  TypedCppValue outputEncrypted =
      interpreter.interpret("matvec", {cc, arg0Enc})[0];

#ifdef OPENFHE_ENABLE_TIMING
  interpreter.printTimingResults();
#endif

  TypedCppValue actualVal =
      interpreter.interpret("matvec__decrypt__result0",
                            {cc, outputEncrypted, TypedCppValue(secretKey)})[0];
  std::vector<float> actual = std::get<std::vector<float>>(actualVal.value);

  EXPECT_NEAR(expected, actual.front(), 1e-6);
}

}  // namespace openfhe
}  // namespace heir
}  // namespace mlir
