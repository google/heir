#include <chrono>
#include <ctime>
#include <iostream>
#include <ostream>
#include <string>
#include <utility>
#include <vector>

#include "lib/Target/OpenFhePke/Interpreter.h"
#include "mlir/include/mlir/IR/BuiltinOps.h"           // from @llvm-project
#include "mlir/include/mlir/IR/MLIRContext.h"          // from @llvm-project
#include "mlir/include/mlir/IR/OwningOpRef.h"          // from @llvm-project
#include "mlir/include/mlir/Parser/Parser.h"           // from @llvm-project
#include "src/core/include/lattice/hal/lat-backend.h"  // from @openfhe
#include "src/pke/include/cryptocontext-fwd.h"         // from @openfhe

namespace mlir {
namespace heir {
namespace openfhe {

using namespace lbcrypto;
using CryptoContextT = CryptoContext<DCRTPoly>;

}  // namespace openfhe
}  // namespace heir
}  // namespace mlir

void reportTime(const std::string& operation,
                const std::chrono::high_resolution_clock::time_point& start,
                const std::chrono::high_resolution_clock::time_point& end) {
  auto duration = std::chrono::duration_cast<std::chrono::seconds>(end - start);
  std::cout << operation << " time: " << duration.count() << " seconds\n";
}

int main(int argc, char* argv[]) {
  // Generated by the bazel rule
  std::string generatedModuleFile = argv[1];

  // Load the MLIR module from a file
  mlir::MLIRContext context;
  mlir::heir::openfhe::initContext(context);
  mlir::OwningOpRef<mlir::ModuleOp> module =
      parseSourceFile<mlir::ModuleOp>(generatedModuleFile, &context);
  mlir::heir::openfhe::Interpreter interpreter(module.get());

  auto start = std::chrono::high_resolution_clock::now();
  mlir::heir::openfhe::TypedCppValue ccInitial =
      interpreter.interpret("lenet__generate_crypto_context", {})[0];
  auto end = std::chrono::high_resolution_clock::now();
  reportTime("lenet__generate_crypto_context", start, end);

  auto keyPair =
      std::get<mlir::heir::openfhe::CryptoContextT>(ccInitial.value)->KeyGen();
  auto publicKey = keyPair.publicKey;
  auto secretKey = keyPair.secretKey;
  std::vector<mlir::heir::openfhe::TypedCppValue> args = {
      ccInitial, mlir::heir::openfhe::TypedCppValue(secretKey)};

  start = std::chrono::high_resolution_clock::now();
  mlir::heir::openfhe::TypedCppValue cc = std::move(
      interpreter.interpret("lenet__configure_crypto_context", args)[0]);
  end = std::chrono::high_resolution_clock::now();
  reportTime("lenet__configure_crypto_context", start, end);

  // Run one inference
  std::vector<float> inputVector(32 * 32, 0.0f);
  start = std::chrono::high_resolution_clock::now();
  mlir::heir::openfhe::TypedCppValue arg0Enc = interpreter.interpret(
      "lenet__encrypt__arg0",
      {cc, mlir::heir::openfhe::TypedCppValue(inputVector),
       mlir::heir::openfhe::TypedCppValue(publicKey)})[0];
  end = std::chrono::high_resolution_clock::now();
  reportTime("lenet__encrypt__arg0", start, end);

  start = std::chrono::high_resolution_clock::now();
  mlir::heir::openfhe::TypedCppValue outputEncrypted =
      interpreter.interpret("lenet", {cc, arg0Enc})[0];
  end = std::chrono::high_resolution_clock::now();
  reportTime("lenet", start, end);

  start = std::chrono::high_resolution_clock::now();
  std::vector<mlir::heir::openfhe::TypedCppValue> actualVal =
      interpreter.interpret(
          "lenet__decrypt__result0",
          {cc, outputEncrypted, mlir::heir::openfhe::TypedCppValue(secretKey)});
  end = std::chrono::high_resolution_clock::now();
  reportTime("lenet__decrypt__result0", start, end);

  return 0;
}
