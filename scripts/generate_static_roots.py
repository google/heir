import argparse
import sys
import pathlib

from sympy.ntheory import n_order, nthroot_mod

def generate_roots(q, ns):
  return [ primitive_2nth_root(n, q) for n in ns ]

def primitive_nth_roots(n, q):
  return [ x for x in nthroot_mod(1, n, q, True) if n_order(x, q) == n]

def smallest_primitive_nth_root(n, q):
  res = primitive_nth_roots(n,q)
  return None if len(res) == 0 else res[0]

def primitive_2nth_root(n, q):
  roots = [ nthroot_mod(a, 2, q) for a in primitive_nth_roots(n, q) ]
  res = [ x for x in roots if x ]
  return None if len(res) == 0 else res[0]

HEADER = """// WARNING: this file is autogenerated. Do not edit manually, instead see
// scripts/generate_static_roots.py

#ifndef INCLUDE_DIALECT_POLYNOMIAL_IR_STATICROOTS_H_
#define INCLUDE_DIALECT_POLYNOMIAL_IR_STATICROOTS_H_

#include <optional>

#include "llvm/include/llvm/ADT/APInt.h"     // from @llvm-project
#include "llvm/include/llvm/ADT/DenseMap.h"  // from @llvm-project

namespace roots {
"""

OPENING_TEMPLATE="""
llvm::DenseMap<std::pair<unsigned, unsigned>, unsigned> STATIC_{size}BIT_ROOTS({{
"""

ENTRY_TEMPLATE="""    {{{{{cmod}, {degree}}}, {root}}},
"""

CLOSING = """});
"""

FOOTER = """
// Attempts to find a 64-bit primitive 2n-th root of unity from the pre-computed
// values, where n is the given degree. find64BitRoot should be used if the
// required bits to represent cMod is greater than 32 and less than or equal to
// 64.
std::optional<llvm::APInt> find64BitRoot(const llvm::APInt& cMod,
                                         unsigned degree, unsigned bitWidth) {
  std::optional<llvm::APInt> root = std::nullopt;
  // We currently only precompute 64 bit and 32 bit values so we can skip
  // greater than that to ensure getZExtValue does not throw an error
  if (cMod.getBitWidth() <= 64) {
    auto rootIt = STATIC_64BIT_ROOTS.find({cMod.getZExtValue(), degree});
    if (rootIt != STATIC_64BIT_ROOTS.end())
      root = llvm::APInt(bitWidth, rootIt->second);
  }
  return root;
}

// Attempts to find a 32-bit primitive 2n-th root of unity from the pre-computed
// values, where n is the given degree. find32BitRoot should be used if the
// required bits to represent cMod is and less than or equal to 32.
std::optional<llvm::APInt> find32BitRoot(const llvm::APInt& cMod,
                                         unsigned degree, unsigned bitWidth) {
  std::optional<llvm::APInt> root = std::nullopt;
  // We currently only precompute 64 bit and 32 bit values so we can skip
  // greater than that to ensure getZExtValue does not throw an error
  if (cMod.getBitWidth() <= 32) {
    auto rootIt = STATIC_32BIT_ROOTS.find({cMod.getZExtValue(), degree});
    if (rootIt != STATIC_32BIT_ROOTS.end())
      root = llvm::APInt(bitWidth, rootIt->second);
  }
  return root;
}

}  // namespace roots

#endif  // INCLUDE_DIALECT_POLYNOMIAL_IR_STATICROOTS_H_
"""

parser = argparse.ArgumentParser(
    description=(
        'Generate a static DenseMap of the primitive roots'
    )
)
parser.add_argument(
    '--cmods',
    metavar='q',
    type=int,
    nargs='*',
    help='A list of coefficient modulus values that should be computed.'
         ' Defaults to [12289, 786433, 8380417].'
)
parser.add_argument(
    'degrees',
    metavar='d',
    type=int,
    nargs='*',
    help='A list of degrees that the root should be computed for each cmod.'
         ' Defaults to [256, 512, 1024, 65536].'
)

def output_map(outfile, cmod_mapping, size, degrees):
  outfile.write(OPENING_TEMPLATE.format(size=size))
  for cmod, roots in cmod_mapping.items():
    for degree, root in zip(degrees, roots):
      if root:
        output = ENTRY_TEMPLATE.format(cmod=cmod, degree=degree, root=root)
        outfile.write(output)
  outfile.write(CLOSING)

def main(args: argparse.Namespace) -> None:
  degrees = args.degrees if args.degrees else [256, 512, 1024, 65536]
  cmods = args.cmods if args.cmods else [12289, 786433, 8380417]

  cmods32 = [ x for x in cmods if x < 2**32 ]
  cmod32_mapping = {}
  for q in cmods32:
    cmod32_mapping[q] = [ primitive_2nth_root(d, q) for d in degrees ]

  cmods64 = [ x for x in cmods if 2**32 <= x <= 2**64 ]
  cmod64_mapping = {}
  for q in cmods32:
    cmod64_mapping[q] = [ primitive_2nth_root(d, q) for d in degrees ]

  heir_root = pathlib.Path(__file__).parent
  static_roots = '../include/Dialect/Polynomial/IR/StaticRoots.h'
  output_fn = heir_root / static_roots
  with open(output_fn.resolve(), 'w') as outfile:
    outfile.write(HEADER)
    output_map(outfile, cmod64_mapping, "64", degrees)
    output_map(outfile, cmod32_mapping, "32", degrees)
    outfile.write(FOOTER)

if __name__ == '__main__':
  main(parser.parse_args())
